---
title: Hot100
date: 2025-08-12 01:57:43
categories:
  - leetcode
tags:
  - leetcode
---

# 哈希

## 两数之和

用哈希表维护一个当前<期望值，当前值>的哈希表即可。



## 字母异位词分组

用一个哈希表维护<字母异位词，原字符串>

>  其中可以将每一个质数代替一个字母，质数相乘独特的字母异位词有独立的质数相乘结果。但是使用此方法要注意存在溢出的风险。

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        HashMap<String, List<String>> hashMap = new HashMap<>();
        for(String str : strs){
            char[] c = str.toCharArray();
            Arrays.sort(c);
            String t = new String(c);
            if(hashMap.containsKey(t)){
                List l = hashMap.get(t);
                l.add(str);
                hashMap.put(t,l);
            } else {
                List<String> l = new ArrayList<>();
                l.add(str);
                hashMap.put(t,l);
            }
        }
        List<List<String>> res = new ArrayList<>();
        for(Map.Entry<String, List<String>> p : hashMap.entrySet()){
            res.add(p.getValue());
        }
        return res;
    }
}
```





## 最长连续序列

本质上还是双指针

```java
class Solution {
    public void moveZeroes(int[] nums) {
        //维护两个指针，p1指向第一个零，p2指向第一个非零
        int p1 = 0;
        int p2 = 0;
        while(p1 < nums.length && p2<nums.length){
            while(nums[p1] != 0) {
            p1++;
        if(p1 >= nums.length) return;
            }
            p2 = p1+1;
            if(p2 >= nums.length) break;
            while(nums[p2] == 0){
            p2 ++;
         if(p2 >= nums.length) return;
            } 
            int t = nums[p1];
            nums[p1] = nums[p2];
            nums[p2] = t;
            p1 = p1+1;
        }
    }
}
```





# 链表

## 相交链表

遍历两次判断交点

```java
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode a = headA;
        ListNode b = headB;
        while( a!=b){
            a=a!= null?a.next:headA;
            b=b!=null?b.next:headB;
        }
        return a;
    }
```





# 矩阵

## 旋转图像

转置后进行轴对称



# 树

## 二叉树中序遍历

中序遍历一下，按照

dfs(root.left)

print(root)

dfs(root.right)

```java
    public static void dfs(TreeNode root){
        if(root==null)
        return;
        dfs(root.left);
        res.add(root.val);
        dfs(root.right);

    }
```



## 二叉树的最大深度

递归查找每一层节点的深度

```java
    public int maxDepth(TreeNode root) {
        return dfs(root);
    }
    static int dfs(TreeNode root){
        if(root == null)
        return 0;
        return Math.max(dfs(root.left),dfs(root.right)) + 1;
    }
```

## 对称二叉树

递归交换检查每层的左右节点是否对称

```java
    public static boolean dfs(TreeNode left, TreeNode right){
        if(left == null && right == null) 
        return true;
        if(left == null && right != null)
        return false;
        if(right == null && left != null)
        return false;
        if(left.val == right.val && dfs(left.left,right.right) && dfs(left.right,right.left) )
        return true;
        return false;
    }
```



## 翻转二叉树

使用递归交换每一层的左右子节点

```
    public static void dfs(TreeNode node){
        if(node == null) return;
        TreeNode t = new TreeNode();
        t = node.left;
        node.left = node.right;
        node.right = t;
        dfs(node.left);
        dfs(node.right);
    }
```



## 二叉树的直径

题目：给你一棵二叉树的根节点，返回该树的 **直径** 。

二叉树的 **直径** 是指树中任意两个节点之间最长路径的 **长度** 。这条路径可能经过也可能不经过根节点 `root` 。

两节点之间路径的 **长度** 由它们之间边数表示。

思路：递归搜索每个节点的左右子树路径和，在主函数使用一个全局变量维护该最大值。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    
    static int ans = 0;
    public int diameterOfBinaryTree(TreeNode root) {
        if(root == null) 
        return 0;
        ans = 1;
        dep(root);
        return ans-1;

    }
    public static int dep(TreeNode node){
        if(node == null) return 0;
        int l = dep(node.left);
        int r = dep(node.right);
        ans = Math.max(ans, l+r+1);
        return Math.max(l,r)+1;
    }
}
```

> 注：二叉树的直径不同于图的直径，图的直径可以通过两次遍历先找到一端的直径端点，然后再找到另一端的直径端点实现，模板如下
>
> ```java
> public static int treeDiameter(int n, List<List<Integer>> adj) {
>         if (n == 0) return 0;
>         // 从任意节点 0 开始 BFS 找最远点
>         int far = bfsFarthest(0, n, adj)[0];
>         // 从 far 再次 BFS，得到最远距离
>         int[] res = bfsFarthest(far, n, adj);
>         return res[1]; // distance
>     }
> 
>     // 返回长度为2的数组: [farthestNode, distance]
>     private static int[] bfsFarthest(int src, int n, List<List<Integer>> adj) {
>         int[] dist = new int[n];
>         Arrays.fill(dist, -1);
>         Queue<Integer> q = new ArrayDeque<>();
>         q.add(src);
>         dist[src] = 0;
>         int farNode = src;
>         while (!q.isEmpty()) {
>             int u = q.poll();
>             for (int v : adj.get(u)) {
>                 if (dist[v] == -1) {
>                     dist[v] = dist[u] + 1;
>                     q.add(v);
>                     if (dist[v] > dist[farNode]) farNode = v;
>                 }
>             }
>         }
>         return new int[]{farNode, dist[farNode]};
>     }
> ```
>
> 

## 二叉树层序遍历

使用一个Queue维护二叉树的每层节点。for循环统计当前层节点数量。

```java
public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res= new ArrayList<>();
        if(root==null){
            return res;
        }
        Deque<TreeNode> d = new ArrayDeque<>();
        d.addLast(root);
        while(!d.isEmpty()){
            int size = d.size();
            List<Integer> t = new ArrayList<>();
            for(int i=0;i<size;i++){
                TreeNode n=d.removeFirst();
                t.add(n.val);
                if(n.left!=null) d.addLast(n.left);
                if(n.right!=null) d.addLast(n.right);
            }
            res.add(t);
        }
        return res;
    }
```

## 数组转化为平衡二叉搜索树

BST递归后序遍历建立树，核心公式：int mid = (l + r) / 2 选中之后再建树，记住就好。

注意二分法的递归范围为

```java
if (left > right) return null;
TreeNode l = dfs(nums, left, mid - 1);
TreeNode r = dfs(nums, mid + 1, right);
```

```java
public TreeNode sortedArrayToBST(int[] nums) {
        return dfs(nums,0,nums.length-1);
    }
    public static TreeNode dfs(int[] nums, int left, int right){
        if(left > right)
        return null;
        int mid = (left + right) / 2;
        TreeNode t = new TreeNode(nums[mid]);
        TreeNode l = dfs(nums,left,mid-1);
        TreeNode r = dfs(nums,mid+1,right);
        t.left = l;
        t.right = r;
        return t;
    }
```



## 验证二叉搜索树

递归查询每个节点是否大于其左子树的最大值，并且小于其右子树的最小值。额外创建两个递归查询左子树的最大值和右子树的最小值。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isValidBST(TreeNode root) {
        return dfs(root);
    }
    static boolean dfs(TreeNode root){
        if(root == null)
        return true;
        int mid = root.val;
        long l = root.left==null? Long.MIN_VALUE: (long)dfs_r(root.left);
        long r = root.right==null? Long.MAX_VALUE: (long)dfs_l(root.right);
        return mid > l && mid < r && dfs(root.left) && dfs(root.right);
    }
    static int dfs_l(TreeNode root){
        if(root.left != null)
            return dfs_l(root.left);
        else 
            return root.val; 
    }
    static int dfs_r(TreeNode root){
        if(root.right!=null){
            return dfs_r(root.right);
        }else{
            return root.val;
        }
    }
}
```



## 二叉搜索树中第K小的元素

其实就是中序遍历到的第k个元素，维护一个全局变量统计一下当前统计到的元素个数。

```java
    static int cnt;
    static int res;
    public int kthSmallest(TreeNode root, int k) {
        cnt = 0;
        dfs(root,k);
        return res;
    }
    static void dfs(TreeNode root, int k){
        if(root == null){
            return; 
        }
        dfs(root.left, k);
        cnt ++;
        if(cnt == k){
            res=root.val;
            return;
        }
        dfs(root.right, k);
    }
```

## 二叉树的右视图

对于同一深度的节点来说，如果右子树存在的话就只能看见右子树，所以我们要从右->左进行遍历，维护一个数组，统计深度为i的层是否已经有节点在右视图中。从顶部到底部访问，可以改为[根->右->左]

注意：其中[右->左]的顺序可以不变,改变[根]的位置可以实现从顶部到底部，但不能从底部到顶部，考虑这一种情况，如果有一个左子树很大，但是右子树很小的二叉树，在[右->左]的递归顺序下，也会优先存储右子树深度较浅的值。

```java
static int[] a;
    static List<Integer> res;
    public List<Integer> rightSideView(TreeNode root) {
        a = new int[100];
        res = new ArrayList<>();
        dfs(root,0);
        return res;
    }
    static void dfs(TreeNode root, int depth){
        if(root == null)
        return;
        if(a[depth] == 0){
            res.add(root.val);
            a[depth] = 1;
        }
        dfs(root.right,depth + 1);
        dfs(root.left,depth + 1);

    }   
```

## 二叉树展开为链表

![image-20250930235317445](https://raw.githubusercontent.com/yicizhang00/image_host/main/blog-img/202509302353722.png)

解法一：采用头插法构建链表，也就是从节点 6 开始，在 6 的前面插入 5，在 5 的前面插入 4，依此类推。

为此，要按照 6→5→4→3→2→1 的顺序访问节点。如何遍历这棵树，才能实现这个顺序？

考虑到链表为先序遍历的结果，我们要将递归的根节点的右子树指向【右->左->根】的访问到的倒数第二个节点，所以需要反向遍历为【右->左->根】，用全局变量记录下访问到的根节点。

```java
    private static TreeNode head;
    
    public void flatten(TreeNode root) {
        head=null;
        dfs(root);

    }
    public static void dfs(TreeNode node){
        if(node == null)
        return;
        dfs(node.right);
        dfs(node.left);
        node.left = null;
        node.right = head;
        head = node;

    }
```

解法二：

正常使用先序遍历的结果，由于进入递归后，但是依然要使用全局变量记录下前一个节点，以及当前节点的原始右子树。

```java
private static TreeNode pre; // 记录前一个访问过的节点

public void flatten(TreeNode root) {
    pre = null;   // 每次调用前要清空
    dfs(root);
}

public static void dfs(TreeNode node) {
    if (node == null) return;

    // 如果 pre 已经存在，把 pre 的 right 指向当前节点
    if (pre != null) {
        pre.left = null;   // 左子树要断掉
        pre.right = node;  // 前一个节点的右指针连到当前节点
    }
    pre = node; // 更新 pre，表示“当前节点就是下一个节点的前驱”

    // ⚠️ 保存右子树，避免被覆盖
    TreeNode right = node.right;

    // 递归处理左子树
    dfs(node.left);

    // 递归处理原始右子树
    dfs(right);
}
```

## 从前序与中序遍历序列构造二叉树

由于前序是[根->左->右]，每个节点的构造由一个全局变量维护，不要将这个全局变量作为递归的变量传入！中序是[左->根->右]，可以使用前序的[根]找到中序[根的位置]，然后中序[根]的左右分别为左右子树。

```java
class Solution {
    private int i = 0;
    private int[] preorder;
    private int[] inorder;
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        this.preorder = preorder;
        this.inorder = inorder;
        return dfs(0,preorder.length-1);
    }
    public TreeNode dfs(int j, int k){
        if(j > k)
        return null;
        int root = this.preorder[i];
        int n = 0;
        for(int m = j; m <= k;m++){
            if(this.inorder[m] == root){
                n = m;
                break;
            }
        }
        TreeNode node = new TreeNode(root);
        i++;
        node.left = dfs(j,n-1);
        node.right = dfs(n+1,k);
        return node;
    }
}
```

## 路径综合III

使用两层递归

```java
class Solution {
    private int res = 0;
    public int pathSum(TreeNode root, int targetSum) {
        if(root == null) return 0;
        dfs(root,targetSum);
        pathSum(root.left, targetSum);
        pathSum(root.right,targetSum);
        return res;
    }
    public void dfs(TreeNode root, int targetSum){
        if(root == null){
            return;
        }
        int val = root.val;
        if(val == targetSum){
            res ++;
        }
        
        dfs(root.left, targetSum - val);
        dfs(root.right, targetSum - val);
    }
}

```



使用全局变量记录路径和为n的次数为m，然后使用回溯法+一层递归

```java
class Solution {
    private int res = 0;
    private Map<Long, Integer> prefix = new HashMap<>();

    public int pathSum(TreeNode root, int targetSum) {
        prefix.put(0L, 1); // 前缀和为 0 出现过 1 次（空路径）
        dfs(root, 0L, targetSum);
        return res;
    }

    private void dfs(TreeNode node, long currSum, int targetSum) {
        if (node == null) return;

        currSum += node.val;

        // 找到满足条件的路径数
        res += prefix.getOrDefault(currSum - targetSum, 0);

        // 更新前缀和
        prefix.put(currSum, prefix.getOrDefault(currSum, 0) + 1);

        // 递归子树
        dfs(node.left, currSum, targetSum);
        dfs(node.right, currSum, targetSum);

        // 回溯，撤销当前节点的贡献
        prefix.put(currSum, prefix.get(currSum) - 1);
    }
}

```

## 二叉树的最近公共祖先

定义dfs为**在以当前节点为根的子树中，返回找到的 `p`、`q` 或者公共祖先**。

![image-20251001020021223](https://raw.githubusercontent.com/yicizhang00/image_host/main/blog-img/202510010200515.png)

```
class Solution {
    private TreeNode m;
    private TreeNode n;
    private TreeNode res;
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        m = p;
        n = q;
        
        return dfs(root);
    }
 
    public TreeNode dfs(TreeNode node){
        if(node == null || node == n || node == m){
            return node;
        }
        TreeNode l = dfs(node.left);
        TreeNode r = dfs(node.right);
        if(l!=null && r!=null){
            return node;
        }
        return l==null?r:l;
    }
}
```

## 二叉树中的最大路径和

和二叉树的直径类似，使用递归函数维护一个当前节点向下走单边路径的最大值

**dfs 的含义**

- 返回值：从当前节点出发，**向下走一条单边路径**（只能选左子树或右子树，不可能两边都选，因为往父节点传递的时候只能走一边）。
- 如果子树路径和为负数，那还不如不要，所以用 `Math.max(..., 0)`。

**res 的含义**

- `res` 是一个全局变量，存储 **当前遍历过程中出现的最大路径和**。

- 在每个节点 `root` 处，路径最大值可能是：

  ```
  左子树贡献 + root.val + 右子树贡献
  ```

  这个结果可以形成一条经过 `root` 的完整路径，因此要用它更新 `res`。

**为什么返回 `root.val + Math.max(l, r)`**

- 父节点只能选择一边接上当前节点的路径。
- 所以返回值是 “当前节点值 + 左右子树中较大的一边”。

```java
class Solution {
    private int res = 0;

    public int maxPathSum(TreeNode root) {
        if(root == null) 
            return 0;
        res = root.val;       // 初始化结果为根节点值，避免 res 初始值太小
        dfs(root);            // 深度优先遍历计算
        return res;
    }

    // 返回 "以 root 为起点，到叶子方向的最大路径和"
    public int dfs(TreeNode root){
        if(root == null){
            return 0;
        }
        // 分别计算左子树、右子树的最大贡献（小于0的路径直接舍弃，所以用 Math.max(..., 0)）
        int l = Math.max(dfs(root.left), 0);
        int r = Math.max(dfs(root.right), 0);

        // 更新全局最大路径：可能经过当前 root，路径 = 左贡献 + root.val + 右贡献
        res = Math.max(res, l + r + root.val);

        // 返回 "当前节点能提供给父节点的最大单边贡献"
        return root.val + Math.max(l, r);
    }
}

```

# 图论

## 岛屿数量

dfs递归感染四周岛屿，将岛屿由'1'变为'2'，通过边界条件控制感染。

```java
class Solution {
    private int res =0;
    public int numIslands(char[][] grid) {
        for(int i = 0 ; i < grid.length;i++){
            for(int j = 0; j < grid[0].length;j++){
                if(grid[i][j] == '1'){
                    dfs(grid,i,j);
                    res ++;
                }
            }
        }
        return res;
        
    }
    public void dfs(char[][] grid ,int i ,int j){
        if(i <0 || i >= grid.length || j <0 || j>=grid[0].length || grid[i][j] != '1'){
            return;
        }
        grid[i][j] = '2';
        dfs(grid,i-1,j);
        dfs(grid,i+1,j);
        dfs(grid,i,j+1);
        dfs(grid,i,j-1);
    }
}
```

## 腐烂的橘子

类似于图的层序遍历

```java

    class Node{
    int x;
    int y;
    Node(int x,int y){
        this.x = x;
        this.y = y;
    }
    public int getX(){
        return x;
    }
    public int getY(){
        return y;
    }
    }

class Solution {

    public int orangesRotting(int[][] grid) {
        int res = -1;
        int fresh =0 ;
            int m = grid.length;
            int n = grid[0].length;
            
            Deque<Node> d = new ArrayDeque<>();
            for(int i = 0 ; i < m; i ++){
                for(int j = 0 ;j<n;j++){
                    if(grid[i][j] == 2){
                        Node node = new Node(i,j);
                        d.addLast(node);
                    } else if (grid[i][j] == 1){
                        fresh ++;
                    }
                }
            }
            while(!d.isEmpty()){
                res++;
                int size = d.size();
                for(int k = 0 ; k < size ; k++){
                    Node t = d.removeFirst();
                    int x = t.getX();
                    int y = t.getY();
                    if(x + 1 < m && grid[x+1][y] == 1){
                        Node t1 = new Node(x+1,y);
                        d.addLast(t1);
                        grid[x+1][y]='2';
                        fresh--;
                    }
                    if( x - 1 >=0 && grid[x-1][y] == 1){
                        Node t1 = new Node(x-1,y);
                        d.addLast(t1);
                        grid[x-1][y]='2';
                        fresh--;
                    }
                    if( y-1 >=0 && grid[x][y-1] == 1){
                        Node t1 = new Node(x,y-1);
                        d.addLast(t1);
                        grid[x][y-1]='2';
                        fresh--;
                    }
                    if(y+1 < n && grid[x][y+1] == 1){
                        Node t1 = new Node(x,y+1);
                        d.addLast(t1);
                        grid[x][y+1]='2';
                        fresh--;
                    }
                }
            }
            return fresh==0?Math.max(0,res):-1;
    }
}

```

## 课程表

构造一个邻接表，用拓扑排序的方式遍历，计算最后是否有节点无法被写入拓扑排序中

```java
class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        //入度统计
        int[] inDegree = new int[numCourses];
        //建图
        List<List<Integer>> graph = new ArrayList<>();
        for(int i = 0 ; i < numCourses; i ++){
            List<Integer> l = new ArrayList<>();
            graph.add(l);
        }
        for(int i = 0 ; i < prerequisites.length;i++){
            int a = prerequisites[i][0];
            int b = prerequisites[i][1];
            graph.get(a).add(b);
            inDegree[b] ++;
        }
        //统计删除点的数量
        List<Integer> res = new ArrayList<>();
        //入度为0的点加入队列
        Deque<Integer> d = new ArrayDeque<>();
        for(int i = 0 ; i < numCourses ; i++){
            if(inDegree[i] == 0){
                d.addLast(i);
                res.add(i);
            }

        }
        while(!d.isEmpty()){
            int size = d.size();
            for(int i = 0 ; i < size ; i ++){
                //找到所有入度为0的点所指向的边
                int c = d.removeFirst();
                List<Integer> t = graph.get(c);
                for(int m  : t){
                    inDegree[m]--;
                    //如果导致其入度为0，则入队
                    if(inDegree[m] == 0){
                        d.addLast(m);
                        res.add(m);
                    }
                }
            }
        }
        //判断是否删除了所有节点
        if(res.size() == numCourses){
            return true;
        }
        return false;

    }
}
```

## 前缀树Trie

前缀树实际上就是一个多节点的树，用HashMap<Character,Trie>或者Tire[]来维护子节点，然后在每个节点额外维护一个符号表示是否有输入到此为止。

```java
class Trie {
    HashMap<Character, Trie> hashMap;
    int flag ;
    public Trie() {
        hashMap = new HashMap<>();        
        flag = 0;
    }
    
    public void insert(String word) {
        Trie t = this;
        int len = word.length();
        for(int i = 0 ; i < len ; i ++){
            char c = word.charAt(i);
            if(t.hashMap.containsKey(c)){
                t = t.hashMap.get(c); 
            } else {
                Trie trie = new Trie();
                t.hashMap.put(c,trie);
                t = trie;
            }
        }
        t.flag = 1;
    }
    
    public boolean search(String word) {
        Trie t = this;
        int len = word.length();
        for(int i = 0 ; i < len ; i ++){
            char c = word.charAt(i);
            if(t.hashMap.containsKey(c)){
                t = t.hashMap.get(c); 
            } else {
                return false;
            }
        }
        return t.flag == 1 ? true : false;
    }
    
    public boolean startsWith(String prefix) {
        Trie t = this;
        int len = prefix.length();
        for(int i = 0 ; i < len ; i ++){
            char c = prefix.charAt(i);
            if(t.hashMap.containsKey(c)){
                t = t.hashMap.get(c); 
            } else {
                return false;
            }
        }
        return true;
    }
}

/**
 * Your Trie object will be instantiated and called as such:
 * Trie obj = new Trie();
 * obj.insert(word);
 * boolean param_2 = obj.search(word);
 * boolean param_3 = obj.startsWith(prefix);
 */
```

# 栈



## 有效的括号

维护一个符号栈

```java
class Solution {
    public boolean isValid(String s) {
        //维护一个栈
        Deque<Character> stack = new ArrayDeque<>();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            switch (c) {
                case '(':
                    stack.addLast(c);
                    break;
                case ')':
                    if (stack.isEmpty() ||stack.peekLast() != '(')
                        return false;
                    stack.removeLast();
                    break;
                case '[':
                    stack.addLast(c);
                    break;
                case ']':
                    if (stack.isEmpty() || stack.peekLast() != '[')
                        return false;
                    stack.removeLast();
                    break;
                case '{':
                    stack.addLast(c);
                    break;
                case '}':
                    if (stack.isEmpty() || stack.peekLast() != '{')
                        return false;
                    stack.removeLast();
                    break;
                default:
                    return false;
            }
            ;

        }
        if (stack.isEmpty()) {
            return true;
        }
        return false;
    }
}
```



## 最小栈

在每个节点入栈时，维护当前入栈时的最小值

```java
class MinStack {
Stack<int[]> s1;

    public MinStack() {
        s1 = new Stack<>();
    }
    
    public void push(int val) {
        if(!s1.isEmpty()){
            int[] t = s1.peek();
            if(val < t[1]){
                s1.push(new int[]{val,val});
            } else {
                s1.push(new int[]{val,t[1]});
            }
        } else {
            s1.push(new int[]{val,val});
        }
    }
    
    public void pop() {
        int[] t = s1.pop();
    }
    
    public int top() {
        int[] t = s1.peek();
        return t[0];
    }
    
    public int getMin() {
        int[] t = s1.peek();
        return t[1];
    }
}

```

## 每日温度

还是维护一个单调栈，栈里面的pair对分别为index和nums[index]

```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        //维护一个单调递减的栈
        Stack<int[]> s = new Stack<>();
        int[] res = new int[temperatures.length];
        for(int i = 0 ;  i< temperatures.length;i++){
            int[] x  = new int[]{temperatures[i], i};
            if(s.isEmpty()){
                s.push(x);
            } else {
                while(!s.isEmpty() && s.peek()[0] < x[0]){
                    int[] t = s.pop();
                    res[t[1]] = i - t[1];
                }
                s.push(x);
            }
        }
        for(int i=0;i<s.size();i++){
            int[] t = s.pop();
            res[t[1]] = 0;
        }
        
        return res;
    }
}
```



## 柱状图中的最大矩形

维护两个单调栈

```java
class Solution {
        public int largestRectangleArea(int[] heights) {
        //找到每个位置[i]两侧，第一个小于heights[i]的元素位置。两侧维护单调递增的栈。
        //dp数组维护[i]到两侧的长度
        Stack<int[]> s_l = new Stack<>();
        Stack<int[]> s_r = new Stack<>();
        int n = heights.length;
        int[] r = new int[n];
        int[] l = new int[n];
        for(int i=0; i < n ;i++){
            int j = n - 1 - i;
            int[] x = new int[]{heights[i], i};
            int[] y = new int[]{heights[j], j};
            if(s_r.isEmpty()){
                s_r.push(x);
            } else {
                while(!s_r.isEmpty() && s_r.peek()[0] > x[0]){
                    int[] t = s_r.pop();
                    r[t[1]] = i - t[1];
                }
                s_r.push(x);
            }

            if(s_l.isEmpty()){
                s_l.push(y);
            } else {
                while(!s_l.isEmpty() && s_l.peek()[0] > y[0]){
                    int[] t = s_l.pop();
                    l[t[1]] = t[1] - j ;
                }
                s_l.push(y);
            }
        }
        int s_r_size = s_r.size();
        for(int i = 0 ; i < s_r_size;i++){
            int[] t = s_r.pop();
            r[t[1]] = n  - t[1];
        }
        int s_list_size = s_l.size();
        for(int j = 0 ; j < s_list_size;j++){
            int[] t = s_l.pop();
            l[t[1]] = t[1] + 1;
        }

        int res = Integer.MIN_VALUE;
        for(int k = 0 ; k < n ; k ++){
            if(r[k] == 1 || r[k] == 0){
                r[k] = 0;

            } else {
                r[k] --;
            }
            if(l[k] == 1 || l[k] == 0){
                l[k] = 0;

            } else {
                l[k] --;
            }

        }
        for(int k = 0 ; k < n ; k ++){
            res = Math.max(res, heights[k] * (r[k] + l[k] +1 ));
        }

        return res;

    }
}
```



# 贪心算法

## 买卖股票的最佳时机

1. 买一次卖一次
2. 卖的时间>买的时间

解法：维护一个从0到i的最小值的dp数组

```java
class Solution {
    public int maxProfit(int[] prices) {
        //维护一个从0到i的最小值的dp
        int n = prices.length;
        if(n==0)
        return 0;
        int[] dp = new int[n]; 
        dp[0] = prices[0];
        int res = Integer.MIN_VALUE;
        for(int i = 1 ; i < n ; i ++){
            dp[i] = Math.min(prices[i] , dp[i-1]);
            res = Math.max(res, prices[i] - dp[i]);
        }
        return res < 0 ? 0 : res;
    }
}
```

## 跳跃游戏

用dp[i]维护i+nums[i]的地点是否可达

```java
class Solution {
    public boolean canJump(int[] nums) {
        //dp的含义为维护一个i所在的地点是否可达
        int[] dp = new int[nums.length];
        dp[0] = 1;
        for(int i = 0 ; i < nums.length;i++){
            if(dp[i] == 0) return false;
            int step=i+nums[i];
            for(int j = i ; j <= step; j ++){
                if(j<nums.length)
                    dp[j] =1;
            }
        }
        return true;
         
    }
}
```



## 跳跃游戏II

和跳跃游戏I类似，dp[i]要维护到i这个地点所有的步数的最小值

```java
class Solution {
    public int jump(int[] nums) {
        //dp[i]维护到i所用的步数
        int n = nums.length;
        int[] dp = new int[n];
        Arrays.fill(dp,Integer.MAX_VALUE);
        dp[0] = 0;
        for(int i = 0; i < n; i ++){
            int step = i + nums[i];
            for(int j = i ; j <= step ; j++){
                if(j < n){
                    dp[j] = Math.min(dp[j],dp[i]+1); 
                }
            }
            
        }
        return dp[n-1];
    }
}
```

## 划分字母区间

1. 题目的意思是一个字母只能在一个区间内出现
2. 这实际上就是区间合并

```java
class Solution {
    public List<Integer> partitionLabels(String s) {
        //1.获得每个字符的左右边界
        HashMap<Character,int[]> hashMap = new HashMap<>();
        int n = s.length();
        for(int i = 0 ; i < n ; i ++){
            char c = s.charAt(i);
            if(hashMap.containsKey(c)){
                int[] seg = hashMap.get(c);
                seg[1] = i;
                hashMap.put(c,seg);
            } else {
                int[] seg = new int[]{i,i};
                hashMap.put(c,seg);
            }
        }
        int m = hashMap.size();
        int[][] in = new int[m][];
        int p = 0;
        for(Map.Entry<Character,int[]> e : hashMap.entrySet()){
            char e1 = e.getKey();
            int[] e2 = e.getValue();
            in[p] = e2;
            p++;
        }

        //2.将所有区间合并,首先将所有区间按照左界由小到大排序、
        Arrays.sort(in, (a,b) -> Integer.compare(a[0],b[0]));
        List<Integer> res = new ArrayList<>();
        int curLeft = in[0][0];
        int curRight = in[0][1];
        for(int i = 1 ; i < m ; i ++){
            //可以合并
            if(curRight >= in[i][0]){
                curRight = Math.max(curRight,in[i][1]);
            } else { //不能合并
                int len = curRight - curLeft + 1;
                res.add(len);
                curLeft = in[i][0];
                curRight = in[i][1];
            }
        }
        res.add(curRight-curLeft + 1);


        return res;
    }
}
```



# 动态规划

## 爬楼梯

实际上是斐波那契数列

```java
class Solution {
    public int climbStairs(int n) {
        if( n <= 2) return n;
        int[] dp = new int[n+1];
        dp[1] = 1;
        dp[2] = 2;
        for(int i = 3 ; i <= n ; i ++){
            dp[i] = dp[i-1] + dp[i - 2];
        }
        return dp[n];
    }
}
```

## 杨辉三角

```java
class Solution {
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> res = new ArrayList<>();
            List<Integer> t0 = new ArrayList<>();
            t0.add(1);
            res.add(t0);
        if(numRows == 1){
            return res;
        }
            List<Integer> t1 = new ArrayList<>();
            t1.add(1);
            t1.add(1);
            res.add(t1);
        if(numRows == 2){
            return res;
        }
        
        for(int i = 2 ; i < numRows ; i ++){
            List<Integer> t = new ArrayList<>();
            t.add(1);
            for(int j = 1 ; j < i ; j ++){
                t.add(res.get(i-1).get(j-1) + res.get(i-1).get(j));
            }
            t.add(1);
            res.add(t);
        }
        return res;   
    }
}
```

## 完全平方数之和

这是一个完全背包问题，递推公式为
$$
dp[i] = 1 + min_{j}^{\sqrt{i}} dp[i-j^2]
$$

```
class Solution {
    public int numSquares(int n) {
        int[] dp = new int[n + 1];
        dp[1] = 1;
        for(int i = 1 ; i < n + 1; i ++ ){
            int minn = Integer.MAX_VALUE;
            for(int j = 1 ; j*j<=i;j++){
                minn = Math.min(minn, dp[i - j * j]);
            }
            dp[i] = minn + 1;
        }
        return dp[n];
    }
}
```







## 零钱兑换

和完全平方数之和类似，是一个完全背包问题，递推公式为：
$$
dp[i] = 1 + min_{j \in coins} dp[i-j]
$$

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
        for (int i = 1; i <= amount; i++) {
            int minn = Integer.MAX_VALUE;
            for (int j = 0; j < coins.length; j++) {
                if (i - coins[j] >= 0)
                    minn = Math.min(minn, dp[i - coins[j]]);
            }
            if (minn != Integer.MAX_VALUE)
                dp[i] = minn +1;
                 else dp[i] = Integer.MAX_VALUE;
        }
        return dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount];
    }
}
```



## 拆分单词

依然是一个完全背包问题，记录一下，递推公式：

但是需要额外处理一下，dp[i]应该为或的关系，即只要出现满足的单词前缀即可。
$$
dp[i] = dp[i] \ || \ dp[i-t.length()]
$$

```java
class Solution {
   public boolean wordBreak(String s, List<String> wordDict) {
        //还是背包问题
        //分段去截取
        boolean dp[] = new boolean[s.length()+1];
        dp[0] = true;
        for(int j = 1 ; j <= s.length(); j++){
            for(int k = 0 ; k < wordDict.size(); k ++){
                String t = wordDict.get(k);
                if( j - t.length() < 0 )
                    continue;
                if(s.substring( j - t.length(), j).equals(t) && dp[j - t.length()]){

                    dp[j] = dp[j - t.length()];
                }
            }
        }
        return dp[s.length()];

    }
}
```

## 最长递增子序列

解法一：维护一个普通的动态规划

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int n = nums.length;
        int res = 1;
        int[] dp = new int[n+1];
        dp[0] = 1;
        for(int i = 1; i <n ; i ++){
            int t = 0;
            for(int j = i - 1 ; j>= 0 ; j --){
                if(nums[j] < nums[i]){
                    t = Math.max(t, dp[j]);
                }
            }

            dp[i] = t + 1;
            res = Math.max(res, dp[i]);
        }
        return res;
    }
}
```



解法二：

二分查找+贪心

维护一个辅助数组 p，它的每一项 p[i] 的含义是，所有长度为 i+1 的上升子序列的末尾元素中的最小值

参考: https://writings.sh/post/longest-increasing-subsequence-revisited





## 分割等和子集

**01 背包问题的“可达性版本”**：

```java
public boolean canPartition(int[] nums) {
        int n = nums.length;

        int sum = 0;
        for(int i = 0 ; i < n ; i ++){
            sum += nums[i];

        }
        if(sum % 2 == 1) return false;
        int[] dp = new int[sum];
        dp[0] = 1;

        int halfSum = sum / 2;
        for(int i = 0 ; i < nums.length ; i ++){
            for(int j = halfSum; j >= nums[i] ; j --){
                dp[j] = Math.max(dp[j],dp[j-nums[i]]);
            }
        }
        return dp[halfSum] == 1 ? true : false;
    }
```



## 最长有效括号

1. 首先判断当前位是否能组成括号，是为1，否为0
2. 转为判断最长连续1的问题

```java
class Node{
    char c;
    int index;
    public Node(char c, int index){
        this.c = c;
        this.index = index;
    }
    char getC(){
        return this.c;
    }
    int getIndex(){
        return this.index;
    }
}
class Solution {
    public int longestValidParentheses(String s) {
        //
        int n = s.length();
        if(s.length() == 0) return 0;
        int[] num = new int[n];
        Stack<Node> stack = new Stack<>();
        for(int i = 0 ; i  <  s.length();i++){
            char c = s.charAt(i);
            switch(c){
                case '(' :
                    Node t = new Node(c,i);
                    stack.push(t);
                    break;
                case ')' :
                    if(!stack.isEmpty() && stack.peek().getC() == '('){
                        Node t1 = stack.pop();
                        num[i] = 1;
                        num[t1.getIndex()] = 1;
                    }
                    break;
                default:
                return 0;
            }
        }
        //获得了一个0为不匹配，1为匹配的num[]，现在要求最长的连续1的序列
        int res = 0;
        int temp = 0;
        for(int i = 0 ; i < n ; i ++){
            if(num[i] == 1){
                temp ++;
            } else{
                
                temp = 0;
            }
            res = Math.max(res,temp);

        }
        return res;
    }
}
```





# 技巧

## 只出现一次的数字，其他数字

使用异或操作，异或操作的特性：

1. a ^ a = 0
2. a ^ 0 = a

3. 异或具有交换律

```java
class Solution {
    public int climbStairs(int n) {
        if( n <= 2) return n;
        int[] dp = new int[n+1];
        dp[1] = 1;
        dp[2] = 2;
        for(int i = 3 ; i <= n ; i ++){
            dp[i] = dp[i-1] + dp[i - 2];
        }
        return dp[n];
    }
}
```

## 多数元素

多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素。

采用投票法，意味着在元素抵消的过程中，多数元素必定会留下。

```java
class Solution {
    public int majorityElement(int[] nums) {
        int cur = nums[0];
        int cnt = 1;
        for(int i = 1 ; i < nums.length;i++){
            if(cnt == 0){
                cur = nums[i];
                cnt ++;
                continue;
            }
            if(nums[i] == cur){
                cnt ++ ;
            } else {
                cnt -- ;

            }
        }
        return cur;
    }
}
```

