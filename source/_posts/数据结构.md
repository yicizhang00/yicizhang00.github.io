---
title: 数据结构
date: 2025-08-12 01:55:16
tags:
categories: 
  - 数据结构 
  - java
---
# 数据结构

## 1.基本数据类型

Java中基本数据类型有8种：short(2 Byte), int(4 Byte), float(4 Byte) , long(8 Byte), double(8 Byte), byte(1 Byte), boolean(1 bit), char(1 Byte)

| 数据类型   | 关键字  | 大小  | 取值范围                   | 默认值   | 包装类    |
| :--------- | :------ | :---- | :------------------------- | :------- | :-------- |
| 字节型     | byte    | 1字节 | -128 ~ 127                 | 0        | Byte      |
| 短整型     | short   | 2字节 | -32768 ~ 32767             | 0        | Short     |
| 整型       | int     | 4字节 | -2³¹ ~ 2³¹-1               | 0        | Integer   |
| 长整型     | long    | 8字节 | -2⁶³ ~ 2⁶³-1               | 0L       | Long      |
| 单精度浮点 | float   | 4字节 | ±3.4^38                    | 0.0f     | Float     |
| 双精度浮点 | double  | 8字节 | ±1.7^308                   | 0.0d     | Double    |
| 字符型     | char    | 2字节 | '\u0000' ~ '\uffff'(UTF-8) | '\u0000' | Character |
| 布尔型     | boolean | 1位   | true/false                 | false    | Boolean   |

### 浮点数精度

浮点数采用IEEE754存储，浮点数无法精确表示。

```java
System.out.println(0.1 + 0.2); // 输出：0.30000000000000004
```

因此进行浮点数比较是否相等时必须使用差值小于某一值

```java
if(a - b < 1e-9) return true;
```

### float 与 double

所有单独出现的小数均默认为double类型，如果要定义float类型，后面必须加f后缀。

```java
float f = 3.14f;        // 必须加f后缀
double d = 3.14;        // 默认double
```

### 转换

#### 隐式转换

小类型转化为大类型不会丢失精度。

```
byte → short → int → long → float → double
         ↓
        char
```

#### 强制转换

大类型强制转为小类型，可能存在精度丢失。

```java
float a = 3.14f;
int b = (int) a;
```

### 数据装箱、拆箱

#### 基本概念

**装箱**：基本类型 → 包装类型

**拆箱**：包装类型 → 基本类型

```java
// 自动装箱
Integer i = 10;         // 等价于 Integer.valueOf(10)

// 自动拆箱
int n = i;              // 等价于 i.intValue()
```

#### 运算时自动装箱、拆箱

JDK1.5+的新特性：int 可以直接和Integer类型直接进行运算，自动进行`intValue()`和`valueOf()`

```java
int primitiveInt = 10;
Integer wrapperInteger = 20;

// 情况1：结果赋值给基本数据类型 int
// 过程：wrapperInteger 被拆箱为 int，然后与 primitiveInt 相加
int resultToPrimitive = primitiveInt + wrapperInteger;
System.out.println("结果赋值给 int: " + resultToPrimitive); // 输出：30

// 情况2：结果赋值给包装类 Integer
// 过程：wrapperInteger 被拆箱 -> 相加 -> 结果 30 被自动装箱为 Integer
Integer resultToWrapper = primitiveInt + wrapperInteger;
System.out.println("结果赋值给 Integer: " + resultToWrapper); // 输出：30

// 情况3：直接在表达式中使用（如打印、作为参数传递）
// 过程：wrapperInteger 被拆箱 -> 相加 -> 输出 int 结果
System.out.println("直接运算并打印: " + (primitiveInt + wrapperInteger)); // 输出：30

// 这个过程等价于早期没有自动拆箱/装箱时的手动操作：
int manualResult = primitiveInt + wrapperInteger.intValue(); // 手动拆箱
System.out.println("手动拆箱等效操作: " + manualResult); // 输出：30
```

#### 缓存机制（IntegerCache）

当Java对某些**特定范围**的整型数据进行自动装箱时，它不会每次都创建一个新的对象，而是会从一个预先创建好的**缓存数组**中直接获取对应的包装类对象。

例如：对于Integer来说，其缓存范围在-128~127(通常情况下这个范围内的数据使用频率较高)，意味着在创建该范围内的对象时，其使用的对象将会重用同一缓存内的对象。

```java
Integer a = 127;
Integer b = 127;
System.out.println(a == b);      // true (同一对象)
System.out.println(a.equals(b)); // true (值相等)

Integer c = 128;
Integer d = 128;
System.out.println(c == d);      // false (不同对象)
System.out.println(c.equals(d)); // true (值相等)
```

而当

```java
Integer a = 127;
Integer b = 127;
System.out.println(a == b); // true - 因为指向缓存中的同一个对象

// 进行 i1 + 1 操作
Integer result = a + 1;      // 这里会发生什么？
System.out.println(a);       // 仍然是 127
System.out.println(b);       // 仍然是 127
System.out.println(result == b); // false - result 是新的 Integer 对象
```

对于一个Integer类型的值进行运算，其会先拆箱接着装箱

```java
Integer result = i1 + 1;
// 等价于：
// int temp = i1.intValue() + 1;  // 拆箱，temp = 128
// Integer result = Integer.valueOf(temp); // 装箱
```

- Integer类型是`immutable`的，一旦创建值就不能改变，想要改变必须先拆箱后装箱。

- Integer是一个类，而int是基本数据类型，因此Integer可以等于`null`，而int不行。

- ` =` 运算会比较JVM中的地址，而`equals()`则有其不同的重写方法，通常情况下会比较对象所含的值。

### 常用方法

#### valueOf()

 参数为基本数据类型，返回包装类对象； 

```java
Integer a = Integer.valueOf(100);
```

参数为String字符串（Character类没有以String为  参数的该方法）,返回包装类对象；

```java
Integer a = Integer.valueOf("100");
```

#### parseInt()

参数为字符串，返回基本数据类型；

```java
int a = Integer.parseInt("100";)
```

## 2.数组

### int[]

数组是用于存储**固定大小**、**相同类型**元素的线性数据结构。其继承于Object类型，拥有`Objet.toString()`,`Object.equals()`,和`Obejct.hashCode()`等方法，并且保存在**JVM的堆**中。

数组的声明方式如下：

```java
int[] a = new int[];//声明数组，然后全部初始化为对应值。整数：0，浮点：0.0，boolean：false，引用类型：null
int[] a = {1,2,3};//java风格
int a[] = {1,2,3};//c风格
```

由于数组一旦声明长度就不可变，其以连续空间的形式存储在堆中，因此在随机访问时，可以通过下标×偏移量加首地址的方式计算出目标地址，随机访问的时间复杂度为`O(1)`。

### List

List<E> 继承了Collection<E>， Collection<E> 继承了Iterable<E>。

- `Collection<E>`: 所有集合类（如 Set, List, Queue）的根接口，定义了添加、删除、遍历等基本操作。
- `Iterable<E>`: `Collection`的父接口，意味着所有 `List`都可以使用 **for-each 循环**进行迭代。

```java
List (接口)
├── ArrayList (数组实现，随机访问快)
├── LinkedList (链表实现，插入删除快)
├── Vector (线程安全，已过时，所有方法都用Synchronized修饰，性能差)
│   └── Stack (栈实现，继承Vector，同样有性能问题，推荐使用ArrayDueue实现)
└── CopyOnWriteArrayList (线程安全，写时复制)
```

#### ArrayList

ArrayList的底层结构是动态数组，ArrayList **不是线程安全的**，在多线程环境下需要同步。

如何创建一个线程安全的List：

```java
List<String> syncList = Collections.synchronizedList(new ArrayList<>());//使用synchronizedList加锁
List<String> safeList = new CopyOnWriteArrayList<>();
```

<div style="border: 2px solid #150404ff; border-radius: 10px; padding: 10px; background: #f8f9fa;">
☆如何创建一个动态扩容数组：ArrayList的底层就是一个 Object[] elementData。默认初始容量为10，当添加元素导致容量不足时，它会创建一个新的更大数组（通常是原容量的1.5 倍，太小扩容频繁，太大浪费空间，1.5倍是经验值），然后使用 Arrays.copyOf()（内部是 System.arraycopy()）将旧数组的数据拷贝到新数组中。
</div>

#### LinkedList

LinkedList的底层结构是双向链表，同样**不是线程安全的**，在多线程环境下需要同步。

LinkedList可以作为Queue和Dueue的底层结构。

```java
// 作为队列使用
Queue<String> queue = new LinkedList<>();
queue.offer("a"); // 入队
queue.poll();     // 出队

// 作为双端队列
Deque<String> deque = new LinkedList<>();
deque.offerFirst("a");
deque.offerLast("b");
```



| 特性         | ArrayList                   | LinkedList                 |
| :----------- | :-------------------------- | :------------------------- |
| **底层结构** | 动态数组                    | 双向链表                   |
| **随机访问** | O(1)                        | O(n)                       |
| **头部插入** | O(n)                        | O(1)                       |
| **尾部插入** | 均摊O(1)                    | O(1)                       |
| **中间插入** | O(n)                        | O(n)                       |
| **内存占用** | 较小（连续内存）            | 较大（每个元素含两个指针） |
| **缓存友好** | 是(CPU在取值的时候可以预取) | 否                         |

**如何选择 ArrayList 和 LinkedList？**

> 根据具体场景：如果需要频繁随机访问，选择ArrayList；如果需要频繁在头部插入删除，选择LinkedList。大多数情况下ArrayList是更好的选择，因为CPU缓存友好，实际性能往往优于LinkedList。

#### stack

基于vector实现，同样有性能问题，推荐使用ArrayDueue作为栈。

```java
Deque<Integer> stack = new ArrayDeque<>();
stack.push(1);
stack.pop();
```

#### CopyOnWriteArrayList

写的时候加锁并复制到新数组：

```java
public boolean add(E e) {
    synchronized(lock) {
        Object[] es = getArray();
        int len = es.length;
        es = Arrays.copyOf(es, len + 1); // 复制新数组
        es[len] = e;
        setArray(es); // 替换引用
        return true;
    }
}
```

**适用场景？**

读多写少（读操作不需要锁，直接访问数组）

写操作性能较差（需要复制整个数组）

#### toCharArray()

#### 特性

**快速失败**

```java
List<String> list = new ArrayList<>();
list.add("a");
Iterator<String> it = list.iterator();
list.add("b"); // 结构修改
it.next();     // 抛出ConcurrentModificationException
```

`Iterator` 在被创建时，会记录下集合的当前**修改次数（modCount）**。当你通过 `list.add("b")` 修改了 `list` 的结构后，这个修改次数会增加。当迭代器调用 `it.next()` 方法时，它会**检查**当前集合的修改次数是否与它在创建时记录下来的修改次数一致。一旦不一致，就会抛出ConcurrentModificationException，快速失败

**子列表视图**

```java
List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
List<Integer> subList = list.subList(1, 4); // [2, 3, 4]
subList.set(0, 99); // 原list变为[1, 99, 3, 4, 5]
```

`subList`并非一个新的对象，而是对原对象的一个局部引用

#### **多维数组**

 Java**支持多维数组**，但实际上是**数组的数组**。例如，`int[][]`是一个一维数组，其中的每个元素又是一个 `int[]`数组。这意味着多维数组可以是不规则的（每行的长度可以不同）。

如何创建一个不规则的多维数组：

```java
// 1. 声明并创建外部数组（指定有3行）
int[][] jaggedArray = new int[3][];

// 2. 分别创建每一行的内部数组（指定不同的列数）
jaggedArray[0] = new int[3]; // 第一行有3列
jaggedArray[1] = new int[2]; // 第二行有2列
jaggedArray[2] = new int[4]; // 第三行有4列
```

Java中的多维数组的地址分配更接近于下图：

<img src="https://raw.githubusercontent.com/yicizhang00/image_host/main/blog-img/202508260240314.png" alt="image-20250826024059174" style="zoom:33%;" />

> 在C中int\[\]\[\] 的大小是固定的，其在堆上连续分配，而JVM中int[0]的地址和int[1]的地址并非连续。

#### 常用方法

`Arrays.sort(arr)`: 排序（双轴快排）。

`Arrays.sort(arr, Comparator.reverseOrder())`：由大到小排序。

`Arrays.binarySearch(arr, key)`: 二分查找（**数组必须已排序**）。

`Arrays.fill(arr, value)`: 填充值。

`Arrays.equals(arr1, arr2)`: 比较两个数组的**内容**是否相等（深层次比较元素）。

`Arrays.toString(arr)`: 将数组转换为字符串表示形式，便于打印调试。

`Arrays.asList(T... a)`: 返回一个固定大小的列表（`List`），由原数组生成。**不能进行增删操作**，否则会抛 `UnsupportedOperationException`。

#### 高级与底层

##### 协变数组

它允许你用一个**子类型数组的引用**赋值给一个**父类型数组的变量**。

```java
Object[] objectArray = new String[10]; // 编译和运行都可以
objectArray[0] = "Hello"; // OK
objectArray[1] = 1;       // 编译通过，但运行时会抛出 ArrayStoreException
```

这种**运行时错误**是协变数组最大的缺陷。为了解决这个问题，Java语言的设计者在泛型（Generics）中引入了**不可变（Invariant）**的概念。

```java
// 泛型是不可变的
// List<Animal> animals = new ArrayList<Dog>(); // 编译错误！
```

其提供了**编译时**的类型安全保障，避免了运行时的类型转换错误。

## 链表

## 栈

## 队列

## 哈希表


☆哈希表如何解决哈希冲突：

1.链地址法：每个哈希桶存储一个链表（或其他结构），所有哈希到同一位置的元素都插入该链表。插入和查找时只需遍历链表即可。
2.开放地址法：当发生冲突时，按照一定探查方式（如线性探查、二次探查、双重哈希）寻找下一个空位，将元素插入空位。查找时同样按探查顺序查找。
3.再哈希法：发生冲突时，使用另一个哈希函数重新计算位置，直到找到空位。
4.扩容与重哈希：当哈希表负载因子过高时，扩容并重新分配所有元素，减少冲突概率。

**Java实现**
Java的HashMap在JEP 180之前采用链表解决冲突，而之后当链表长度超过阈值（通常为8）通过将每个桶存储一个链表转为红黑树。

具体来说，当一个哈希桶中的链表长度达到 8（即 TREEIFY_THRESHOLD）时，并且此时哈希表的总容量（capacity）也达到了 64（即 MIN_TREEIFY_CAPACITY），这个链表就会被转换为一棵红黑树。

**改进实现**
在改进之前，字符串冲突的备选是采用hash32，为每一个String新增一个字段，此改进实现了任何Comparable接口的键类型的性能提升，字符串的hash32字段被移除。
    
该改进已经在`java.util.concurrent.ConcurrentHashMap`,`HashMap`以及`LinkedHashMap`中实现。但是在`HashTable`,`WeakHashMap`和`IdentityHashMap`中并不实现。

**为什么要满足容量大于 64？**
因为如果哈希表容量太小，频繁发生哈希冲突的原因很可能不是哈希函数不好，而是哈希表本身太小。在这种情况下，更好的解决办法是进行扩容（resize），而不是转换为红黑树。

当哈希表容量小于 64 时，即使链表长度达到了 8，`HashMap` 也会优先选择扩容，通过重新计算哈希值来分散元素。这样可以避免不必要的树化，减少性能开销。

**为什么链表长度为8**
泊松分布描述稀有事件在固定时间或者空间内发生的概率，适用于：
- 事件独立
- 事件发生的平均速率已知并固定
- 事件发生的概率极低
在哈希表中，设容量为m，插入n个键，每个键落入m个桶内，单个键冲突概率为\( \frac{1}{m}\)

**WeakHashMap的弱引用与垃圾回收**
`WeakHashMap` 的核心特点是键（key）是弱引用。这意味着当一个键对象没有其他强引用指向它时，它随时可能被垃圾回收器（Garbage Collector, GC）回收。

WeakHashMap内部有一个ReferenceQueue队列维护被GC的键，当一个弱引用键被GC后，其会被添加到这个队列中，在每次put,get,remove时，会检查并清理这个队列，所有被GC的键从WeakHashMap中删除。因此带来了：
1） 红黑树的维护开销：红黑树在删除节点时会带来节点的旋转和重新着色。
2） GC行为无法预测：导致红黑树的结构也不可预测，会带来巨大的性能开销。

**IdentityHashMap基于身份哈希的无冲突设计**
IdentityHsahMap采用"=="而非"equals()"


<div style="border: 2px solid #150404ff; border-radius: 10px; padding: 10px; background: #f8f9fa;">

</div>

### HashMap

### HashTable

### WeakHashMap

### IdentityHashMap

### LinkedHashMap
**LRU缓存设计**

**Redis的LRU设计**
redis的LRU并非严格LRU设计，而是近似的LRU设计，因此严格的LRU在每次访问一个键时需要将其移动到链表头部，同时对于内存和开销都有巨大压力：


### EnumMap


### ConcurrentSkipListMap

# 进阶数据结构

## 堆

## 优先队列

## TreeMap

## Deque 双端队列

## TreeSet

## 图

## 并查集DSU

# 高级数据结构

## 跳表

## 线段树

## 前缀树

## AVL

## 红黑树

## 布隆过滤器
布隆过滤器是一种空间效率极高的概率型数据结构，用于判断一个元素是否在集合中。它通过多个哈希函数将元素映射到位数组的不同位置，插入时将对应位设为1，查询时只要有一个位为0则一定不在集合中，否则可能在集合中（存在误判）。

**优点：**
- 占用空间小，插入和查询速度快。
- 适合大数据场景下的快速去重和存在性判断。

**缺点：**
- 存在一定的误判率（假阳性），无法删除元素（标准实现）。
- 不支持元素的遍历。

**应用场景：**
- 数据库缓存过滤（如Redis缓存穿透防护）
- 网络黑名单检测
- 大规模去重（如爬虫URL判重）

**时间复杂度：**
- 插入操作(Add): O(K)
- 查询操作(Check): O(K)
k是哈希函数的数量
<div style="border: 2px solid #150404ff; border-radius: 10px; padding: 10px; background: #f8f9fa;">
☆★布隆过滤器的原理是用 k 个哈希函数将元素映射到位数组的 k 个位置。插入时，需要对元素进行 k 次哈希并设置 k 个位；查询时，需要对元素进行 k 次哈希并检查 k 个位。因此，时间复杂度与哈希函数数量 k 成线性关系，通常 k 是常数，所以实际操作接近 O(1)。
</div>

### Java实现
```java
public class SimpleBloomFilter {
    private int size;
    private boolean[] bits;
    private int[] seeds = {7, 11, 13, 31, 37, 61};

    public SimpleBloomFilter(int capacity) {
        this.size = capacity;
        this.bits = new boolean[size];
    }

    private int hash(String value, int seed) {
        int result = 0;
        for (int i = 0; i < value.length(); i++) {
            result = seed * result + value.charAt(i);
        }
        return (size - 1) & result;
    }

    public void add(String value) {
        for (int seed : seeds) {
            bits[hash(value, seed)] = true;
        }
    }

    public boolean contains(String value) {
        for (int seed : seeds) {
            if (!bits[hash(value, seed)]) {
                return false;
            }
        }
        return true;
    }
}
```

### 第三方库
```java
BloomFilter<String> bloomFilter = BloomFilter.create(
    Funnels.stringFunnel(Charset.defaultCharset()), 
    1000, // 预期元素数量
    0.01  // 误报率
);
bloomFilter.put("item1");
System.out.println(bloomFilter.mightContain("item1")); // true
```

## 有序哈希表LinkedHashMap

## WeakHashMap

## EnumSet

## EnumMap

## 地址哈希表IdentityHashMap

## ConcurrentHashMap

## 时间轮Time Wheel

## 位集 BitSet

