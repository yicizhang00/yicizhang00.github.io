---
title: java基础
date: 2025-08-12 01:55:16
tags:
categories: 
  - 数据结构 
  - java
---

# Java基础知识

## 静态方法与非静态成员

静态方法是属于类的，而非静态成员属于实例对象，前者在类加载的时候就会分配内存，而后者只有在对象实例化之后才会加载，因此静态方法不能访问非静态成员。

## 可变长参数

在jdk5后引入，参数后会加上`...`以表示可变长参数，当一个可变长参数的函数重载另一个函数会后，调用会优先选择范围可定的函数。

```java
public void methodName(Type... parameterName) {
    // 方法体
}
```

1.可变长参数实际上是一个语法糖，编译器在底层会将其转换为数组。

2.例如 `String... args` 会被编译为 `String[] args`。

3.调用方法时，可以传递任意数量（包括零个）的参数。

4.可变长参数只能放在普通参数的最后。

## 面向对象OOP

三大特点：封装、继承、多态

封装：内部成员隐藏，仅暴露外部方法以供调用

继承：在已定义的类的基础上定义额外的类，提高代码的重用和可扩展性。

1.子类无法继承父类的私有属性和方法

2.子类可以重写父类的方法

多态：一个对象可以存在多种状态。

**编译时多态**：方法重载（Overload）。
**运行时多态**：方法重写（Override）—— 这是多态的核心和精髓。



## 接口和抽象类

- **实例化**：接口和抽象类都不能直接实例化，只能被实现（接口）或继承（抽象类）后才能创建具体的对象。
- **抽象方法**：接口和抽象类都可以包含抽象方法。抽象方法没有方法体，必须在子类或实现类中实现。

| 维度           | 接口 (Interface)             | 抽象类 (Abstract Class)    |
| :------------- | :--------------------------- | :------------------------- |
| **继承**       | 实现多个接口                 | 只能继承一个抽象类         |
| **方法**       | 抽象方法、默认方法、静态方法 | 抽象方法和具体方法         |
| **变量**       | 只能是常量                   | 可以是普通变量             |
| **构造器**     | 无                           | 有                         |
| **设计目标**   | 定义契约和能力               | 代码复用和部分实现         |
| **访问修饰符** | 默认public                   | 可以是protected、private等 |

## Final关键字

### Final修饰的类

**作用**：表示这个类**不能被继承**，即不能有子类。

**特点**：1.这个类所有方法都不能重写，因为没有子类；2.这个类中的变量不一定是final的

### Final修饰的方法

**作用**：表示这个方法**不能被子类重写**(Override)。

**特点**：1.可以用于修饰静态方法和实例方法；2.private是隐式final的，因为无法被继承，也就没有重写；3.final方法可以被Overload

### Final修饰的变量

#### 1. final修饰基本类型变量

**作用**：表示这个变量的值**一旦初始化就不能被修改**（即成为常量）。

#### 2. final修饰引用类型变量

**作用**：表示这个引用**不能再指向其他对象**，但对象本身的内容可以被修改。

#### 3. final修饰成员变量

**特点**：1.必须在声明时或构造方法中初始化；2.一旦初始化后就不能再修改。

### Final的内存特点

1.Final修饰的变量在初始化完成后对其他线程可见。

2.阻止内存重排。

3.用于实现线程安全不可变关键。

## 浅拷贝、深拷贝与引用拷贝

![shallow&deep-copy](https://oss.javaguide.cn/github/javaguide/java/basis/shallow&deep-copy.png)

### 浅拷贝

创建一个新对象，然后将原对象的**非静态字段**的值逐个复制到新对象。

- 如果字段是**基本类型**，则复制其值。

- 如果字段是**引用类型**，则复制其**内存地址**（即引用），而不是引用的对象本身。

### 深拷贝	

创建一个新对象，同时递归地创建原对象中所有引用类型字段所指向的对象的副本。结果是两个完全独立的对象，没有任何共享的内部状态。

### 引用拷贝

创建一个新的变量名，实际上指向的还是原来的对象引用地址。

## String，StringBuilder和StringBuffer

### String不可变

String是一个final修饰的对象，final关键字强调了该引用不可变。

在JDK的主要实现中，String底层是一个char[]。

```java
public final class String implements java.io.Serializable, Comparable<String>, CharSequence {
/** String本质是个char数组. 而且用final关键字修饰.*/
private final char value[];
......
}
```

虽然final不可变，但是其引用不可变，我们依然可以去修改堆中的内存，但其使用了private修饰，并且没有暴露内部字段。

同时，String有字符串常量池属性，对于相同的字符串，它们都指向堆的同一个内存地址，如果String是可变的话，这就没有意义了。

```java
String a = "111";
String b = "111";
```

