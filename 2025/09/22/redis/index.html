<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>redis | Hexo</title><meta name="keywords" content="java"><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="redis"><meta name="application-name" content="redis"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="redis"><meta property="og:url" content="http://example.com/2025/09/22/redis/index.html"><meta property="og:site_name" content="Hexo"><meta property="og:description" content="Redis基础Redis （REmote DIctionary Server）是一个基于 C 语言开发的开源 NoSQL 数据库（BSD 许可）。与传统数据库不同的是，Redis 的数据是保存在内存中的（内存数据库，支持持久化），因此读写速度非常快，被广泛应用于分布式缓存方向。并且，Redis 存储"><meta property="og:locale" content="en"><meta property="og:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta property="article:author" content="John Doe"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta name="description" content="Redis基础Redis （REmote DIctionary Server）是一个基于 C 语言开发的开源 NoSQL 数据库（BSD 许可）。与传统数据库不同的是，Redis 的数据是保存在内存中的（内存数据库，支持持久化），因此读写速度非常快，被广泛应用于分布式缓存方向。并且，Redis 存储"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/2025/09/22/redis/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2024/07/27/125766904/ba62475f396df9de3316a08ed9e65d86_5680958632268053399..png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"Author: John Doe","link":"Link: ","source":"Source: Hexo","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.","copySuccess":"Copy success, copy and reprint please mark the address of this article"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Hexo',
  title: 'redis',
  postAI: '',
  pageFillDescription: 'Redis基础, Redis的数据类型, redis效能, 其他的分布式缓存技术, Memcached, Tendis, Dragonfly, keyDB, Faster, Redis常见问题, 问什么要用分布式缓存, 常见的缓存更新策略有哪些, Cache Aside(旁路缓存), 场景复现（先删除后写）, 场景复现（先写后删除）, 场景复现（先写后删除依旧有问题）, 优化手段, Read Through Pattern 读穿透, Write Through Pattern（写穿透）, Read Back （写回）, Redis底层结构以及实现, 底层结构, String(SDS), List双端链表, ZipList, 连锁更新, 特点, QuickList, quickListNode结构, quickList, quicklist总体结构, 分裂机制, 合并机制, listpack, ListPackEntry, Redis的功能, 分布式锁, 限流, 消息队列, 延时队列, 分布式Session, 其他业务场景, Redis的性能, 单线程, 为什么使用单线程？, 网络IO多线程, 异步删除多线程（懒删除lazy free）, AOFx2FRDB, 集群和复制线程, 哨兵模式, 集群模式基础是一个基于语言开发的开源数据库许可与传统数据库不同的是的数据是保存在内存中的内存数据库支持持久化因此读写速度非常快被广泛应用于分布式缓存方向并且存储的是键值对数据为了满足不同的业务场景内置了多种数据类型实现比如并且还支持事务持久化脚本发布订阅模型多种开箱即用的集群方案的数据类型字符串二进制安全可以存储任意数据字符串数字甚至图片或序列化数据最大容量单个最多常见操作使用场景缓存对象计数器分布式锁列表一个有序的双向链表可以从两端插入和弹出元素保持插入顺序支持重复元素常见操作使用场景消息队列任务队列最新列表展示如微博时间线哈希表存储键值对适合存储对象常见操作使用场景用户信息表集合无序集合不允许重复底层实现哈希表查找和去重效率高常见操作使用场景去重好友关系交集求共同好友差集求可能认识的人有序集合每个成员关联一个分数按分数排序分数可以相同但成员不能重复常见操作使用场景排行榜按分数时间排序带权重的数据位图基于的位操作节省存储空间常见操作使用场景签到打卡用户在线状态统计布隆过滤器底层用于基数统计去重计数占用空间固定常见操作使用场景网站统计活跃用户数地理空间数据基于实现可以存储经纬度并进行范围查询常见操作使用场景附近的人地图服务流引入消息队列结构支持持久化和消费组常见操作使用场景消息队列日志系统实时数据处理类型是否有序是否允许重复典型场景否否缓存计数器锁有序允许队列时间线无序唯一存储对象信息无序否去重集合运算有序否排行榜位序列位唯一签到状态标记概率去重统计按距离否地理位置服务有序允许消息队列效能纯内存操作所有读写发生在内存中而非持久化到磁盘上高效的模型采用了单线程事件以及多路复用优化的内部数据结构如采用了自定义的通信协议其他的分布式缓存技术常见问题问什么要用分布式缓存特性本地缓存数据一致性多服务器部署时存在数据不一致问题数据一致内存限制受限于单台服务器内存独立部署内存空间更大数据丢失风险服务器宕机数据丢失可持久化数据不易丢失管理维护分散管理不便集中管理提供丰富的管理工具功能丰富性功能有限通常只提供简单的键值对存储功能丰富支持多种数据结构和功能常见的缓存更新策略有哪些旁路缓存写流程更新删除缓存读流程查缓存命中直接返回未命中转查数据库更新缓存为什么写流程不能先删除后更新场景复现先删除后写线程删除缓存线程读取数据发现缓存没了去查数据库读到的是旧值线程更新数据库线程把旧值写回缓存结果缓存里是旧值数据库里是新值缓存和数据库不一致场景复现先写后删除线程更新数据库线程读取数据发现缓存存在直接返回旧值线程删除缓存线程读取数据发现缓存不存在去数据库里面查数据库然后更新缓存结果到线程时缓存为空数据库里是新值缓存和数据库短暂不一致短暂不一致在后续线程时会更新缓存保证最终一致性场景复现先写后删除依旧有问题线程读取数据但数据不在缓存中去数据库中读取到旧数据线程写数据库线程删除缓存线程更新缓存为旧数据结果此时仍然会出现缓存和数据不一致的情况优化手段延迟双删为了解决短暂的不一致性更新数据库后先写数据库删缓存一段时间再删一次缓存能够解决并发读写导致的脏数据确保第二次删除能够覆盖所有旧数据的缓存优点适合缓存一致性要求高但无法满足完全实时一致性缺点增加系统复杂度无法满足会完全实时一致性的场景缺点解决首次请求数据一定不在的问题将热点数据提前放入中缺点数据库和缓存数据强一致场景更新的时候同样更新不过我们需要加一个锁分布式锁来保证更新的时候不存在线程安全问题可以短暂地允许数据库和缓存数据不一致的场景更新的时候同样更新但是给缓存加一个比较短的过期时间这样的话就可以保证即使数据不一致的话影响也比较小读穿透读查缓存命中直接返回未命中转查数据库更新缓存返回数据库写穿透写先查不存在直接更新中存在先更新同步更新缓存和在同一事务中写实际只是在之上进行了封装在下发生读请求的时候如果中不存在对应的数据是由客户端自己负责把数据写入而则是服务自己来写入缓存的这对客户端是透明的实际上并不提供读写穿透的策略自己无法去写写回写先查不存在直接更新中存在先更新异步更新优点减少数据库压力缺点数据丢失风险缓存宕机数据没落库一致性较弱适合对一致性要求不高的场景底层结构以及实现是单线程事件驱动的内存数据库主要框架客户端网络事件模块命令解析模块数据结构模块持久化模块模块功能网络基于的模型非阻塞命令解析器解析客户端请求协议数据结构模块实现各种类型的键值对持久化模块内存管理自定义内存分配多线程模块只在读写网络时用多线程核心逻辑仍单线程底层结构的所有都保存在全局哈希表里面每个都是一个当出现哈希冲突时形成链表是一个结构有不同的编码方式数据类型编码方式指向底层数据结构类型底层结构说明简单动态字符串类似但有预分配空间支持二进制安全旧新双端链表压缩块兼顾随机访问和内存效率小大小数据紧凑存储大数据用哈希表小大小集合用整数数组大集合用哈希表有序集合小大跳表哈希表支持按分数范围查询位操作在上实现稀疏稠密数组布隆过滤器的字符串不是而是实际长度分配空间内容双端链表在使用压缩表划分为多个字段压缩列表的字节长度占个字节因此压缩列表最长字节压缩列表尾元素相对于压缩列表起始地址的偏移量占个字节压缩列表的元素数目占两个字节那么当压缩列表的元素数目超过怎么处理呢此时通过字段无法获得压缩列表的元素数目必须遍历整个压缩列表才能获取到元素数目压缩列表存储的若干个元素可以为字节数组或者整数的编码结构后面详述压缩列表的结尾占一个字节恒为例如代表这个的总空间大小为到尾部的偏移量为即最后一个的地址为数组长度为最后一个字节默认为每个压缩列表节点的具体构成为这个属性记录了压缩列表前一个节点的长度该属性根据前一个节点的大小不同可以是个字节或者个字节如果前一个节点的长度小于个字节那么的大小为个字节即前一个节点的长度可以使用个字节表示如果前一个节点的长度大于等于个字节那么的大小为个字节第一个字节会被设置为十进制的之后的四个字节则用于保存前一个节点的长度该字段设计主要是为了查找前一个节点使用当前节点的地址减去前一个节点的长度即可获得前一个节点的开始地址表示的编码方式以及长度一字节两字节或者五字节长值的最高位为或者的是字节数组编码这种编码表示节点的属性保存着字节数组数组的长度由编码除去最高两位之后的其他位记录一字节长值的最高位以开头的是整数编码这种编码表示节点的属性保存着整数值整数值的类型和长度由编码除去最高两位之后的其他位记录内容根据部分决定连锁更新由于的长度是动态变化的因此添加节点或者删除节点时可能会导致后一个节点的长度变化即使存在这种情况但是并不影响我们使用压缩列表压缩列表里要恰好有多个连续的长度介于字节至字节之间的节点连锁更新才有可能被引发这种情况就和连中彩票一样很少见懂了即使出现连锁更新但只要被更新的节点数量不多就不会对性能造成任何影响比如说对三五个节点进行连锁更新是绝对不会影响性能的特点结构紧凑一整块连续内存没有多余的内存碎片更新会导致内存与内存复制平均时间复杂度为逆向遍历从表尾开始向表头进行遍历注意了但是插入还是在表头连锁更新对前一条数据的更新可能导致后一条数据的与所需长度变化产生连锁反应更新操作最坏时间为在较早版本的中有两种底层实现当列表对象中元素的长度比较小或者数量比较少的时候采用压缩列表来存储当列表对象中元素的长度比较大或者数量比较多的时候则会转而使用双向列表来存储两者各有优缺点的优点是内存紧凑访问效率高缺点是更新效率低并且数据量较大时可能导致大量的内存复制的优点是节点修改的效率高但是需要额外的内存开销并且节点较多时会产生大量的内存碎片为了结合两者的优点在之后的底层实现变为快速列表快速列表是与的结合包含多个内存不连续的节点但每个节点本身就是一个在使用链表和结合的结构前一个后一个指向的的字节大小中的元素个数编码格式原生字节数组或压缩存储存储方式数据是否被压缩数据能否被压缩预留的位指向该节点的前后节点指向该节点对应的结构代表整个结构的大小代表采用的编码方式代表是原生的代表使用进行压缩为节点指向的容器类型代表代表使用存储数据代表这个节点之前是否是压缩节点若是则在使用压缩节点前先进行解压缩使用后需要重新压缩此外为代表是压缩节点测试时使用为预留的链表头的链表尾所有中的总元素个数的个数单独解释具体含义是两端各有个节点不压缩用来指明每个中长度当为正数时表明每个最多含有的数据项数当为负数时如下即节点最大为即节点最大为取负数时必须大于等于可以通过修改参数配置节点所占内存大小实际上每个节点所占的内存会在该值上下浮动考虑节点个数较多时我们经常访问的是两端的数据为了进一步节省空间允许对中间的节点进行压缩通过修改参数进行配置即设置参数该项的具体含义是两端各有个节点不压缩总体结构只有当前的已满超过设定阈值时才会新建一个及其否则就直接往当前节点的里追加分裂机制如果在中间插入元素导致超出容量上限会将该一分为二原插入新元素中间后过大分裂为于是会新建一个用于第二个这样避免某个太大影响性能合并机制当某个因为删除过小时其会和相邻的合并以减少内存使用由于使用可能会导致每个的长度字段需要更新可能引发整个内存重分配在极端情况下是的复杂度所有节点都需要更新因此在之后使用了彻底代替了其结构如下相对比去除了节点意味着没法通过找到列表结尾其主要改进在中的功能分布式锁限流消息队列延时队列分布式其他业务场景的性能单线程使用了多路复用来处理请求的核心命令执行逻辑仍是单线程的所有等命令都在主线程顺序执行不存在锁竞争也不需要上下文切换因此非常快内存操作事件循环这正是能在百万场景下仍然稳定的原因为什么使用单线程因为的数据结构操作需要保持原子性多线程同时操作相同会产生锁竞争多线程下难以保证命令间顺序一致性单线程多线程是一个性能与一致性的最佳平衡点网络多线程前完全单线程循环的事件单线程事件循环等待事件处理读事件执行命令内存操作处理写事件也就是说主线程通过获取活跃连接然后顺序执行所有的读命令写逻辑整个过程全在一个核上完成高效是因为不用加锁不用上下文切换内存操作极快而在之后引入了多线程仍然负责事件监听但网络读写由多个线程并发完成主线程获取活跃将分发给线程池线程线程线程读取数据解析请求包写回响应结果仍然在主线程中使用主线程收集活跃连接后将这些连接分配给多个线程各线程负责并行命令解析与执行仍然在主线程完成异步删除多线程懒删除场景命令如删除大量键时如果在主线程中执行会阻塞整个实例解决使用后台线程池异步释放内存避免主线程阻塞场景线程说明重写子进程线程异步重写日志文件快照子进程异步写入文件后台线程定期将到磁盘集群和复制线程节点之间的消息同步等网络通信也通过独立线程处理复制时主节点发送文件是在后台子进程中完成在中引入了的复制机制哨兵模式集群模式',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-12-31 11:26:16',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">Hexo</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> Newest Comments</span></div><div class="aside-list"><span>loading...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/java/" style="font-size: 1.05rem;">java<sup>2</sup></a><a href="/tags/leetcode/" style="font-size: 1.05rem;">leetcode<sup>5</sup></a><a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 1.05rem;">分布式<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 1.05rem;">数据库<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 1.05rem;">算法<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/" style="font-size: 1.05rem;">网络安全<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>Archives</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/12/"><span class="card-archive-list-date">December 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">8</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/09/"><span class="card-archive-list-date">September 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/08/"><span class="card-archive-list-date">August 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">27</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="article-meta tags"><a class="article-meta__tags" href="/tags/java/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>java</span></a></span></div></div><h1 class="post-title" itemprop="name headline">redis</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-09-21T17:44:36.000Z" title="Created 2025-09-22 01:44:36">2025-09-22</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-12-31T03:26:16.222Z" title="Updated 2025-12-31 11:26:16">2025-12-31</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为长沙"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>长沙</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2025/09/22/redis/"><header><a href="/tags/java/" tabindex="-1" itemprop="url">java</a><h1 id="CrawlerTitle" itemprop="name headline">redis</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">John Doe</span><time itemprop="dateCreated datePublished" datetime="2025-09-21T17:44:36.000Z" title="Created 2025-09-22 01:44:36">2025-09-22</time><time itemprop="dateCreated datePublished" datetime="2025-12-31T03:26:16.222Z" title="Updated 2025-12-31 11:26:16">2025-12-31</time></header><h1 id="Redis基础"><a href="#Redis基础" class="headerlink" title="Redis基础"></a>Redis基础</h1><p><a target="_blank" rel="noopener" href="https://redis.io/">Redis</a> （<strong>RE</strong>mote <strong>DI</strong>ctionary <strong>S</strong>erver）是一个基于 C 语言开发的开源 NoSQL 数据库（BSD 许可）。与传统数据库不同的是，Redis 的数据是保存在内存中的（内存数据库，支持持久化），因此读写速度非常快，被广泛应用于分布式缓存方向。并且，Redis 存储的是 KV 键值对数据。</p>
<p>为了满足不同的业务场景，Redis 内置了多种数据类型实现（比如 String、Hash、Sorted Set、Bitmap、HyperLogLog、GEO）。并且，Redis 还支持事务、持久化、Lua 脚本、发布订阅模型、多种开箱即用的集群方案（Redis Sentinel、Redis Cluster）。</p>
<h2 id="Redis的数据类型"><a href="#Redis的数据类型" class="headerlink" title="Redis的数据类型"></a>Redis的数据类型</h2><ol>
<li><p><strong>String（字符串）</strong></p>
<ul>
<li>二进制安全，可以存储任意数据：字符串、数字、甚至图片或序列化数据。</li>
<li>最大容量：单个 value 最多 512MB。</li>
<li>常见操作：<code>SET</code>、<code>GET</code>、<code>INCR</code>、<code>DECR</code>、<code>APPEND</code>。</li>
<li>使用场景：缓存对象、计数器、分布式锁。</li>
</ul>
</li>
<li><p><strong>List（列表）</strong></p>
<ul>
<li>一个有序的双向链表，可以从两端插入和弹出元素。</li>
<li>保持插入顺序，支持重复元素。</li>
<li>常见操作：<code>LPUSH</code>、<code>RPUSH</code>、<code>LPOP</code>、<code>RPOP</code>、<code>LRANGE</code>。</li>
<li>使用场景：消息队列、任务队列、最新列表展示（如微博时间线）。</li>
</ul>
</li>
<li><p><strong>Hash（哈希表）</strong></p>
<ul>
<li>存储键值对（field-value），适合存储对象。</li>
<li>常见操作：<code>HSET</code>、<code>HGET</code>、<code>HMGET</code>、<code>HDEL</code>。</li>
<li>使用场景：用户信息表（id → {name, age, email}）。</li>
</ul>
</li>
<li><p><strong>Set（集合）</strong></p>
<ul>
<li>无序集合，不允许重复。</li>
<li>底层实现：哈希表，查找和去重效率高。</li>
<li>常见操作：<code>SADD</code>、<code>SMEMBERS</code>、<code>SINTER</code>、<code>SUNION</code>、<code>SDIFF</code>。</li>
<li>使用场景：去重、好友关系（交集求共同好友，差集求可能认识的人）。</li>
</ul>
</li>
<li><p><strong>Sorted Set（有序集合，Zset）</strong></p>
<ul>
<li>每个成员（member）关联一个分数（score），按分数排序。</li>
<li>分数可以相同，但成员不能重复。</li>
<li>常见操作：<code>ZADD</code>、<code>ZRANGE</code>、<code>ZREVRANGE</code>、<code>ZRANK</code>、<code>ZREM</code>。</li>
<li>使用场景：排行榜（按分数、时间排序）、带权重的数据。</li>
</ul>
</li>
<li><p><strong>Bitmap（位图）</strong></p>
</li>
</ol>
<ul>
<li>基于 String 的位操作，节省存储空间。</li>
<li>常见操作：<code>SETBIT</code>、<code>GETBIT</code>、<code>BITCOUNT</code>。</li>
<li>使用场景：签到打卡、用户在线状态统计、布隆过滤器底层。</li>
</ul>
<ol start="7">
<li><strong>HyperLogLog</strong></li>
</ol>
<ul>
<li>用于基数统计（去重计数），占用空间固定（12KB）。</li>
<li>常见操作：<code>PFADD</code>、<code>PFCOUNT</code>、<code>PFMERGE</code>。</li>
<li>使用场景：网站 UV 统计、活跃用户数。</li>
</ul>
<ol start="8">
<li><strong>Geospatial（地理空间数据）</strong></li>
</ol>
<ul>
<li>基于 Zset 实现，可以存储经纬度并进行范围查询。</li>
<li>常见操作：<code>GEOADD</code>、<code>GEODIST</code>、<code>GEORADIUS</code>。</li>
<li>使用场景：附近的人、地图服务。</li>
</ul>
<ol start="9">
<li><strong>Stream（流，Redis 5.0 引入）</strong></li>
</ol>
<ul>
<li>消息队列结构，支持持久化和消费组。</li>
<li>常见操作：<code>XADD</code>、<code>XREAD</code>、<code>XGROUP</code>、<code>XREADGROUP</code>。</li>
<li>使用场景：消息队列、日志系统、实时数据处理。</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>是否有序</th>
<th>是否允许重复</th>
<th>典型场景</th>
</tr>
</thead>
<tbody><tr>
<td>String</td>
<td>否</td>
<td>否</td>
<td>缓存、计数器、锁</td>
</tr>
<tr>
<td>List</td>
<td>有序</td>
<td>允许</td>
<td>队列、时间线</td>
</tr>
<tr>
<td>Hash</td>
<td>无序</td>
<td>field 唯一</td>
<td>存储对象信息</td>
</tr>
<tr>
<td>Set</td>
<td>无序</td>
<td>否</td>
<td>去重、集合运算</td>
</tr>
<tr>
<td>Sorted Set</td>
<td>有序</td>
<td>否</td>
<td>排行榜</td>
</tr>
<tr>
<td>Bitmap</td>
<td>位序列</td>
<td>位唯一</td>
<td>签到、状态标记</td>
</tr>
<tr>
<td>HyperLogLog</td>
<td>N&#x2F;A</td>
<td>概率去重</td>
<td>UV 统计</td>
</tr>
<tr>
<td>Geo</td>
<td>按距离</td>
<td>否</td>
<td>地理位置服务</td>
</tr>
<tr>
<td>Stream</td>
<td>有序</td>
<td>允许</td>
<td>消息队列</td>
</tr>
</tbody></table>
<h2 id="redis效能"><a href="#redis效能" class="headerlink" title="redis效能"></a>redis效能</h2><ol>
<li>纯内存操作：所有读写发生在内存中，而非持久化到磁盘上。</li>
<li>高效的IO模型：采用了单线程事件以及IO多路复用。</li>
<li>优化的内部数据结构：如ziplist，quicklist，skiplist，hashtable</li>
<li>采用了自定义的通信协议：RESP</li>
</ol>
<h2 id="其他的分布式缓存技术"><a href="#其他的分布式缓存技术" class="headerlink" title="其他的分布式缓存技术"></a>其他的分布式缓存技术</h2><h3 id="Memcached"><a href="#Memcached" class="headerlink" title="Memcached"></a>Memcached</h3><h2 id="Tendis"><a href="#Tendis" class="headerlink" title="Tendis"></a>Tendis</h2><h2 id="Dragonfly"><a href="#Dragonfly" class="headerlink" title="Dragonfly"></a>Dragonfly</h2><h2 id="keyDB"><a href="#keyDB" class="headerlink" title="keyDB"></a>keyDB</h2><h2 id="Faster"><a href="#Faster" class="headerlink" title="Faster"></a>Faster</h2><h1 id="Redis常见问题"><a href="#Redis常见问题" class="headerlink" title="Redis常见问题"></a>Redis常见问题</h1><h2 id="问什么要用分布式缓存"><a href="#问什么要用分布式缓存" class="headerlink" title="问什么要用分布式缓存"></a>问什么要用分布式缓存</h2><table>
<thead>
<tr>
<th>特性</th>
<th>本地缓存</th>
<th>Redis</th>
</tr>
</thead>
<tbody><tr>
<td>数据一致性</td>
<td>多服务器部署时存在数据不一致问题</td>
<td>数据一致</td>
</tr>
<tr>
<td>内存限制</td>
<td>受限于单台服务器内存</td>
<td>独立部署，内存空间更大</td>
</tr>
<tr>
<td>数据丢失风险</td>
<td>服务器宕机数据丢失</td>
<td>可持久化，数据不易丢失</td>
</tr>
<tr>
<td>管理维护</td>
<td>分散，管理不便</td>
<td>集中管理，提供丰富的管理工具</td>
</tr>
<tr>
<td>功能丰富性</td>
<td>功能有限，通常只提供简单的键值对存储</td>
<td>功能丰富，支持多种数据结构和功能</td>
</tr>
</tbody></table>
<h2 id="常见的缓存更新策略有哪些"><a href="#常见的缓存更新策略有哪些" class="headerlink" title="常见的缓存更新策略有哪些"></a>常见的缓存更新策略有哪些</h2><h3 id="Cache-Aside-旁路缓存"><a href="#Cache-Aside-旁路缓存" class="headerlink" title="Cache Aside(旁路缓存)"></a>Cache Aside(旁路缓存)</h3><p>写流程：</p>
<ol>
<li>更新DB</li>
<li>删除缓存</li>
</ol>
<p>读流程：</p>
<ol>
<li>查缓存，命中直接返回，未命中转2</li>
<li>查数据库</li>
<li>更新缓存</li>
</ol>
<p><strong>为什么写流程不能先删除后更新？</strong></p>
<h4 id="场景复现（先删除后写）"><a href="#场景复现（先删除后写）" class="headerlink" title="场景复现（先删除后写）"></a>场景复现（先删除后写）</h4><ol>
<li><strong>线程 A</strong>：删除缓存。</li>
<li><strong>线程 B</strong>：读取数据，发现缓存没了，去查数据库，读到的是旧值。</li>
<li><strong>线程 A</strong>：更新数据库。</li>
<li><strong>线程 B</strong>：把旧值写回缓存。</li>
</ol>
<p>👉 结果：<strong>缓存里是旧值</strong>，数据库里是新值，缓存和数据库不一致。</p>
<h4 id="场景复现（先写后删除）"><a href="#场景复现（先写后删除）" class="headerlink" title="场景复现（先写后删除）"></a>场景复现（先写后删除）</h4><ol>
<li><strong>线程 A</strong>：更新数据库。</li>
<li><strong>线程 B</strong>：读取数据，发现缓存存在，直接返回旧值。</li>
<li><strong>线程 A</strong>：删除缓存。</li>
<li><strong>线程 C</strong>：读取数据，发现缓存不存在，去数据库里面查数据库，然后更新缓存。</li>
</ol>
<p>👉 结果：到线程B时<strong>缓存为空</strong>，数据库里是新值，缓存和数据库<strong>短暂</strong>不一致，短暂不一致在后续线程C时会更新缓存保证<strong>最终一致性</strong>。</p>
<h4 id="场景复现（先写后删除依旧有问题）"><a href="#场景复现（先写后删除依旧有问题）" class="headerlink" title="场景复现（先写后删除依旧有问题）"></a>场景复现（先写后删除依旧有问题）</h4><ol>
<li><strong>线程 A</strong>：读取数据，但数据不在缓存中，去数据库中读取到旧数据。</li>
<li><strong>线程 B</strong>：写数据库。</li>
<li><strong>线程 B</strong>：删除缓存。</li>
<li><strong>线程 A</strong>：更新缓存为旧数据。</li>
</ol>
<p>👉 结果：此时仍然会出现缓存和DB数据不一致的情况。</p>
<h4 id="优化手段"><a href="#优化手段" class="headerlink" title="优化手段"></a>优化手段</h4><p>延迟双删：为了解决短暂的不一致性，更新数据库后：先写数据库→ 删缓存 → sleep 一段时间 → 再删一次缓存，能够解决并发读写导致的脏数据。确保第二次删除能够覆盖所有旧数据的缓存。</p>
<ul>
<li><p>优点：</p>
<ul>
<li>适合缓存一致性要求高，但无法满足完全实时一致性。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>增加系统复杂度。</li>
<li>无法满足会完全实时一致性的场景。</li>
</ul>
</li>
</ul>
<p><strong>缺点1</strong>：<strong>解决首次请求数据一定不在 cache 的问题</strong>，将热点数据提前放入redis中。</p>
<p><strong>缺点2</strong>：</p>
<p>数据库和缓存数据强一致场景：更新 db 的时候同样更新 cache，不过我们需要加一个锁&#x2F;分布式锁来保证更新 cache 的时候不存在线程安全问题。</p>
<p>可以短暂地允许数据库和缓存数据不一致的场景：更新 db 的时候同样更新 cache，但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小。</p>
<h3 id="Read-Through-Pattern-读穿透"><a href="#Read-Through-Pattern-读穿透" class="headerlink" title="Read Through Pattern 读穿透"></a>Read Through Pattern 读穿透</h3><p>读：</p>
<ol>
<li>查缓存，命中直接返回，未命中转2</li>
<li>查数据库，更新缓存，返回数据库</li>
</ol>
<h3 id="Write-Through-Pattern（写穿透）"><a href="#Write-Through-Pattern（写穿透）" class="headerlink" title="Write Through Pattern（写穿透）"></a>Write Through Pattern（写穿透）</h3><p>写：</p>
<ol>
<li>先查cache，cache不存在，直接更新db</li>
<li>cache中存在，先更新cache，<strong>同步</strong>更新DB（缓存和DB在同一事务中写）</li>
</ol>
<p>Read-Through Pattern 实际只是在 Cache-Aside Pattern 之上进行了封装。在 Cache-Aside Pattern 下，发生读请求的时候，如果 cache 中不存在对应的数据，是由客户端自己负责把数据写入 cache，而 Read Through Pattern 则是 cache 服务自己来写入缓存的，这对客户端是透明的。</p>
<blockquote>
<p>实际上redis并不提供读写穿透的策略，redis自己无法去写DB</p>
</blockquote>
<h3 id="Read-Back-（写回）"><a href="#Read-Back-（写回）" class="headerlink" title="Read Back （写回）"></a>Read Back （写回）</h3><p>写：</p>
<ol>
<li>先查cache，cache不存在，直接更新db</li>
<li>cache中存在，先更新cache，<strong>异步</strong>更新DB</li>
</ol>
<p>优点：</p>
<p>​	减少数据库压力</p>
<p>缺点：</p>
<p>​	数据丢失风险（缓存宕机，数据没落库）。</p>
<p>​	一致性较弱，适合对一致性要求不高的场景。</p>
<h1 id="Redis底层结构以及实现"><a href="#Redis底层结构以及实现" class="headerlink" title="Redis底层结构以及实现"></a>Redis底层结构以及实现</h1><p>Redis是<strong>单线程事件驱动</strong>的内存数据库，主要框架</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端 &lt;-&gt; 网络事件模块 &lt;-&gt; 命令解析模块 &lt;-&gt; 数据结构模块 &lt;-&gt; 持久化模块</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>模块</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><strong>网络 I&#x2F;O</strong></td>
<td>基于 epoll 的 Reactor 模型，非阻塞 I&#x2F;O</td>
</tr>
<tr>
<td><strong>命令解析器</strong></td>
<td>解析客户端请求（RESP 协议）</td>
</tr>
<tr>
<td><strong>数据结构模块</strong></td>
<td>实现各种类型的键值对</td>
</tr>
<tr>
<td><strong>持久化模块</strong></td>
<td>RDB &#x2F; AOF</td>
</tr>
<tr>
<td><strong>内存管理</strong></td>
<td>自定义内存分配（jemalloc）</td>
</tr>
<tr>
<td><strong>多线程模块（I&#x2F;O）</strong></td>
<td>只在读写网络时用多线程，核心逻辑仍单线程</td>
</tr>
</tbody></table>
<h2 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h2><p>Redis的所有<code>key-value</code>都保存在全局哈希表里面：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict *db</span><br></pre></td></tr></table></figure>

<p>每个<code>key-value</code>都是一个<code>dictEntry</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictEntry &#123;</span><br><span class="line">    void *key;</span><br><span class="line">    void *val;</span><br><span class="line">    struct dictEntry *next;</span><br><span class="line">&#125; dictEntry;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>当出现哈希冲突时，形成链表</p>
</blockquote>
<p><code>val</code>是一个<code>redisObject</code>结构，有不同的编码方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject &#123;</span><br><span class="line">    unsigned type:4;  // 数据类型 (string/list/set/zset/hash)</span><br><span class="line">    unsigned encoding:4; // 编码方式</span><br><span class="line">    void *ptr;        // 指向底层数据结构</span><br><span class="line">&#125; robj;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Redis 类型</th>
<th>底层结构（encoding）</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>String</strong></td>
<td>SDS（简单动态字符串）</td>
<td>类似 <code>char*</code>，但有 length、预分配空间，支持二进制安全</td>
</tr>
<tr>
<td><strong>List</strong></td>
<td><code>ziplist</code>（旧） &#x2F; <code>quicklist</code>（新）</td>
<td>双端链表 + 压缩块，兼顾随机访问和内存效率</td>
</tr>
<tr>
<td><strong>Hash</strong></td>
<td><code>ziplist</code>（小） &#x2F; <code>hashtable</code>（大）</td>
<td>小数据紧凑存储，大数据用哈希表</td>
</tr>
<tr>
<td><strong>Set</strong></td>
<td><code>intset</code>（小） &#x2F; <code>hashtable</code>（大）</td>
<td>小集合用整数数组，大集合用哈希表</td>
</tr>
<tr>
<td><strong>ZSet（有序集合）</strong></td>
<td><code>ziplist</code>（小） &#x2F; <code>skiplist</code> + <code>dict</code>（大）</td>
<td>跳表 + 哈希表，支持按分数范围查询</td>
</tr>
<tr>
<td>Stream</td>
<td>radix tree+list pack</td>
<td></td>
</tr>
<tr>
<td>Bitmap</td>
<td>String</td>
<td>位操作在String上实现</td>
</tr>
<tr>
<td>HyperLog Log</td>
<td>稀疏&#x2F;稠密数组 + hash</td>
<td></td>
</tr>
<tr>
<td>Geo</td>
<td>Zset+GeoHash</td>
<td></td>
</tr>
<tr>
<td>Bloom Filter（布隆过滤器）</td>
<td>bitmap+hash</td>
<td></td>
</tr>
</tbody></table>
<h3 id="String-SDS"><a href="#String-SDS" class="headerlink" title="String(SDS)"></a>String(SDS)</h3><p>Redis的字符串不是char*而是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct sdshdr &#123;</span><br><span class="line">    int len;       // 实际长度</span><br><span class="line">    int alloc;     // 分配空间</span><br><span class="line">    char buf[];    // 内容</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="List双端链表"><a href="#List双端链表" class="headerlink" title="List双端链表"></a>List双端链表</h3><h4 id="ZipList"><a href="#ZipList" class="headerlink" title="ZipList"></a>ZipList</h4><p>在Redis&lt;3.2：使用<code>ziplist</code>压缩表</p>
<p>ZipList划分为多个字段</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/yicizhang00/image_host/main/blog-img/20251014150145645.png" alt="img"></p>
<ul>
<li>1、<strong>zlbytes</strong>：压缩列表的字节长度，占4个字节，因此压缩列表最长(2^32)-1字节；</li>
<li>2、<strong>zltail</strong>：压缩列表尾元素相对于压缩列表起始地址的偏移量，占4个字节；</li>
<li>3、<strong>zllen</strong>：压缩列表的元素数目，占两个字节；那么当压缩列表的元素数目超过(2^16)-1怎么处理呢？此时通过zllen字段无法获得压缩列表的元素数目，必须遍历整个压缩列表才能获取到元素数目；</li>
<li>4、<strong>entryX</strong>：压缩列表存储的若干个元素，可以为字节数组或者整数；entry的编码结构后面详述；</li>
<li>5、<strong>zlend</strong>：压缩列表的结尾，占一个字节，恒为<strong>0xFF</strong>。</li>
</ul>
<p>例如</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/yicizhang00/image_host/main/blog-img/20251014150219950.jpeg" alt="img"></p>
<p>代表这个ziplist的总空间大小为0x50，到尾部的偏移量为0x3c(0d60)，即最后一个entry3的地址为p+60，数组长度为0x3，最后一个字节默认为0xFF。</p>
<p>每个压缩列表节点的具体构成为</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/yicizhang00/image_host/main/blog-img/20251014150446605.jpeg" alt="img"></p>
<ul>
<li>previous_entry_length：这个属性记录了压缩列表前一个节点的长度，<strong>该属性根据前一个节点的大小不同可以是1个字节或者5个字节。</strong><ul>
<li>如果前一个节点的长度小于254个字节，那么previous_entry_length的大小为1个字节，<strong>即前一个节点的长度可以使用1个字节表示。</strong></li>
<li>如果前一个节点的长度大于等于254个字节，那么previous_entry_length的大小为5个字节**，第一个字节会被设置为0xFE(十进制的254），之后的四个字节则用于保存前一个节点的长度。**</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/yicizhang00/image_host/main/blog-img/20251014150815811.jpeg">、<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/yicizhang00/image_host/main/blog-img/20251014150828183.jpeg" alt="img"></p>
<p>该字段设计主要是为了查找前一个节点，使用当前节点的地址减去前一个节点的长度即可获得前一个节点的开始地址。</p>
<ul>
<li>encoding：表示content的编码方式以及长度，<ul>
<li>一字节、两字节或者五字节长， 值的最高位为 00 、 01 或者 10 的是字节数组编码： 这种编码表示节点的 content 属性保存着字节数组， 数组的长度由编码除去最高两位之后的其他位记录</li>
<li>一字节长， 值的最高位以 11 开头的是整数编码： 这种编码表示节点的 content 属性保存着整数值， 整数值的类型和长度由编码除去最高两位之后的其他位记录；</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/yicizhang00/image_host/main/blog-img/20251014151053014.png" alt="image-20251014151052722"></p>
<ul>
<li>content：内容根据encoding部分决定。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/yicizhang00/image_host/main/blog-img/20251014151141865.png" alt="image-20251014151141782"></p>
<h4 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h4><p>由于previous_entry_lenth的长度是动态变化的，因此添加节点或者删除节点时可能会导致后一个节点的长度变化</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/yicizhang00/image_host/main/blog-img/20251014151910361.png" alt="image-20251014151910166"><strong>即使存在这种情况，但是并不影响我们使用压缩列表</strong></p>
<p>压缩列表里要恰好有多个<strong>连续的、长度介于 250 字节至 253 字节之间的节点， 连锁更新才有可能被引发， 这种情况就和连中彩票一样，很少见 (yes 懂了)</strong></p>
<p>即使出现连锁更新， 但只要被更新的节点数量不多， 就不会对性能造成任何影响： 比如说， 对三五个节点进行连锁更新是绝对不会影响性能的；</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>结构紧凑：一整块连续内存，没有多余的内存碎片，更新会导致内存 realloc 与内存复制，平均时间复杂度为 <code>O(N)</code></li>
<li><strong>逆向遍历：从表尾开始向表头进行遍历(注意了！，但是插入还是在表头)</strong></li>
<li>连锁更新：对前一条数据的更新，可能导致后一条数据的 prev_entry_length 与 encoding 所需长度变化，产生连锁反应，更新操作最坏时间为 <code>O(N^2)</code></li>
</ul>
<h4 id="QuickList"><a href="#QuickList" class="headerlink" title="QuickList"></a>QuickList</h4><p>在较早版本的 redis 中，list 有两种底层实现：</p>
<ul>
<li><strong>当列表对象中元素的长度比较小或者数量比较少的时候，采用压缩列表 ziplist 来存储</strong></li>
<li><strong>当列表对象中元素的长度比较大或者数量比较多的时候，则会转而使用双向列表 linkedlist 来存储</strong></li>
</ul>
<p>两者各有优缺点：</p>
<ul>
<li><strong>ziplist 的优点是内存紧凑，访问效率高，缺点是更新效率低，并且数据量较大时，可能导致大量的内存复制</strong></li>
<li><strong>linkedlist 的优点是节点修改的效率高，但是需要额外的内存开销，并且节点较多时，会产生大量的内存碎片</strong></li>
</ul>
<p>为了结合两者的优点，<strong>在 redis 3.2 之后，list 的底层实现变为快速列表 quicklist</strong>。<br>快速列表是 linkedlist 与 ziplist 的结合: quicklist 包含多个内存不连续的节点，但每个节点本身就是一个 ziplist。</p>
<p>在Redis＞3.2：使用链表和<code>ziplist</code>结合的<code>quickList</code></p>
<h4 id="quickListNode结构"><a href="#quickListNode结构" class="headerlink" title="quickListNode结构"></a>quickListNode结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span>  <span class="comment">//前一个quicklistNode</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span>  <span class="comment">//后一个quicklistNode</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *zl;           <span class="comment">//quicklistNode指向的ziplist</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sz;             <span class="comment">//ziplist的字节大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count : <span class="number">16</span>;     <span class="comment">//ziplist中的元素个数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> encoding : <span class="number">2</span>;   <span class="comment">//编码格式，原生字节数组或压缩存储</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> container : <span class="number">2</span>;  <span class="comment">//存储方式</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> recompress : <span class="number">1</span>; <span class="comment">//数据是否被压缩</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> attempted_compress : <span class="number">1</span>; <span class="comment">//数据能否被压缩</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> extra : <span class="number">10</span>;     <span class="comment">//预留的bit位</span></span><br><span class="line">&#125; quicklistNode;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>prev、next指向该节点的前后节点；</p>
<p>zl指向该节点对应的ziplist结构；</p>
<p>sz代表整个ziplist结构的大小；</p>
<p>encoding代表采用的编码方式：1代表是原生的，2代表使用LZF进行压缩；</p>
<p>container为quicklistNode节点zl指向的容器类型：1代表none,2代表使用ziplist存储数据</p>
<p>recompress代表这个节点之前是否是压缩节点，若是，则在使用压缩节点前先进行解压缩，使用后需要重新压缩，此外为1，代表是压缩节点；</p>
<p>attempted_compress测试时使用；</p>
<p>extra为预留</p>
<h4 id="quickList"><a href="#quickList" class="headerlink" title="quickList"></a>quickList</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct quicklist &#123;</span><br><span class="line">    quicklistNode *head;   // quicklist的链表头</span><br><span class="line">    quicklistNode *tail;   // quicklist的链表尾</span><br><span class="line">    unsigned long count;   // 所有ziplist中的总元素个数</span><br><span class="line">    unsigned long len;     // quicklistNodes的个数</span><br><span class="line">    int fill : QL_FILL_BITS;  // 单独解释</span><br><span class="line">    unsigned int compress : QL_COMP_BITS; // 具体含义是两端各有compress个节点不压缩</span><br><span class="line">    ...</span><br><span class="line">&#125; quicklist;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>fill用来指明每个quicklistNode中ziplist长度，当fill为正数时，表明每个ziplist最多含有的数据项数，当fill为负数时，如下：</p>
<ul>
<li>Length -1: 4k，即ziplist节点最大为4KB</li>
<li>Length -2: 8k，即ziplist节点最大为8KB</li>
<li>Length -3: 16k …</li>
<li>Length -4: 32k</li>
<li>Length -5: 64k</li>
</ul>
<p>fill取负数时，必须大于等于-5。可以通过Redis修改参数list-max-ziplist-size配置节点所占内存大小。实际上每个ziplist节点所占的内存会在该值上下浮动。</p>
<p>考虑quicklistNode节点个数较多时，我们经常访问的是两端的数据，为了进一步节省空间，Redis允许对中间的quicklistNode节点进行压缩，通过修改参数list-compress-depth进行配置，即设置compress参数，该项的具体含义是两端各有compress个节点不压缩。</p>
<h4 id="quicklist总体结构"><a href="#quicklist总体结构" class="headerlink" title="quicklist总体结构"></a>quicklist总体结构</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/yicizhang00/image_host/main/blog-img/20251014161710528.webp" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QuickList</span><br><span class="line"> ├── quicklistNode1 → ziplist1 [a, b, c, d, e]</span><br><span class="line"> ├── quicklistNode2 → ziplist2 [f, g, h, i, j]</span><br><span class="line"> └── quicklistNode3 → ziplist3 [k, l, m, n]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>只有当前 quicklistNode 的 ziplist 已满</strong>（超过设定阈值）时，才会新建一个 quicklistNode（及其 ziplist）；<br> 否则就直接往当前节点的 ziplist 里追加。</p>
<h4 id="分裂机制"><a href="#分裂机制" class="headerlink" title="分裂机制"></a>分裂机制</h4><p>如果在 ziplist <strong>中间插入</strong> 元素，导致超出容量上限，<br> Redis 会将该 ziplist 一分为二：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原 ziplist: [a, b, c, d, e]</span><br><span class="line">插入新元素 &#x27;X&#x27; 中间后过大：</span><br><span class="line">分裂为：</span><br><span class="line">ziplist1: [a, b, X]</span><br><span class="line">ziplist2: [c, d, e]</span><br></pre></td></tr></table></figure>

<p>于是会新建一个 <code>quicklistNode</code> 用于第二个 ziplist。<br> 这样避免某个 ziplist 太大影响性能。</p>
<h4 id="合并机制"><a href="#合并机制" class="headerlink" title="合并机制"></a>合并机制</h4><p>当某个ziplist因为删除过小时，其会和相邻的ziplist合并，以减少内存使用。</p>
<h4 id="listpack"><a href="#listpack" class="headerlink" title="listpack"></a>listpack</h4><p>由于使用ziplist可能会导致：</p>
<ul>
<li><p>每个 entry 的长度字段（prevlen）需要更新；</p>
</li>
<li><p>可能引发整个 ziplist 内存重分配；</p>
</li>
<li><p>在极端情况下是 <strong>O(n²)</strong> 的复杂度，所有节点都需要更新。</p>
</li>
</ul>
<p>因此在redis7.0之后使用了listpack彻底代替了ziplist</p>
<p>其结构如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://raw.githubusercontent.com/yicizhang00/image_host/main/blog-img/20251014163041375.jpeg" alt="img"></p>
<p>相对比ziplist，去除了zltail节点，意味着没法通过O(1)找到列表结尾。其主要改进在ListPackEntry中。</p>
<h4 id="ListPackEntry"><a href="#ListPackEntry" class="headerlink" title="ListPackEntry"></a>ListPackEntry</h4><h2 id="Redis的功能"><a href="#Redis的功能" class="headerlink" title="Redis的功能"></a>Redis的功能</h2><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><h3 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h3><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><h3 id="延时队列"><a href="#延时队列" class="headerlink" title="延时队列"></a>延时队列</h3><h3 id="分布式Session"><a href="#分布式Session" class="headerlink" title="分布式Session"></a>分布式Session</h3><h3 id="其他业务场景"><a href="#其他业务场景" class="headerlink" title="其他业务场景"></a>其他业务场景</h3><h1 id="Redis的性能"><a href="#Redis的性能" class="headerlink" title="Redis的性能"></a>Redis的性能</h1><h2 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h2><p>Redis使用了多路复用IO来处理请求，</p>
<p>Redis 的核心命令执行逻辑仍是<strong>单线程</strong>的：</p>
<ul>
<li>所有 <code>GET</code>, <code>SET</code>, <code>ZADD</code>, <code>HGET</code> 等命令都在主线程顺序执行；</li>
<li>不存在锁竞争，也不需要上下文切换；</li>
<li>因此非常快（内存操作 + 事件循环）。</li>
</ul>
<p>💡 这正是 Redis 能在百万 QPS 场景下仍然稳定的原因。</p>
<h2 id="为什么使用单线程？"><a href="#为什么使用单线程？" class="headerlink" title="为什么使用单线程？"></a>为什么使用单线程？</h2><p>因为</p>
<p>Redis 的数据结构（hash、zset、list、dict）操作需要保持原子性；</p>
<p>多线程同时操作相同 key 会产生锁竞争；</p>
<p>多线程下难以保证命令间顺序一致性；</p>
<p>单线程 + I&#x2F;O 多线程 是一个性能与一致性的最佳平衡点。</p>
<h2 id="网络IO多线程"><a href="#网络IO多线程" class="headerlink" title="网络IO多线程"></a>网络IO多线程</h2><p>Redis6.0前，完全单线程循环的事件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌────────────────────┐</span><br><span class="line">│     单线程事件循环   │</span><br><span class="line">│--------------------│</span><br><span class="line">│ epoll_wait()等待事件│</span><br><span class="line">│ 处理读事件          │</span><br><span class="line">│ 执行命令（内存操作）  │</span><br><span class="line">│ 处理写事件          │</span><br><span class="line">└────────────────────┘</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>也就是说：</p>
<ul>
<li>Redis 主线程通过 <strong>epoll_wait()</strong> 获取活跃连接；</li>
<li>然后顺序执行所有的读、命令、写逻辑；</li>
<li>整个过程全在一个 CPU 核上完成。</li>
</ul>
<p>💡 高效是因为：</p>
<ul>
<li>不用加锁</li>
<li>不用上下文切换</li>
<li>内存操作极快</li>
</ul>
<p>而在Redis6.0之后，引入了IO多线程，epoll 仍然负责事件监听；<br> 但网络读写由多个线程并发完成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">         ┌───────────────────────────┐</span><br><span class="line">         │          主线程            │</span><br><span class="line">         │---------------------------│</span><br><span class="line">         │ epoll_wait() 获取活跃socket│</span><br><span class="line">         │ 将socket分发给I/O线程池     │</span><br><span class="line">         └────────────┬──────────────┘</span><br><span class="line">                      │</span><br><span class="line">  ┌───────────────────┼───────────────────┐</span><br><span class="line">  │                   │                   │</span><br><span class="line">  v                   v                   v</span><br><span class="line">I/O线程1           I/O线程2           I/O线程3</span><br><span class="line">(读取socket数据)  (解析请求包)      (写回响应结果)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>epoll 仍然在主线程中使用；</p>
<p>主线程收集活跃连接后，将这些连接分配给多个 I&#x2F;O 线程；</p>
<p>各线程负责并行 read()&#x2F;write()；</p>
<p>命令解析与执行仍然在主线程完成。</p>
<h2 id="异步删除多线程（懒删除lazy-free）"><a href="#异步删除多线程（懒删除lazy-free）" class="headerlink" title="异步删除多线程（懒删除lazy free）"></a>异步删除多线程（懒删除lazy free）</h2><p><strong>场景：</strong><br> 命令如 <code>UNLINK</code>, <code>FLUSHDB ASYNC</code>, <code>FLUSHALL ASYNC</code> 删除大量键时，如果在主线程中执行，会阻塞整个实例。</p>
<p><strong>解决：</strong><br> Redis 使用<strong>后台线程池</strong>异步释放内存。</p>
<p>避免主线程阻塞</p>
<h2 id="AOF-RDB"><a href="#AOF-RDB" class="headerlink" title="AOF&#x2F;RDB"></a>AOF&#x2F;RDB</h2><table>
<thead>
<tr>
<th>场景</th>
<th>线程</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>AOF 重写（BGREWRITEAOF）</td>
<td>子进程 + I&#x2F;O 线程</td>
<td>异步重写日志文件</td>
</tr>
<tr>
<td>RDB 快照（BGSAVE）</td>
<td>子进程</td>
<td>异步写入 RDB 文件</td>
</tr>
<tr>
<td>AOF fsync</td>
<td>后台线程</td>
<td>定期将 AOF buffer flush 到磁盘</td>
</tr>
</tbody></table>
<h2 id="集群和复制线程"><a href="#集群和复制线程" class="headerlink" title="集群和复制线程"></a>集群和复制线程</h2><ul>
<li><p>Redis Cluster 节点之间的 <strong>gossip 消息</strong>、<strong>replica 同步</strong> 等网络通信也通过独立线程处理；</p>
</li>
<li><p>复制时，<strong>主节点发送 RDB 文件</strong> 是在后台子进程中完成；</p>
</li>
<li><p>在 Redis 7+ 中引入了 <strong>I&#x2F;O thread per connection</strong> 的复制机制。</p>
</li>
</ul>
<h1 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h1><h1 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h1></article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">John Doe</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2025/09/22/redis/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2025/09/22/redis/')">redis</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2025/09/22/redis/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=redis&amp;url=http://example.com/2025/09/22/redis/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/java/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>java<span class="tagsPageCount">2</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/08/18/math/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">math</div></div></a></div><div class="next-post pull-right"><a href="/2025/09/22/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">分布式锁</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2025/12/31/Java/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" title="代理模式"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-12-31</div><div class="title">代理模式</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description"></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">Redis基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">Redis的数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E6%95%88%E8%83%BD"><span class="toc-number">1.2.</span> <span class="toc-text">redis效能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF"><span class="toc-number">1.3.</span> <span class="toc-text">其他的分布式缓存技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Memcached"><span class="toc-number">1.3.1.</span> <span class="toc-text">Memcached</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tendis"><span class="toc-number">1.4.</span> <span class="toc-text">Tendis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dragonfly"><span class="toc-number">1.5.</span> <span class="toc-text">Dragonfly</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#keyDB"><span class="toc-number">1.6.</span> <span class="toc-text">keyDB</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Faster"><span class="toc-number">1.7.</span> <span class="toc-text">Faster</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">Redis常见问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98"><span class="toc-number">2.1.</span> <span class="toc-text">问什么要用分布式缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">2.2.</span> <span class="toc-text">常见的缓存更新策略有哪些</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Cache-Aside-%E6%97%81%E8%B7%AF%E7%BC%93%E5%AD%98"><span class="toc-number">2.2.1.</span> <span class="toc-text">Cache Aside(旁路缓存)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E5%A4%8D%E7%8E%B0%EF%BC%88%E5%85%88%E5%88%A0%E9%99%A4%E5%90%8E%E5%86%99%EF%BC%89"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">场景复现（先删除后写）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E5%A4%8D%E7%8E%B0%EF%BC%88%E5%85%88%E5%86%99%E5%90%8E%E5%88%A0%E9%99%A4%EF%BC%89"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">场景复现（先写后删除）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E5%A4%8D%E7%8E%B0%EF%BC%88%E5%85%88%E5%86%99%E5%90%8E%E5%88%A0%E9%99%A4%E4%BE%9D%E6%97%A7%E6%9C%89%E9%97%AE%E9%A2%98%EF%BC%89"><span class="toc-number">2.2.1.3.</span> <span class="toc-text">场景复现（先写后删除依旧有问题）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5"><span class="toc-number">2.2.1.4.</span> <span class="toc-text">优化手段</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Read-Through-Pattern-%E8%AF%BB%E7%A9%BF%E9%80%8F"><span class="toc-number">2.2.2.</span> <span class="toc-text">Read Through Pattern 读穿透</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Write-Through-Pattern%EF%BC%88%E5%86%99%E7%A9%BF%E9%80%8F%EF%BC%89"><span class="toc-number">2.2.3.</span> <span class="toc-text">Write Through Pattern（写穿透）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Read-Back-%EF%BC%88%E5%86%99%E5%9B%9E%EF%BC%89"><span class="toc-number">2.2.4.</span> <span class="toc-text">Read Back （写回）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.</span> <span class="toc-text">Redis底层结构以及实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">底层结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#String-SDS"><span class="toc-number">3.1.1.</span> <span class="toc-text">String(SDS)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E5%8F%8C%E7%AB%AF%E9%93%BE%E8%A1%A8"><span class="toc-number">3.1.2.</span> <span class="toc-text">List双端链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ZipList"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">ZipList</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E9%94%81%E6%9B%B4%E6%96%B0"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">连锁更新</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">3.1.2.3.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#QuickList"><span class="toc-number">3.1.2.4.</span> <span class="toc-text">QuickList</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#quickListNode%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.2.5.</span> <span class="toc-text">quickListNode结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#quickList"><span class="toc-number">3.1.2.6.</span> <span class="toc-text">quickList</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#quicklist%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.2.7.</span> <span class="toc-text">quicklist总体结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E8%A3%82%E6%9C%BA%E5%88%B6"><span class="toc-number">3.1.2.8.</span> <span class="toc-text">分裂机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">3.1.2.9.</span> <span class="toc-text">合并机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#listpack"><span class="toc-number">3.1.2.10.</span> <span class="toc-text">listpack</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ListPackEntry"><span class="toc-number">3.1.2.11.</span> <span class="toc-text">ListPackEntry</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">3.2.</span> <span class="toc-text">Redis的功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">3.2.1.</span> <span class="toc-text">分布式锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%90%E6%B5%81"><span class="toc-number">3.2.2.</span> <span class="toc-text">限流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">3.2.3.</span> <span class="toc-text">消息队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97"><span class="toc-number">3.2.4.</span> <span class="toc-text">延时队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8FSession"><span class="toc-number">3.2.5.</span> <span class="toc-text">分布式Session</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF"><span class="toc-number">3.2.6.</span> <span class="toc-text">其他业务场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E7%9A%84%E6%80%A7%E8%83%BD"><span class="toc-number">4.</span> <span class="toc-text">Redis的性能</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.1.</span> <span class="toc-text">单线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%8D%95%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">为什么使用单线程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9CIO%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.3.</span> <span class="toc-text">网络IO多线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%88%A0%E9%99%A4%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E6%87%92%E5%88%A0%E9%99%A4lazy-free%EF%BC%89"><span class="toc-number">4.4.</span> <span class="toc-text">异步删除多线程（懒删除lazy free）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOF-RDB"><span class="toc-number">4.5.</span> <span class="toc-text">AOF&#x2F;RDB</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E5%92%8C%E5%A4%8D%E5%88%B6%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.6.</span> <span class="toc-text">集群和复制线程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.</span> <span class="toc-text">哨兵模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.</span> <span class="toc-text">集群模式</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/31/%E7%BD%91%E7%BB%9C/Untitled%201/" title="No title">No title</a><time datetime="2025-12-31T03:26:16.223Z" title="Created 2025-12-31 11:26:16">2025-12-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/31/linux%E5%86%85%E6%A0%B8/" title="No title">No title</a><time datetime="2025-12-31T03:26:16.222Z" title="Created 2025-12-31 11:26:16">2025-12-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/31/%E4%B8%AA%E4%BA%BA%E4%BB%8B%E7%BB%8D/" title="No title">No title</a><time datetime="2025-12-31T03:26:16.222Z" title="Created 2025-12-31 11:26:16">2025-12-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/31/hello-world/" title="Hello World">Hello World</a><time datetime="2025-12-31T03:26:16.221Z" title="Created 2025-12-31 11:26:16">2025-12-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/31/Java/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" title="代理模式">代理模式</a><time datetime="2025-12-31T01:52:52.000Z" title="Created 2025-12-31 09:52:52">2025-12-31</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2025 By <a class="footer-bar-link" href="/" title="John Doe" target="_blank">John Doe</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">Articles</div><div class="length-num">38</div></a><a href="/tags/" title="tag"><div class="headline">Tags</div><div class="length-num">6</div></a><a href="/categories/" title="category"><div class="headline">Categories</div><div class="length-num">20</div></a></div><span class="sidebar-menu-item-title">Function</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="Display Mode"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>Display Mode</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/java/" style="font-size: 0.88rem;">java<sup>2</sup></a><a href="/tags/leetcode/" style="font-size: 0.88rem;">leetcode<sup>5</sup></a><a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 0.88rem;">分布式<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 0.88rem;">数据库<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 0.88rem;">算法<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/" style="font-size: 0.88rem;">网络安全<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.14",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 John Doe 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>