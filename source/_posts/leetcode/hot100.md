---
title: Hot100
date: 2025-08-12 01:57:43
categories:
  - leetcode
tags:
  - leetcode
---

# å“ˆå¸Œ

## ä¸¤æ•°ä¹‹å’Œ

ç”¨å“ˆå¸Œè¡¨ç»´æŠ¤ä¸€ä¸ªå½“å‰<æœŸæœ›å€¼ï¼Œå½“å‰å€¼>çš„å“ˆå¸Œè¡¨å³å¯ã€‚

```
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for(int i = 0 ; i < nums.length ; i ++){
            if (map.containsKey(target-nums[i])){
                return new int[]{i, map.get(target-nums[i])};
            } else {
                map.put(nums[i],i);
            }
        }
        return new int[]{};
    }
}
```



## å­—æ¯å¼‚ä½è¯åˆ†ç»„

ç”¨ä¸€ä¸ªå“ˆå¸Œè¡¨ç»´æŠ¤<å­—æ¯å¼‚ä½è¯ï¼ŒåŸå­—ç¬¦ä¸²>

>  å…¶ä¸­å¯ä»¥å°†æ¯ä¸€ä¸ªè´¨æ•°ä»£æ›¿ä¸€ä¸ªå­—æ¯ï¼Œè´¨æ•°ç›¸ä¹˜ç‹¬ç‰¹çš„å­—æ¯å¼‚ä½è¯æœ‰ç‹¬ç«‹çš„è´¨æ•°ç›¸ä¹˜ç»“æœã€‚ä½†æ˜¯ä½¿ç”¨æ­¤æ–¹æ³•è¦æ³¨æ„å­˜åœ¨æº¢å‡ºçš„é£é™©ã€‚

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        HashMap<String, List<String>> hashMap = new HashMap<>();
        for(String str : strs){
            char[] c = str.toCharArray();
            Arrays.sort(c);
            String t = new String(c);
            if(hashMap.containsKey(t)){
                List l = hashMap.get(t);
                l.add(str);
                hashMap.put(t,l);
            } else {
                List<String> l = new ArrayList<>();
                l.add(str);
                hashMap.put(t,l);
            }
        }
        List<List<String>> res = new ArrayList<>();
        for(Map.Entry<String, List<String>> p : hashMap.entrySet()){
            res.add(p.getValue());
        }
        return res;
    }
}
```





## æœ€é•¿è¿ç»­åºåˆ—

é¦–å…ˆå…¨éƒ¨åŠ å…¥Setä¸­ï¼Œç„¶åéå†Setåˆ¤æ–­å½“å‰æ•°å­—æ˜¯å¦ä¸ºè¯¥æ®µåºåˆ—çš„å¼€å¤´ï¼Œå¦‚æœæ˜¯åˆ™éå†ä¸‹å»ã€‚

```java
class Solution {
    public int longestConsecutive(int[] nums) {
        Set<Integer> hashSet = new HashSet<>();
        int res = 0;

        for(int i = 0 ; i < nums.length; i ++){
            hashSet.add(nums[i]);
        }
        for(int t : hashSet){//æ³¨æ„è¿™é‡Œéœ€è¦ä»hashSetéå†ï¼Œä¸èƒ½ä»numsï¼Œnumsæœ‰é‡å¤å…ƒç´ 
            if(!hashSet.contains(t-1)){
                int num = t+1;
                while(hashSet.contains(num)) num++;
                res = Math.max(res, num-t);
                
            }
        }

        return res;
    }
}
```





# 



æœ¬è´¨ä¸Šè¿˜æ˜¯åŒæŒ‡é’ˆ

```java

```



# åŒæŒ‡é’ˆ

## ç§»åŠ¨é›¶

æœ¬è´¨ä¸Šè¿˜æ˜¯åŒæŒ‡é’ˆ

```
class Solution {
    public void moveZeroes(int[] nums) {
        //ç»´æŠ¤ä¸¤ä¸ªæŒ‡é’ˆï¼Œp1æŒ‡å‘ç¬¬ä¸€ä¸ªé›¶ï¼Œp2æŒ‡å‘ç¬¬ä¸€ä¸ªéé›¶
        int p1 = 0;
        int p2 = 0;
        while(p1 < nums.length && p2<nums.length){
            while(nums[p1] != 0) {
            p1++;
        if(p1 >= nums.length) return;
            }
            p2 = p1+1;
            if(p2 >= nums.length) break;
            while(nums[p2] == 0){
            p2 ++;
         if(p2 >= nums.length) return;
            } 
            int t = nums[p1];
            nums[p1] = nums[p2];
            nums[p2] = t;
            p1 = p1+1;
        }
    }
}
```



# æ»‘åŠ¨çª—å£

## æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        if(s.length() == 0){
            return 0;
        }
        int res = 1;
        Set<Character> hashSet = new HashSet<>();
        int i = 0;
        int j = 0;
        for(i = 0 ; i < s.length();i++){
            while(hashSet.contains(s.charAt(i))){
                hashSet.remove(s.charAt(j));
                j++;
            }
            hashSet.add(s.charAt(i));
            res = Math.max(res, i - j + 1);
        }
        return res;
    }
}
```

## æ‰¾åˆ°å­—ç¬¦ä¸²ä¸­æ‰€æœ‰å­—æ¯å¼‚ä½è¯

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> res = new ArrayList<>();
        int m = s.length(), n = p.length();
        if (m < n) return res;

        int[] count = new int[26];
        for (int i = 0; i < n; i++) {
            count[s.charAt(i) - 'a']++;
            count[p.charAt(i) - 'a']--;
        }

        int diff = 0;
        for (int c : count) if (c != 0) diff++;

        if (diff == 0) res.add(0);

        for (int i = n; i < m; i++) {
            int add = s.charAt(i) - 'a';
            int remove = s.charAt(i - n) - 'a';

            if (count[add] == 0) diff++;
            count[add]++;
            if (count[add] == 0) diff--;

            if (count[remove] == 0) diff++;
            count[remove]--;
            if (count[remove] == 0) diff--;

            if (diff == 0) res.add(i - n + 1);
        }

        return res;
    }
}

```



# é“¾è¡¨

## ç›¸äº¤é“¾è¡¨

éå†ä¸¤æ¬¡åˆ¤æ–­äº¤ç‚¹

```java
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode a = headA;
        ListNode b = headB;
        while( a!=b){
            a=a!= null?a.next:headA;
            b=b!=null?b.next:headB;
        }
        return a;
    }
```





# çŸ©é˜µ

## æ—‹è½¬å›¾åƒ

è½¬ç½®åè¿›è¡Œè½´å¯¹ç§°



# æ ‘

## äºŒå‰æ ‘ä¸­åºéå†

ä¸­åºéå†ä¸€ä¸‹ï¼ŒæŒ‰ç…§

dfs(root.left)

print(root)

dfs(root.right)

```java
    public static void dfs(TreeNode root){
        if(root==null)
        return;
        dfs(root.left);
        res.add(root.val);
        dfs(root.right);

    }
```



## äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦

é€’å½’æŸ¥æ‰¾æ¯ä¸€å±‚èŠ‚ç‚¹çš„æ·±åº¦

```java
    public int maxDepth(TreeNode root) {
        return dfs(root);
    }
    static int dfs(TreeNode root){
        if(root == null)
        return 0;
        return Math.max(dfs(root.left),dfs(root.right)) + 1;
    }
```

## å¯¹ç§°äºŒå‰æ ‘

é€’å½’äº¤æ¢æ£€æŸ¥æ¯å±‚çš„å·¦å³èŠ‚ç‚¹æ˜¯å¦å¯¹ç§°

```java
    public static boolean dfs(TreeNode left, TreeNode right){
        if(left == null && right == null) 
        return true;
        if(left == null && right != null)
        return false;
        if(right == null && left != null)
        return false;
        if(left.val == right.val && dfs(left.left,right.right) && dfs(left.right,right.left) )
        return true;
        return false;
    }
```



## ç¿»è½¬äºŒå‰æ ‘

ä½¿ç”¨é€’å½’äº¤æ¢æ¯ä¸€å±‚çš„å·¦å³å­èŠ‚ç‚¹

```
    public static void dfs(TreeNode node){
        if(node == null) return;
        TreeNode t = new TreeNode();
        t = node.left;
        node.left = node.right;
        node.right = t;
        dfs(node.left);
        dfs(node.right);
    }
```



## äºŒå‰æ ‘çš„ç›´å¾„

é¢˜ç›®ï¼šç»™ä½ ä¸€æ£µäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œè¿”å›è¯¥æ ‘çš„ **ç›´å¾„** ã€‚

äºŒå‰æ ‘çš„ **ç›´å¾„** æ˜¯æŒ‡æ ‘ä¸­ä»»æ„ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹é—´æœ€é•¿è·¯å¾„çš„ **é•¿åº¦** ã€‚è¿™æ¡è·¯å¾„å¯èƒ½ç»è¿‡ä¹Ÿå¯èƒ½ä¸ç»è¿‡æ ¹èŠ‚ç‚¹ `root` ã€‚

ä¸¤èŠ‚ç‚¹ä¹‹é—´è·¯å¾„çš„ **é•¿åº¦** ç”±å®ƒä»¬ä¹‹é—´è¾¹æ•°è¡¨ç¤ºã€‚

æ€è·¯ï¼šé€’å½’æœç´¢æ¯ä¸ªèŠ‚ç‚¹çš„å·¦å³å­æ ‘è·¯å¾„å’Œï¼Œåœ¨ä¸»å‡½æ•°ä½¿ç”¨ä¸€ä¸ªå…¨å±€å˜é‡ç»´æŠ¤è¯¥æœ€å¤§å€¼ã€‚

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    
    static int ans = 0;
    public int diameterOfBinaryTree(TreeNode root) {
        if(root == null) 
        return 0;
        ans = 1;
        dep(root);
        return ans-1;

    }
    public static int dep(TreeNode node){
        if(node == null) return 0;
        int l = dep(node.left);
        int r = dep(node.right);
        ans = Math.max(ans, l+r+1);
        return Math.max(l,r)+1;
    }
}
```

> æ³¨ï¼šäºŒå‰æ ‘çš„ç›´å¾„ä¸åŒäºå›¾çš„ç›´å¾„ï¼Œå›¾çš„ç›´å¾„å¯ä»¥é€šè¿‡ä¸¤æ¬¡éå†å…ˆæ‰¾åˆ°ä¸€ç«¯çš„ç›´å¾„ç«¯ç‚¹ï¼Œç„¶åå†æ‰¾åˆ°å¦ä¸€ç«¯çš„ç›´å¾„ç«¯ç‚¹å®ç°ï¼Œæ¨¡æ¿å¦‚ä¸‹
>
> ```java
> public static int treeDiameter(int n, List<List<Integer>> adj) {
>         if (n == 0) return 0;
>         // ä»ä»»æ„èŠ‚ç‚¹ 0 å¼€å§‹ BFS æ‰¾æœ€è¿œç‚¹
>         int far = bfsFarthest(0, n, adj)[0];
>         // ä» far å†æ¬¡ BFSï¼Œå¾—åˆ°æœ€è¿œè·ç¦»
>         int[] res = bfsFarthest(far, n, adj);
>         return res[1]; // distance
>     }
> 
>     // è¿”å›é•¿åº¦ä¸º2çš„æ•°ç»„: [farthestNode, distance]
>     private static int[] bfsFarthest(int src, int n, List<List<Integer>> adj) {
>         int[] dist = new int[n];
>         Arrays.fill(dist, -1);
>         Queue<Integer> q = new ArrayDeque<>();
>         q.add(src);
>         dist[src] = 0;
>         int farNode = src;
>         while (!q.isEmpty()) {
>             int u = q.poll();
>             for (int v : adj.get(u)) {
>                 if (dist[v] == -1) {
>                     dist[v] = dist[u] + 1;
>                     q.add(v);
>                     if (dist[v] > dist[farNode]) farNode = v;
>                 }
>             }
>         }
>         return new int[]{farNode, dist[farNode]};
>     }
> ```
>
> 

## äºŒå‰æ ‘å±‚åºéå†

ä½¿ç”¨ä¸€ä¸ªQueueç»´æŠ¤äºŒå‰æ ‘çš„æ¯å±‚èŠ‚ç‚¹ã€‚forå¾ªç¯ç»Ÿè®¡å½“å‰å±‚èŠ‚ç‚¹æ•°é‡ã€‚

```java
public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res= new ArrayList<>();
        if(root==null){
            return res;
        }
        Deque<TreeNode> d = new ArrayDeque<>();
        d.addLast(root);
        while(!d.isEmpty()){
            int size = d.size();
            List<Integer> t = new ArrayList<>();
            for(int i=0;i<size;i++){
                TreeNode n=d.removeFirst();
                t.add(n.val);
                if(n.left!=null) d.addLast(n.left);
                if(n.right!=null) d.addLast(n.right);
            }
            res.add(t);
        }
        return res;
    }
```

## æ•°ç»„è½¬åŒ–ä¸ºå¹³è¡¡äºŒå‰æœç´¢æ ‘

BSTé€’å½’ååºéå†å»ºç«‹æ ‘ï¼Œæ ¸å¿ƒå…¬å¼ï¼šint mid = (l + r) / 2 é€‰ä¸­ä¹‹åå†å»ºæ ‘ï¼Œè®°ä½å°±å¥½ã€‚

æ³¨æ„äºŒåˆ†æ³•çš„é€’å½’èŒƒå›´ä¸º

```java
if (left > right) return null;
TreeNode l = dfs(nums, left, mid - 1);
TreeNode r = dfs(nums, mid + 1, right);
```

```java
public TreeNode sortedArrayToBST(int[] nums) {
        return dfs(nums,0,nums.length-1);
    }
    public static TreeNode dfs(int[] nums, int left, int right){
        if(left > right)
        return null;
        int mid = (left + right) / 2;
        TreeNode t = new TreeNode(nums[mid]);
        TreeNode l = dfs(nums,left,mid-1);
        TreeNode r = dfs(nums,mid+1,right);
        t.left = l;
        t.right = r;
        return t;
    }
```



## éªŒè¯äºŒå‰æœç´¢æ ‘

é€’å½’æŸ¥è¯¢æ¯ä¸ªèŠ‚ç‚¹æ˜¯å¦å¤§äºå…¶å·¦å­æ ‘çš„æœ€å¤§å€¼ï¼Œå¹¶ä¸”å°äºå…¶å³å­æ ‘çš„æœ€å°å€¼ã€‚é¢å¤–åˆ›å»ºä¸¤ä¸ªé€’å½’æŸ¥è¯¢å·¦å­æ ‘çš„æœ€å¤§å€¼å’Œå³å­æ ‘çš„æœ€å°å€¼ã€‚

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isValidBST(TreeNode root) {
        return dfs(root);
    }
    static boolean dfs(TreeNode root){
        if(root == null)
        return true;
        int mid = root.val;
        long l = root.left==null? Long.MIN_VALUE: (long)dfs_r(root.left);
        long r = root.right==null? Long.MAX_VALUE: (long)dfs_l(root.right);
        return mid > l && mid < r && dfs(root.left) && dfs(root.right);
    }
    static int dfs_l(TreeNode root){
        if(root.left != null)
            return dfs_l(root.left);
        else 
            return root.val; 
    }
    static int dfs_r(TreeNode root){
        if(root.right!=null){
            return dfs_r(root.right);
        }else{
            return root.val;
        }
    }
}
```



## äºŒå‰æœç´¢æ ‘ä¸­ç¬¬Kå°çš„å…ƒç´ 

å…¶å®å°±æ˜¯ä¸­åºéå†åˆ°çš„ç¬¬kä¸ªå…ƒç´ ï¼Œç»´æŠ¤ä¸€ä¸ªå…¨å±€å˜é‡ç»Ÿè®¡ä¸€ä¸‹å½“å‰ç»Ÿè®¡åˆ°çš„å…ƒç´ ä¸ªæ•°ã€‚

```java
    static int cnt;
    static int res;
    public int kthSmallest(TreeNode root, int k) {
        cnt = 0;
        dfs(root,k);
        return res;
    }
    static void dfs(TreeNode root, int k){
        if(root == null){
            return; 
        }
        dfs(root.left, k);
        cnt ++;
        if(cnt == k){
            res=root.val;
            return;
        }
        dfs(root.right, k);
    }
```

## äºŒå‰æ ‘çš„å³è§†å›¾

å¯¹äºåŒä¸€æ·±åº¦çš„èŠ‚ç‚¹æ¥è¯´ï¼Œå¦‚æœå³å­æ ‘å­˜åœ¨çš„è¯å°±åªèƒ½çœ‹è§å³å­æ ‘ï¼Œæ‰€ä»¥æˆ‘ä»¬è¦ä»å³->å·¦è¿›è¡Œéå†ï¼Œç»´æŠ¤ä¸€ä¸ªæ•°ç»„ï¼Œç»Ÿè®¡æ·±åº¦ä¸ºiçš„å±‚æ˜¯å¦å·²ç»æœ‰èŠ‚ç‚¹åœ¨å³è§†å›¾ä¸­ã€‚ä»é¡¶éƒ¨åˆ°åº•éƒ¨è®¿é—®ï¼Œå¯ä»¥æ”¹ä¸º[æ ¹->å³->å·¦]

æ³¨æ„ï¼šå…¶ä¸­[å³->å·¦]çš„é¡ºåºå¯ä»¥ä¸å˜,æ”¹å˜[æ ¹]çš„ä½ç½®å¯ä»¥å®ç°ä»é¡¶éƒ¨åˆ°åº•éƒ¨ï¼Œä½†ä¸èƒ½ä»åº•éƒ¨åˆ°é¡¶éƒ¨ï¼Œè€ƒè™‘è¿™ä¸€ç§æƒ…å†µï¼Œå¦‚æœæœ‰ä¸€ä¸ªå·¦å­æ ‘å¾ˆå¤§ï¼Œä½†æ˜¯å³å­æ ‘å¾ˆå°çš„äºŒå‰æ ‘ï¼Œåœ¨[å³->å·¦]çš„é€’å½’é¡ºåºä¸‹ï¼Œä¹Ÿä¼šä¼˜å…ˆå­˜å‚¨å³å­æ ‘æ·±åº¦è¾ƒæµ…çš„å€¼ã€‚

```java
static int[] a;
    static List<Integer> res;
    public List<Integer> rightSideView(TreeNode root) {
        a = new int[100];
        res = new ArrayList<>();
        dfs(root,0);
        return res;
    }
    static void dfs(TreeNode root, int depth){
        if(root == null)
        return;
        if(a[depth] == 0){
            res.add(root.val);
            a[depth] = 1;
        }
        dfs(root.right,depth + 1);
        dfs(root.left,depth + 1);

    }   
```

## äºŒå‰æ ‘å±•å¼€ä¸ºé“¾è¡¨

![image-20250930235317445](https://raw.githubusercontent.com/yicizhang00/image_host/main/blog-img/202509302353722.png)

è§£æ³•ä¸€ï¼šé‡‡ç”¨å¤´æ’æ³•æ„å»ºé“¾è¡¨ï¼Œä¹Ÿå°±æ˜¯ä»èŠ‚ç‚¹ 6 å¼€å§‹ï¼Œåœ¨ 6 çš„å‰é¢æ’å…¥ 5ï¼Œåœ¨ 5 çš„å‰é¢æ’å…¥ 4ï¼Œä¾æ­¤ç±»æ¨ã€‚

ä¸ºæ­¤ï¼Œè¦æŒ‰ç…§ 6â†’5â†’4â†’3â†’2â†’1 çš„é¡ºåºè®¿é—®èŠ‚ç‚¹ã€‚å¦‚ä½•éå†è¿™æ£µæ ‘ï¼Œæ‰èƒ½å®ç°è¿™ä¸ªé¡ºåºï¼Ÿ

è€ƒè™‘åˆ°é“¾è¡¨ä¸ºå…ˆåºéå†çš„ç»“æœï¼Œæˆ‘ä»¬è¦å°†é€’å½’çš„æ ¹èŠ‚ç‚¹çš„å³å­æ ‘æŒ‡å‘ã€å³->å·¦->æ ¹ã€‘çš„è®¿é—®åˆ°çš„å€’æ•°ç¬¬äºŒä¸ªèŠ‚ç‚¹ï¼Œæ‰€ä»¥éœ€è¦åå‘éå†ä¸ºã€å³->å·¦->æ ¹ã€‘ï¼Œç”¨å…¨å±€å˜é‡è®°å½•ä¸‹è®¿é—®åˆ°çš„æ ¹èŠ‚ç‚¹ã€‚

```java
    private static TreeNode head;
    
    public void flatten(TreeNode root) {
        head=null;
        dfs(root);

    }
    public static void dfs(TreeNode node){
        if(node == null)
        return;
        dfs(node.right);
        dfs(node.left);
        node.left = null;
        node.right = head;
        head = node;

    }
```

è§£æ³•äºŒï¼š

æ­£å¸¸ä½¿ç”¨å…ˆåºéå†çš„ç»“æœï¼Œç”±äºè¿›å…¥é€’å½’åï¼Œä½†æ˜¯ä¾ç„¶è¦ä½¿ç”¨å…¨å±€å˜é‡è®°å½•ä¸‹å‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œä»¥åŠå½“å‰èŠ‚ç‚¹çš„åŸå§‹å³å­æ ‘ã€‚

```java
private static TreeNode pre; // è®°å½•å‰ä¸€ä¸ªè®¿é—®è¿‡çš„èŠ‚ç‚¹

public void flatten(TreeNode root) {
    pre = null;   // æ¯æ¬¡è°ƒç”¨å‰è¦æ¸…ç©º
    dfs(root);
}

public static void dfs(TreeNode node) {
    if (node == null) return;

    // å¦‚æœ pre å·²ç»å­˜åœ¨ï¼ŒæŠŠ pre çš„ right æŒ‡å‘å½“å‰èŠ‚ç‚¹
    if (pre != null) {
        pre.left = null;   // å·¦å­æ ‘è¦æ–­æ‰
        pre.right = node;  // å‰ä¸€ä¸ªèŠ‚ç‚¹çš„å³æŒ‡é’ˆè¿åˆ°å½“å‰èŠ‚ç‚¹
    }
    pre = node; // æ›´æ–° preï¼Œè¡¨ç¤ºâ€œå½“å‰èŠ‚ç‚¹å°±æ˜¯ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„å‰é©±â€

    // âš ï¸ ä¿å­˜å³å­æ ‘ï¼Œé¿å…è¢«è¦†ç›–
    TreeNode right = node.right;

    // é€’å½’å¤„ç†å·¦å­æ ‘
    dfs(node.left);

    // é€’å½’å¤„ç†åŸå§‹å³å­æ ‘
    dfs(right);
}
```

## ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘

ç”±äºå‰åºæ˜¯[æ ¹->å·¦->å³]ï¼Œæ¯ä¸ªèŠ‚ç‚¹çš„æ„é€ ç”±ä¸€ä¸ªå…¨å±€å˜é‡ç»´æŠ¤ï¼Œä¸è¦å°†è¿™ä¸ªå…¨å±€å˜é‡ä½œä¸ºé€’å½’çš„å˜é‡ä¼ å…¥ï¼ä¸­åºæ˜¯[å·¦->æ ¹->å³]ï¼Œå¯ä»¥ä½¿ç”¨å‰åºçš„[æ ¹]æ‰¾åˆ°ä¸­åº[æ ¹çš„ä½ç½®]ï¼Œç„¶åä¸­åº[æ ¹]çš„å·¦å³åˆ†åˆ«ä¸ºå·¦å³å­æ ‘ã€‚

```java
class Solution {
    private int i = 0;
    private int[] preorder;
    private int[] inorder;
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        this.preorder = preorder;
        this.inorder = inorder;
        return dfs(0,preorder.length-1);
    }
    public TreeNode dfs(int j, int k){
        if(j > k)
        return null;
        int root = this.preorder[i];
        int n = 0;
        for(int m = j; m <= k;m++){
            if(this.inorder[m] == root){
                n = m;
                break;
            }
        }
        TreeNode node = new TreeNode(root);
        i++;
        node.left = dfs(j,n-1);
        node.right = dfs(n+1,k);
        return node;
    }
}
```

## è·¯å¾„ç»¼åˆIII

ä½¿ç”¨ä¸¤å±‚é€’å½’

```java
class Solution {
    private int res = 0;
    public int pathSum(TreeNode root, int targetSum) {
        if(root == null) return 0;
        dfs(root,targetSum);
        pathSum(root.left, targetSum);
        pathSum(root.right,targetSum);
        return res;
    }
    public void dfs(TreeNode root, int targetSum){
        if(root == null){
            return;
        }
        int val = root.val;
        if(val == targetSum){
            res ++;
        }
        
        dfs(root.left, targetSum - val);
        dfs(root.right, targetSum - val);
    }
}

```



ä½¿ç”¨å…¨å±€å˜é‡è®°å½•è·¯å¾„å’Œä¸ºnçš„æ¬¡æ•°ä¸ºmï¼Œç„¶åä½¿ç”¨å›æº¯æ³•+ä¸€å±‚é€’å½’

```java
class Solution {
    private int res = 0;
    private Map<Long, Integer> prefix = new HashMap<>();

    public int pathSum(TreeNode root, int targetSum) {
        prefix.put(0L, 1); // å‰ç¼€å’Œä¸º 0 å‡ºç°è¿‡ 1 æ¬¡ï¼ˆç©ºè·¯å¾„ï¼‰
        dfs(root, 0L, targetSum);
        return res;
    }

    private void dfs(TreeNode node, long currSum, int targetSum) {
        if (node == null) return;

        currSum += node.val;

        // æ‰¾åˆ°æ»¡è¶³æ¡ä»¶çš„è·¯å¾„æ•°
        res += prefix.getOrDefault(currSum - targetSum, 0);

        // æ›´æ–°å‰ç¼€å’Œ
        prefix.put(currSum, prefix.getOrDefault(currSum, 0) + 1);

        // é€’å½’å­æ ‘
        dfs(node.left, currSum, targetSum);
        dfs(node.right, currSum, targetSum);

        // å›æº¯ï¼Œæ’¤é”€å½“å‰èŠ‚ç‚¹çš„è´¡çŒ®
        prefix.put(currSum, prefix.get(currSum) - 1);
    }
}

```

## äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ

å®šä¹‰dfsä¸º**åœ¨ä»¥å½“å‰èŠ‚ç‚¹ä¸ºæ ¹çš„å­æ ‘ä¸­ï¼Œè¿”å›æ‰¾åˆ°çš„ `p`ã€`q` æˆ–è€…å…¬å…±ç¥–å…ˆ**ã€‚

![image-20251001020021223](https://raw.githubusercontent.com/yicizhang00/image_host/main/blog-img/202510010200515.png)

```
class Solution {
    private TreeNode m;
    private TreeNode n;
    private TreeNode res;
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        m = p;
        n = q;
        
        return dfs(root);
    }
 
    public TreeNode dfs(TreeNode node){
        if(node == null || node == n || node == m){
            return node;
        }
        TreeNode l = dfs(node.left);
        TreeNode r = dfs(node.right);
        if(l!=null && r!=null){
            return node;
        }
        return l==null?r:l;
    }
}
```

## äºŒå‰æ ‘ä¸­çš„æœ€å¤§è·¯å¾„å’Œ

å’ŒäºŒå‰æ ‘çš„ç›´å¾„ç±»ä¼¼ï¼Œä½¿ç”¨é€’å½’å‡½æ•°ç»´æŠ¤ä¸€ä¸ªå½“å‰èŠ‚ç‚¹å‘ä¸‹èµ°å•è¾¹è·¯å¾„çš„æœ€å¤§å€¼

**dfs çš„å«ä¹‰**

- è¿”å›å€¼ï¼šä»å½“å‰èŠ‚ç‚¹å‡ºå‘ï¼Œ**å‘ä¸‹èµ°ä¸€æ¡å•è¾¹è·¯å¾„**ï¼ˆåªèƒ½é€‰å·¦å­æ ‘æˆ–å³å­æ ‘ï¼Œä¸å¯èƒ½ä¸¤è¾¹éƒ½é€‰ï¼Œå› ä¸ºå¾€çˆ¶èŠ‚ç‚¹ä¼ é€’çš„æ—¶å€™åªèƒ½èµ°ä¸€è¾¹ï¼‰ã€‚
- å¦‚æœå­æ ‘è·¯å¾„å’Œä¸ºè´Ÿæ•°ï¼Œé‚£è¿˜ä¸å¦‚ä¸è¦ï¼Œæ‰€ä»¥ç”¨ `Math.max(..., 0)`ã€‚

**res çš„å«ä¹‰**

- `res` æ˜¯ä¸€ä¸ªå…¨å±€å˜é‡ï¼Œå­˜å‚¨ **å½“å‰éå†è¿‡ç¨‹ä¸­å‡ºç°çš„æœ€å¤§è·¯å¾„å’Œ**ã€‚

- åœ¨æ¯ä¸ªèŠ‚ç‚¹ `root` å¤„ï¼Œè·¯å¾„æœ€å¤§å€¼å¯èƒ½æ˜¯ï¼š

  ```
  å·¦å­æ ‘è´¡çŒ® + root.val + å³å­æ ‘è´¡çŒ®
  ```

  è¿™ä¸ªç»“æœå¯ä»¥å½¢æˆä¸€æ¡ç»è¿‡ `root` çš„å®Œæ•´è·¯å¾„ï¼Œå› æ­¤è¦ç”¨å®ƒæ›´æ–° `res`ã€‚

**ä¸ºä»€ä¹ˆè¿”å› `root.val + Math.max(l, r)`**

- çˆ¶èŠ‚ç‚¹åªèƒ½é€‰æ‹©ä¸€è¾¹æ¥ä¸Šå½“å‰èŠ‚ç‚¹çš„è·¯å¾„ã€‚
- æ‰€ä»¥è¿”å›å€¼æ˜¯ â€œå½“å‰èŠ‚ç‚¹å€¼ + å·¦å³å­æ ‘ä¸­è¾ƒå¤§çš„ä¸€è¾¹â€ã€‚

```java
class Solution {
    private int res = 0;

    public int maxPathSum(TreeNode root) {
        if(root == null) 
            return 0;
        res = root.val;       // åˆå§‹åŒ–ç»“æœä¸ºæ ¹èŠ‚ç‚¹å€¼ï¼Œé¿å… res åˆå§‹å€¼å¤ªå°
        dfs(root);            // æ·±åº¦ä¼˜å…ˆéå†è®¡ç®—
        return res;
    }

    // è¿”å› "ä»¥ root ä¸ºèµ·ç‚¹ï¼Œåˆ°å¶å­æ–¹å‘çš„æœ€å¤§è·¯å¾„å’Œ"
    public int dfs(TreeNode root){
        if(root == null){
            return 0;
        }
        // åˆ†åˆ«è®¡ç®—å·¦å­æ ‘ã€å³å­æ ‘çš„æœ€å¤§è´¡çŒ®ï¼ˆå°äº0çš„è·¯å¾„ç›´æ¥èˆå¼ƒï¼Œæ‰€ä»¥ç”¨ Math.max(..., 0)ï¼‰
        int l = Math.max(dfs(root.left), 0);
        int r = Math.max(dfs(root.right), 0);

        // æ›´æ–°å…¨å±€æœ€å¤§è·¯å¾„ï¼šå¯èƒ½ç»è¿‡å½“å‰ rootï¼Œè·¯å¾„ = å·¦è´¡çŒ® + root.val + å³è´¡çŒ®
        res = Math.max(res, l + r + root.val);

        // è¿”å› "å½“å‰èŠ‚ç‚¹èƒ½æä¾›ç»™çˆ¶èŠ‚ç‚¹çš„æœ€å¤§å•è¾¹è´¡çŒ®"
        return root.val + Math.max(l, r);
    }
}

```

# å›¾è®º

## å²›å±¿æ•°é‡

dfsé€’å½’æ„ŸæŸ“å››å‘¨å²›å±¿ï¼Œå°†å²›å±¿ç”±'1'å˜ä¸º'2'ï¼Œé€šè¿‡è¾¹ç•Œæ¡ä»¶æ§åˆ¶æ„ŸæŸ“ã€‚

```java
class Solution {
    private int res =0;
    public int numIslands(char[][] grid) {
        for(int i = 0 ; i < grid.length;i++){
            for(int j = 0; j < grid[0].length;j++){
                if(grid[i][j] == '1'){
                    dfs(grid,i,j);
                    res ++;
                }
            }
        }
        return res;
        
    }
    public void dfs(char[][] grid ,int i ,int j){
        if(i <0 || i >= grid.length || j <0 || j>=grid[0].length || grid[i][j] != '1'){
            return;
        }
        grid[i][j] = '2';
        dfs(grid,i-1,j);
        dfs(grid,i+1,j);
        dfs(grid,i,j+1);
        dfs(grid,i,j-1);
    }
}
```

## è…çƒ‚çš„æ©˜å­

ç±»ä¼¼äºå›¾çš„å±‚åºéå†

```java

    class Node{
    int x;
    int y;
    Node(int x,int y){
        this.x = x;
        this.y = y;
    }
    public int getX(){
        return x;
    }
    public int getY(){
        return y;
    }
    }

class Solution {

    public int orangesRotting(int[][] grid) {
        int res = -1;
        int fresh =0 ;
            int m = grid.length;
            int n = grid[0].length;
            
            Deque<Node> d = new ArrayDeque<>();
            for(int i = 0 ; i < m; i ++){
                for(int j = 0 ;j<n;j++){
                    if(grid[i][j] == 2){
                        Node node = new Node(i,j);
                        d.addLast(node);
                    } else if (grid[i][j] == 1){
                        fresh ++;
                    }
                }
            }
            while(!d.isEmpty()){
                res++;
                int size = d.size();
                for(int k = 0 ; k < size ; k++){
                    Node t = d.removeFirst();
                    int x = t.getX();
                    int y = t.getY();
                    if(x + 1 < m && grid[x+1][y] == 1){
                        Node t1 = new Node(x+1,y);
                        d.addLast(t1);
                        grid[x+1][y]='2';
                        fresh--;
                    }
                    if( x - 1 >=0 && grid[x-1][y] == 1){
                        Node t1 = new Node(x-1,y);
                        d.addLast(t1);
                        grid[x-1][y]='2';
                        fresh--;
                    }
                    if( y-1 >=0 && grid[x][y-1] == 1){
                        Node t1 = new Node(x,y-1);
                        d.addLast(t1);
                        grid[x][y-1]='2';
                        fresh--;
                    }
                    if(y+1 < n && grid[x][y+1] == 1){
                        Node t1 = new Node(x,y+1);
                        d.addLast(t1);
                        grid[x][y+1]='2';
                        fresh--;
                    }
                }
            }
            return fresh==0?Math.max(0,res):-1;
    }
}

```

## è¯¾ç¨‹è¡¨

æ„é€ ä¸€ä¸ªé‚»æ¥è¡¨ï¼Œç”¨æ‹“æ‰‘æ’åºçš„æ–¹å¼éå†ï¼Œè®¡ç®—æœ€åæ˜¯å¦æœ‰èŠ‚ç‚¹æ— æ³•è¢«å†™å…¥æ‹“æ‰‘æ’åºä¸­

```java
class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        //å…¥åº¦ç»Ÿè®¡
        int[] inDegree = new int[numCourses];
        //å»ºå›¾
        List<List<Integer>> graph = new ArrayList<>();
        for(int i = 0 ; i < numCourses; i ++){
            List<Integer> l = new ArrayList<>();
            graph.add(l);
        }
        for(int i = 0 ; i < prerequisites.length;i++){
            int a = prerequisites[i][0];
            int b = prerequisites[i][1];
            graph.get(a).add(b);
            inDegree[b] ++;
        }
        //ç»Ÿè®¡åˆ é™¤ç‚¹çš„æ•°é‡
        List<Integer> res = new ArrayList<>();
        //å…¥åº¦ä¸º0çš„ç‚¹åŠ å…¥é˜Ÿåˆ—
        Deque<Integer> d = new ArrayDeque<>();
        for(int i = 0 ; i < numCourses ; i++){
            if(inDegree[i] == 0){
                d.addLast(i);
                res.add(i);
            }

        }
        while(!d.isEmpty()){
            int size = d.size();
            for(int i = 0 ; i < size ; i ++){
                //æ‰¾åˆ°æ‰€æœ‰å…¥åº¦ä¸º0çš„ç‚¹æ‰€æŒ‡å‘çš„è¾¹
                int c = d.removeFirst();
                List<Integer> t = graph.get(c);
                for(int m  : t){
                    inDegree[m]--;
                    //å¦‚æœå¯¼è‡´å…¶å…¥åº¦ä¸º0ï¼Œåˆ™å…¥é˜Ÿ
                    if(inDegree[m] == 0){
                        d.addLast(m);
                        res.add(m);
                    }
                }
            }
        }
        //åˆ¤æ–­æ˜¯å¦åˆ é™¤äº†æ‰€æœ‰èŠ‚ç‚¹
        if(res.size() == numCourses){
            return true;
        }
        return false;

    }
}
```

## å‰ç¼€æ ‘Trie

å‰ç¼€æ ‘å®é™…ä¸Šå°±æ˜¯ä¸€ä¸ªå¤šèŠ‚ç‚¹çš„æ ‘ï¼Œç”¨HashMap<Character,Trie>æˆ–è€…Tire[]æ¥ç»´æŠ¤å­èŠ‚ç‚¹ï¼Œç„¶ååœ¨æ¯ä¸ªèŠ‚ç‚¹é¢å¤–ç»´æŠ¤ä¸€ä¸ªç¬¦å·è¡¨ç¤ºæ˜¯å¦æœ‰è¾“å…¥åˆ°æ­¤ä¸ºæ­¢ã€‚

```java
class Trie {
    HashMap<Character, Trie> hashMap;
    int flag ;
    public Trie() {
        hashMap = new HashMap<>();        
        flag = 0;
    }
    
    public void insert(String word) {
        Trie t = this;
        int len = word.length();
        for(int i = 0 ; i < len ; i ++){
            char c = word.charAt(i);
            if(t.hashMap.containsKey(c)){
                t = t.hashMap.get(c); 
            } else {
                Trie trie = new Trie();
                t.hashMap.put(c,trie);
                t = trie;
            }
        }
        t.flag = 1;
    }
    
    public boolean search(String word) {
        Trie t = this;
        int len = word.length();
        for(int i = 0 ; i < len ; i ++){
            char c = word.charAt(i);
            if(t.hashMap.containsKey(c)){
                t = t.hashMap.get(c); 
            } else {
                return false;
            }
        }
        return t.flag == 1 ? true : false;
    }
    
    public boolean startsWith(String prefix) {
        Trie t = this;
        int len = prefix.length();
        for(int i = 0 ; i < len ; i ++){
            char c = prefix.charAt(i);
            if(t.hashMap.containsKey(c)){
                t = t.hashMap.get(c); 
            } else {
                return false;
            }
        }
        return true;
    }
}

/**
 * Your Trie object will be instantiated and called as such:
 * Trie obj = new Trie();
 * obj.insert(word);
 * boolean param_2 = obj.search(word);
 * boolean param_3 = obj.startsWith(prefix);
 */
```

# å›æº¯

## å…¨æ’åº

ğŸ§© é—®é¢˜ï¼š`res.add(num)` åŠ è¿›å»çš„å€¼ä¼šè·Ÿç€å˜åŒ–

è¿™æ®µä»£ç ï¼š

```
if (num.size() == nums.length) {
    res.add(num);
    return;
}
```

è¿™é‡Œ `num` æ˜¯ä¸€ä¸ª **å¼•ç”¨ï¼ˆå¼•ç”¨ä¼ é€’ï¼‰**ï¼Œ
 å½“ä½ åé¢ç»§ç»­ä¿®æ”¹ `num`ï¼ˆæ¯”å¦‚ `num.add()` æˆ– `num.remove()`ï¼‰æ—¶ï¼Œ
 `res` é‡Œä¿å­˜çš„é‚£ä¸ªå¼•ç”¨æŒ‡å‘çš„åŒä¸€ä¸ª `List` å¯¹è±¡ï¼Œä¹Ÿä¼šè¢«ä¸€èµ·æ”¹åŠ¨ã€‚

å› æ­¤åœ¨ç»“æœé‡Œé¢åŠ å…¥æ—¶åº”è¯¥ä½¿ç”¨æ„é€ å‡½æ•°è¿›è¡Œæ‹·è´ã€‚

```java
class Solution {
    List<List<Integer>> res;

    public List<List<Integer>> permute(int[] nums) {
        res = new ArrayList<>();
        dfs(new ArrayList<>(), nums);
        return res;
    }

    public void dfs(List<Integer> path, int[] nums) {
        if (path.size() == nums.length) {
            res.add(new ArrayList<>(path)); // âœ… ä¸€å®šè¦å¤åˆ¶
            return;
        }

        for (int i = 0; i < nums.length; i++) {
            if (!path.contains(nums[i])) {
                path.add(nums[i]);
                dfs(path, nums);
                path.remove(path.size() - 1);
            }
        }
    }
}

```

## å…«çš‡å





# äºŒåˆ†æŸ¥æ‰¾

## æœç´¢äºŒç»´çŸ©é˜µ

ä»å·¦ä¸‹è§’æˆ–è€…å³ä¸Šè§’å¼€å§‹æœç´¢ï¼Œè¿™æ ·æ¯ä¸ªæ–¹å‘éƒ½æ˜¯å•è°ƒçš„

```
 class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int m = matrix.length;
        int n = matrix[0].length;
        int i = m -1;
        int j = 0;
        while( i >= 0 && j <= n-1){
            int cur = matrix[i][j];
            if(cur == target){
                return true;
            }
            else if(cur > target){
                i --;
            } else {
                j ++;
            }
        }
        return false;
    }
}
```

## æœç´¢æ’å…¥ä½ç½®

æ‰¾åˆ°ç¬¬ä¸€ä¸ªå¤§äºç­‰äºç›®æ ‡å…ƒç´ çš„ä¸‹æ ‡

```z
int firstGreater(int[] nums, int target) {
    int left = 0, right = nums.length; // [left, right)
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] > target) right = mid;
        else left = mid + 1;
    }
    return left;
}

```

æ‰¾åˆ°ç¬¬ä¸€ä¸ªå°äºç­‰äºç›®æ ‡å…ƒç´ çš„ä¸‹æ ‡

```java
int firstGreater(int[] nums, int target) {
    int left = 0, right = nums.length; // [left, right)
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) left = mid;
        else right = mid - 1;
    }
    return left;
}

```


> ä¸¤ç§äºŒåˆ†æŸ¥æ‰¾å†™æ³•çš„æ ¸å¿ƒåŒºåˆ«

| å†™æ³•                                 | åŒºé—´å«ä¹‰                         | å¾ªç¯æ¡ä»¶        | mid æ›´æ–°é€»è¾‘                                                 | å¸¸è§è¿”å›å€¼                             | å¸¸ç”¨äº                     |
| ------------------------------------ | -------------------------------- | --------------- | ------------------------------------------------------------ | -------------------------------------- | -------------------------- |
| âœ… **å†™æ³•1**ï¼š`while (left < right)`  | **å·¦é—­å³å¼€åŒºé—´ `[left, right)`** | `left < right`  | `mid = left + (right - left) / 2` å¦‚æœæ¡ä»¶ä¸æ»¡è¶³åˆ™ `right = mid` | æœ€åè¿”å› `left`                        | æŸ¥æ‰¾â€œç¬¬ä¸€ä¸ªæ»¡è¶³æ¡ä»¶çš„ä½ç½®â€ |
| âœ… **å†™æ³•2**ï¼š`while (left <= right)` | **å·¦å³éƒ½é—­åŒºé—´ `[left, right]`** | `left <= right` | `mid = left + (right - left) / 2` å¦‚æœæ¡ä»¶ä¸æ»¡è¶³åˆ™ `right = mid - 1` | æœ€åè¿”å› `left` æˆ– `right`ï¼Œå–å†³äºé€»è¾‘ | æŸ¥æ‰¾â€œæ˜¯å¦å­˜åœ¨æŸä¸ªå€¼â€       |

## åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾å…ƒç´ çš„ç¬¬ä¸€ä¸ªä½ç½®å’Œæœ€åä¸€ä¸ªä½ç½®

äºŒåˆ†æœç´¢æ¿é¢˜

```
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int i = 0;
        int j = nums.length-1;
        while(i <= j){
            int mid = i + (j - i)/2;
            if(nums[mid] == target){
                int start = mid;
                int end = mid;
                while(start-1 >=0 && nums[start-1] == target) start --;
                while(end+1<=nums.length-1 && nums[end+1] == target) end++;
                return new int[]{start,end};
            }else if(nums[mid] < target){
                i = mid +1;
            } else{
                j = mid - 1;
            }
        }
        return new int[]{-1,-1};
    }
}
```



# æ ˆ



## æœ‰æ•ˆçš„æ‹¬å·

ç»´æŠ¤ä¸€ä¸ªç¬¦å·æ ˆ

```java
class Solution {
    public boolean isValid(String s) {
        //ç»´æŠ¤ä¸€ä¸ªæ ˆ
        Deque<Character> stack = new ArrayDeque<>();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            switch (c) {
                case '(':
                    stack.addLast(c);
                    break;
                case ')':
                    if (stack.isEmpty() ||stack.peekLast() != '(')
                        return false;
                    stack.removeLast();
                    break;
                case '[':
                    stack.addLast(c);
                    break;
                case ']':
                    if (stack.isEmpty() || stack.peekLast() != '[')
                        return false;
                    stack.removeLast();
                    break;
                case '{':
                    stack.addLast(c);
                    break;
                case '}':
                    if (stack.isEmpty() || stack.peekLast() != '{')
                        return false;
                    stack.removeLast();
                    break;
                default:
                    return false;
            }
            ;

        }
        if (stack.isEmpty()) {
            return true;
        }
        return false;
    }
}
```



## æœ€å°æ ˆ

åœ¨æ¯ä¸ªèŠ‚ç‚¹å…¥æ ˆæ—¶ï¼Œç»´æŠ¤å½“å‰å…¥æ ˆæ—¶çš„æœ€å°å€¼

```java
class MinStack {
Stack<int[]> s1;

    public MinStack() {
        s1 = new Stack<>();
    }
    
    public void push(int val) {
        if(!s1.isEmpty()){
            int[] t = s1.peek();
            if(val < t[1]){
                s1.push(new int[]{val,val});
            } else {
                s1.push(new int[]{val,t[1]});
            }
        } else {
            s1.push(new int[]{val,val});
        }
    }
    
    public void pop() {
        int[] t = s1.pop();
    }
    
    public int top() {
        int[] t = s1.peek();
        return t[0];
    }
    
    public int getMin() {
        int[] t = s1.peek();
        return t[1];
    }
}

```

## æ¯æ—¥æ¸©åº¦

è¿˜æ˜¯ç»´æŠ¤ä¸€ä¸ªå•è°ƒæ ˆï¼Œæ ˆé‡Œé¢çš„pairå¯¹åˆ†åˆ«ä¸ºindexå’Œnums[index]

```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        //ç»´æŠ¤ä¸€ä¸ªå•è°ƒé€’å‡çš„æ ˆ
        Stack<int[]> s = new Stack<>();
        int[] res = new int[temperatures.length];
        for(int i = 0 ;  i< temperatures.length;i++){
            int[] x  = new int[]{temperatures[i], i};
            if(s.isEmpty()){
                s.push(x);
            } else {
                while(!s.isEmpty() && s.peek()[0] < x[0]){
                    int[] t = s.pop();
                    res[t[1]] = i - t[1];
                }
                s.push(x);
            }
        }
        for(int i=0;i<s.size();i++){
            int[] t = s.pop();
            res[t[1]] = 0;
        }
        
        return res;
    }
}
```



## æŸ±çŠ¶å›¾ä¸­çš„æœ€å¤§çŸ©å½¢

ç»´æŠ¤ä¸¤ä¸ªå•è°ƒæ ˆ

```java
class Solution {
        public int largestRectangleArea(int[] heights) {
        //æ‰¾åˆ°æ¯ä¸ªä½ç½®[i]ä¸¤ä¾§ï¼Œç¬¬ä¸€ä¸ªå°äºheights[i]çš„å…ƒç´ ä½ç½®ã€‚ä¸¤ä¾§ç»´æŠ¤å•è°ƒé€’å¢çš„æ ˆã€‚
        //dpæ•°ç»„ç»´æŠ¤[i]åˆ°ä¸¤ä¾§çš„é•¿åº¦
        Stack<int[]> s_l = new Stack<>();
        Stack<int[]> s_r = new Stack<>();
        int n = heights.length;
        int[] r = new int[n];
        int[] l = new int[n];
        for(int i=0; i < n ;i++){
            int j = n - 1 - i;
            int[] x = new int[]{heights[i], i};
            int[] y = new int[]{heights[j], j};
            if(s_r.isEmpty()){
                s_r.push(x);
            } else {
                while(!s_r.isEmpty() && s_r.peek()[0] > x[0]){
                    int[] t = s_r.pop();
                    r[t[1]] = i - t[1];
                }
                s_r.push(x);
            }

            if(s_l.isEmpty()){
                s_l.push(y);
            } else {
                while(!s_l.isEmpty() && s_l.peek()[0] > y[0]){
                    int[] t = s_l.pop();
                    l[t[1]] = t[1] - j ;
                }
                s_l.push(y);
            }
        }
        int s_r_size = s_r.size();
        for(int i = 0 ; i < s_r_size;i++){
            int[] t = s_r.pop();
            r[t[1]] = n  - t[1];
        }
        int s_list_size = s_l.size();
        for(int j = 0 ; j < s_list_size;j++){
            int[] t = s_l.pop();
            l[t[1]] = t[1] + 1;
        }

        int res = Integer.MIN_VALUE;
        for(int k = 0 ; k < n ; k ++){
            if(r[k] == 1 || r[k] == 0){
                r[k] = 0;

            } else {
                r[k] --;
            }
            if(l[k] == 1 || l[k] == 0){
                l[k] = 0;

            } else {
                l[k] --;
            }

        }
        for(int k = 0 ; k < n ; k ++){
            res = Math.max(res, heights[k] * (r[k] + l[k] +1 ));
        }

        return res;

    }
}
```



# è´ªå¿ƒç®—æ³•

## ä¹°å–è‚¡ç¥¨çš„æœ€ä½³æ—¶æœº

1. ä¹°ä¸€æ¬¡å–ä¸€æ¬¡
2. å–çš„æ—¶é—´>ä¹°çš„æ—¶é—´

è§£æ³•ï¼šç»´æŠ¤ä¸€ä¸ªä»0åˆ°içš„æœ€å°å€¼çš„dpæ•°ç»„

```java
class Solution {
    public int maxProfit(int[] prices) {
        //ç»´æŠ¤ä¸€ä¸ªä»0åˆ°içš„æœ€å°å€¼çš„dp
        int n = prices.length;
        if(n==0)
        return 0;
        int[] dp = new int[n]; 
        dp[0] = prices[0];
        int res = Integer.MIN_VALUE;
        for(int i = 1 ; i < n ; i ++){
            dp[i] = Math.min(prices[i] , dp[i-1]);
            res = Math.max(res, prices[i] - dp[i]);
        }
        return res < 0 ? 0 : res;
    }
}
```

## è·³è·ƒæ¸¸æˆ

ç”¨dp[i]ç»´æŠ¤i+nums[i]çš„åœ°ç‚¹æ˜¯å¦å¯è¾¾

```java
class Solution {
    public boolean canJump(int[] nums) {
        //dpçš„å«ä¹‰ä¸ºç»´æŠ¤ä¸€ä¸ªiæ‰€åœ¨çš„åœ°ç‚¹æ˜¯å¦å¯è¾¾
        int[] dp = new int[nums.length];
        dp[0] = 1;
        for(int i = 0 ; i < nums.length;i++){
            if(dp[i] == 0) return false;
            int step=i+nums[i];
            for(int j = i ; j <= step; j ++){
                if(j<nums.length)
                    dp[j] =1;
            }
        }
        return true;
         
    }
}
```



## è·³è·ƒæ¸¸æˆII

å’Œè·³è·ƒæ¸¸æˆIç±»ä¼¼ï¼Œdp[i]è¦ç»´æŠ¤åˆ°iè¿™ä¸ªåœ°ç‚¹æ‰€æœ‰çš„æ­¥æ•°çš„æœ€å°å€¼

```java
class Solution {
    public int jump(int[] nums) {
        //dp[i]ç»´æŠ¤åˆ°iæ‰€ç”¨çš„æ­¥æ•°
        int n = nums.length;
        int[] dp = new int[n];
        Arrays.fill(dp,Integer.MAX_VALUE);
        dp[0] = 0;
        for(int i = 0; i < n; i ++){
            int step = i + nums[i];
            for(int j = i ; j <= step ; j++){
                if(j < n){
                    dp[j] = Math.min(dp[j],dp[i]+1); 
                }
            }
            
        }
        return dp[n-1];
    }
}
```

## åˆ’åˆ†å­—æ¯åŒºé—´

1. é¢˜ç›®çš„æ„æ€æ˜¯ä¸€ä¸ªå­—æ¯åªèƒ½åœ¨ä¸€ä¸ªåŒºé—´å†…å‡ºç°
2. è¿™å®é™…ä¸Šå°±æ˜¯åŒºé—´åˆå¹¶

```java
class Solution {
    public List<Integer> partitionLabels(String s) {
        //1.è·å¾—æ¯ä¸ªå­—ç¬¦çš„å·¦å³è¾¹ç•Œ
        HashMap<Character,int[]> hashMap = new HashMap<>();
        int n = s.length();
        for(int i = 0 ; i < n ; i ++){
            char c = s.charAt(i);
            if(hashMap.containsKey(c)){
                int[] seg = hashMap.get(c);
                seg[1] = i;
                hashMap.put(c,seg);
            } else {
                int[] seg = new int[]{i,i};
                hashMap.put(c,seg);
            }
        }
        int m = hashMap.size();
        int[][] in = new int[m][];
        int p = 0;
        for(Map.Entry<Character,int[]> e : hashMap.entrySet()){
            char e1 = e.getKey();
            int[] e2 = e.getValue();
            in[p] = e2;
            p++;
        }

        //2.å°†æ‰€æœ‰åŒºé—´åˆå¹¶,é¦–å…ˆå°†æ‰€æœ‰åŒºé—´æŒ‰ç…§å·¦ç•Œç”±å°åˆ°å¤§æ’åºã€
        Arrays.sort(in, (a,b) -> Integer.compare(a[0],b[0]));
        List<Integer> res = new ArrayList<>();
        int curLeft = in[0][0];
        int curRight = in[0][1];
        for(int i = 1 ; i < m ; i ++){
            //å¯ä»¥åˆå¹¶
            if(curRight >= in[i][0]){
                curRight = Math.max(curRight,in[i][1]);
            } else { //ä¸èƒ½åˆå¹¶
                int len = curRight - curLeft + 1;
                res.add(len);
                curLeft = in[i][0];
                curRight = in[i][1];
            }
        }
        res.add(curRight-curLeft + 1);


        return res;
    }
}
```



# åŠ¨æ€è§„åˆ’

## çˆ¬æ¥¼æ¢¯

å®é™…ä¸Šæ˜¯æ–æ³¢é‚£å¥‘æ•°åˆ—

```java
class Solution {
    public int climbStairs(int n) {
        if( n <= 2) return n;
        int[] dp = new int[n+1];
        dp[1] = 1;
        dp[2] = 2;
        for(int i = 3 ; i <= n ; i ++){
            dp[i] = dp[i-1] + dp[i - 2];
        }
        return dp[n];
    }
}
```

## æ¨è¾‰ä¸‰è§’

```java
class Solution {
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> res = new ArrayList<>();
            List<Integer> t0 = new ArrayList<>();
            t0.add(1);
            res.add(t0);
        if(numRows == 1){
            return res;
        }
            List<Integer> t1 = new ArrayList<>();
            t1.add(1);
            t1.add(1);
            res.add(t1);
        if(numRows == 2){
            return res;
        }
        
        for(int i = 2 ; i < numRows ; i ++){
            List<Integer> t = new ArrayList<>();
            t.add(1);
            for(int j = 1 ; j < i ; j ++){
                t.add(res.get(i-1).get(j-1) + res.get(i-1).get(j));
            }
            t.add(1);
            res.add(t);
        }
        return res;   
    }
}
```

## å®Œå…¨å¹³æ–¹æ•°ä¹‹å’Œ

è¿™æ˜¯ä¸€ä¸ªå®Œå…¨èƒŒåŒ…é—®é¢˜ï¼Œé€’æ¨å…¬å¼ä¸º
$$
dp[i] = 1 + min_{j}^{\sqrt{i}} dp[i-j^2]
$$

```
class Solution {
    public int numSquares(int n) {
        int[] dp = new int[n + 1];
        dp[1] = 1;
        for(int i = 1 ; i < n + 1; i ++ ){
            int minn = Integer.MAX_VALUE;
            for(int j = 1 ; j*j<=i;j++){
                minn = Math.min(minn, dp[i - j * j]);
            }
            dp[i] = minn + 1;
        }
        return dp[n];
    }
}
```







## é›¶é’±å…‘æ¢

å’Œå®Œå…¨å¹³æ–¹æ•°ä¹‹å’Œç±»ä¼¼ï¼Œæ˜¯ä¸€ä¸ªå®Œå…¨èƒŒåŒ…é—®é¢˜ï¼Œé€’æ¨å…¬å¼ä¸ºï¼š
$$
dp[i] = 1 + min_{j \in coins} dp[i-j]
$$

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
        for (int i = 1; i <= amount; i++) {
            int minn = Integer.MAX_VALUE;
            for (int j = 0; j < coins.length; j++) {
                if (i - coins[j] >= 0)
                    minn = Math.min(minn, dp[i - coins[j]]);
            }
            if (minn != Integer.MAX_VALUE)
                dp[i] = minn +1;
                 else dp[i] = Integer.MAX_VALUE;
        }
        return dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount];
    }
}
```



## æ‹†åˆ†å•è¯

ä¾ç„¶æ˜¯ä¸€ä¸ªå®Œå…¨èƒŒåŒ…é—®é¢˜ï¼Œè®°å½•ä¸€ä¸‹ï¼Œé€’æ¨å…¬å¼ï¼š

ä½†æ˜¯éœ€è¦é¢å¤–å¤„ç†ä¸€ä¸‹ï¼Œdp[i]åº”è¯¥ä¸ºæˆ–çš„å…³ç³»ï¼Œå³åªè¦å‡ºç°æ»¡è¶³çš„å•è¯å‰ç¼€å³å¯ã€‚
$$
dp[i] = dp[i] \ || \ dp[i-t.length()]
$$

```java
class Solution {
   public boolean wordBreak(String s, List<String> wordDict) {
        //è¿˜æ˜¯èƒŒåŒ…é—®é¢˜
        //åˆ†æ®µå»æˆªå–
        boolean dp[] = new boolean[s.length()+1];
        dp[0] = true;
        for(int j = 1 ; j <= s.length(); j++){
            for(int k = 0 ; k < wordDict.size(); k ++){
                String t = wordDict.get(k);
                if( j - t.length() < 0 )
                    continue;
                if(s.substring( j - t.length(), j).equals(t) && dp[j - t.length()]){

                    dp[j] = dp[j - t.length()];
                }
            }
        }
        return dp[s.length()];

    }
}
```

## æœ€é•¿é€’å¢å­åºåˆ—

è§£æ³•ä¸€ï¼šç»´æŠ¤ä¸€ä¸ªæ™®é€šçš„åŠ¨æ€è§„åˆ’

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int n = nums.length;
        int res = 1;
        int[] dp = new int[n+1];
        dp[0] = 1;
        for(int i = 1; i <n ; i ++){
            int t = 0;
            for(int j = i - 1 ; j>= 0 ; j --){
                if(nums[j] < nums[i]){
                    t = Math.max(t, dp[j]);
                }
            }

            dp[i] = t + 1;
            res = Math.max(res, dp[i]);
        }
        return res;
    }
}
```



è§£æ³•äºŒï¼š

äºŒåˆ†æŸ¥æ‰¾+è´ªå¿ƒ

ç»´æŠ¤ä¸€ä¸ªè¾…åŠ©æ•°ç»„ pï¼Œå®ƒçš„æ¯ä¸€é¡¹ p[i] çš„å«ä¹‰æ˜¯ï¼Œæ‰€æœ‰é•¿åº¦ä¸º i+1 çš„ä¸Šå‡å­åºåˆ—çš„æœ«å°¾å…ƒç´ ä¸­çš„æœ€å°å€¼

å‚è€ƒ: https://writings.sh/post/longest-increasing-subsequence-revisited



## æœ€å¤§ä¹˜ç§¯å­æ•°ç»„

è€ƒè™‘åˆ°è´Ÿæ•°çš„å­˜åœ¨ï¼Œç»´æŠ¤ä¸€ä¸ªæœ€å¤§å€¼å’Œä¸€ä¸ªæœ€å°å€¼ï¼ˆæœ€å°å€¼åœ¨ä¹˜ä¸Šè´Ÿæ•°æ—¶åè€Œå˜æˆæœ€å¤§å€¼ï¼‰

```java
class Solution {
    public int maxProduct(int[] nums) {
        //ç»´æŠ¤ä¸€ä¸ªæœ€å¤§å€¼å’Œæœ€å°å€¼
        int n = nums.length;
        int[] dp_max = new int[n+1];
        int[] dp_min = new int[n+1];
        dp_max[0] = nums[0];
        dp_min[0] = nums[0];
        int res = nums[0];
        for(int i = 1 ; i < n ; i ++){

            if(nums[i] < 0){
                dp_max[i] = dp_min[i - 1] * nums[i];
                dp_min[i] = dp_max[i - 1] * nums[i]; 
            } else if(nums[i] > 0) {
                dp_max[i] = dp_max[i - 1] * nums[i];
                dp_min[i] = dp_min[i - 1] * nums[i];
            } else {
                dp_max[i] = nums[i];
                dp_min[i] = nums[i];
            }
            dp_max[i] = Math.max(dp_max[i], nums[i]);
            dp_min[i] = Math.min(dp_min[i], nums[i]);
            res = Math.max(dp_max[i],res);
        }
        return res;
    }
}
```





## åˆ†å‰²ç­‰å’Œå­é›†

**01 èƒŒåŒ…é—®é¢˜çš„â€œå¯è¾¾æ€§ç‰ˆæœ¬â€**ï¼š

```java
public boolean canPartition(int[] nums) {
        int n = nums.length;

        int sum = 0;
        for(int i = 0 ; i < n ; i ++){
            sum += nums[i];

        }
        if(sum % 2 == 1) return false;
        int[] dp = new int[sum];
        dp[0] = 1;

        int halfSum = sum / 2;
        for(int i = 0 ; i < nums.length ; i ++){
            for(int j = halfSum; j >= nums[i] ; j --){
                dp[j] = Math.max(dp[j],dp[j-nums[i]]);
            }
        }
        return dp[halfSum] == 1 ? true : false;
    }
```



## æœ€é•¿æœ‰æ•ˆæ‹¬å·

1. é¦–å…ˆåˆ¤æ–­å½“å‰ä½æ˜¯å¦èƒ½ç»„æˆæ‹¬å·ï¼Œæ˜¯ä¸º1ï¼Œå¦ä¸º0
2. è½¬ä¸ºåˆ¤æ–­æœ€é•¿è¿ç»­1çš„é—®é¢˜

```java
class Node{
    char c;
    int index;
    public Node(char c, int index){
        this.c = c;
        this.index = index;
    }
    char getC(){
        return this.c;
    }
    int getIndex(){
        return this.index;
    }
}
class Solution {
    public int longestValidParentheses(String s) {
        //
        int n = s.length();
        if(s.length() == 0) return 0;
        int[] num = new int[n];
        Stack<Node> stack = new Stack<>();
        for(int i = 0 ; i  <  s.length();i++){
            char c = s.charAt(i);
            switch(c){
                case '(' :
                    Node t = new Node(c,i);
                    stack.push(t);
                    break;
                case ')' :
                    if(!stack.isEmpty() && stack.peek().getC() == '('){
                        Node t1 = stack.pop();
                        num[i] = 1;
                        num[t1.getIndex()] = 1;
                    }
                    break;
                default:
                return 0;
            }
        }
        //è·å¾—äº†ä¸€ä¸ª0ä¸ºä¸åŒ¹é…ï¼Œ1ä¸ºåŒ¹é…çš„num[]ï¼Œç°åœ¨è¦æ±‚æœ€é•¿çš„è¿ç»­1çš„åºåˆ—
        int res = 0;
        int temp = 0;
        for(int i = 0 ; i < n ; i ++){
            if(num[i] == 1){
                temp ++;
            } else{
                
                temp = 0;
            }
            res = Math.max(res,temp);

        }
        return res;
    }
}
```



# å¤šç»´åŠ¨æ€è§„åˆ’

## ä¸åŒè·¯å¾„

ç»´æŠ¤ä¸€ä¸ªäºŒç»´dpæ•°ç»„ï¼Œä»£è¡¨åˆ°è¯¥ç‚¹æ—¶çš„è·¯å¾„æ•°é‡

```java
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        dp[0][0] = 0;
        for(int i = 0 ; i < n ; i++){
            dp[0][i] = 1;

        }
        for(int i = 0 ; i < m ; i ++){
            dp[i][0] = 1;
        }
        for(int i = 1 ; i < m; i ++){
            for(int j = 1 ; j < n ; j ++){
                dp[i][j] = dp[i - 1][j] + dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
}
```



## æœ€å°è·¯å¾„å’Œ

ç»´æŠ¤ä¸€ä¸ªäºŒç»´dpæ•°ç»„ä»£è¡¨åˆ°i,jçš„æœ€å°è·¯å¾„

```java
class Solution {
    public int minPathSum(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        int[][] dp = new int[m][n];
        dp[0][0] = grid[0][0];
        for(int i = 1 ; i < m ; i ++){
            dp[i][0] = dp[i-1][0]+ grid[i][0];

        }
        for(int j = 1 ; j < n ; j ++){
            dp[0][j]  = dp[0][j-1] + grid[0][j];
        }
        for(int i = 1; i < m ; i ++){
            for(int  j = 1; j < n ; j ++){
                dp[i][j] = Math.min(dp[i-1][j],dp[i][j-1]) + grid[i][j];
            }
        }
        return dp[m-1][n-1];
    }
}
```

## æœ€é•¿å…¬å…±å­åºåˆ—

```java
public int longestCommonSubsequence(String text1, String text2) {
        int m = text1.length();
        int n = text2.length();
        
        // dp[i][j] è¡¨ç¤º text1[0..i-1] å’Œ text2[0..j-1] çš„ LCS é•¿åº¦
        int[][] dp = new int[m + 1][n + 1];  // ä½¿ç”¨ (m+1) x (n+1) çš„ DP è¡¨ï¼Œé¿å…è¾¹ç•Œåˆ¤æ–­
        
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        
        return dp[m][n];
    }
```

## ç¼–è¾‘è·ç¦»

dpç»´æŠ¤ä¸ºdpä»£è¡¨å‰nå’Œå‰mè½¬æ¢éœ€è¦çš„æœ€å°æ¬¡æ•°ï¼Œä½¿ç”¨i+1å’Œj+1æ¥å¤„ç†è¾¹ç•Œæ¡ä»¶

è€ƒè™‘åˆ°dpå¯ä»¥ä»ä¸‰ä¸ªæ–¹å‘è·å¾—ï¼Œåˆ†åˆ«ä¸ºå·¦ä¸Šè§’ï¼Œä¸Šæ–¹ï¼Œå·¦æ–¹

````java
class Solution {
    public int minDistance(String word1, String word2) {
        int m = word1.length();
        int n = word2.length();
        //dpä»£è¡¨å‰nå’Œå‰mè½¬æ¢éœ€è¦çš„æœ€å°æ¬¡æ•°
        int[][] dp = new int[m+1][n+1];
        for(int i = 0 ; i <= m;i++){
            dp[i][0] = i;
        }
        for(int i = 0 ; i <=n ; i ++){
            dp[0][i] = i;
        }
        
        for(int i = 1 ; i <= m ; i ++){
            for(int j = 1; j <= n ; j ++){
                char c1 = word1.charAt(i-1);
                char c2 = word2.charAt(j-1);
                if(c1 == c2){
                    dp[i][j] = dp[i-1][j-1];
                } else {
                    dp[i][j] =Math.min(dp[i-1][j-1] + 1 , Math.min(dp[i][j-1] + 1 , dp[i-1][j] + 1)) ;
                }
            }
        }
        return dp[m][n];
    }
}
````





# æŠ€å·§

## åªå‡ºç°ä¸€æ¬¡çš„æ•°å­—ï¼Œå…¶ä»–æ•°å­—

ä½¿ç”¨å¼‚æˆ–æ“ä½œï¼Œå¼‚æˆ–æ“ä½œçš„ç‰¹æ€§ï¼š

1. a ^ a = 0
2. a ^ 0 = a

3. å¼‚æˆ–å…·æœ‰äº¤æ¢å¾‹

```java
class Solution {
    public int climbStairs(int n) {
        if( n <= 2) return n;
        int[] dp = new int[n+1];
        dp[1] = 1;
        dp[2] = 2;
        for(int i = 3 ; i <= n ; i ++){
            dp[i] = dp[i-1] + dp[i - 2];
        }
        return dp[n];
    }
}
```

## å¤šæ•°å…ƒç´ 

å¤šæ•°å…ƒç´ æ˜¯æŒ‡åœ¨æ•°ç»„ä¸­å‡ºç°æ¬¡æ•° **å¤§äº** `âŒŠ n/2 âŒ‹` çš„å…ƒç´ ã€‚

é‡‡ç”¨æŠ•ç¥¨æ³•ï¼Œæ„å‘³ç€åœ¨å…ƒç´ æŠµæ¶ˆçš„è¿‡ç¨‹ä¸­ï¼Œå¤šæ•°å…ƒç´ å¿…å®šä¼šç•™ä¸‹ã€‚

```java
class Solution {
    public int majorityElement(int[] nums) {
        int cur = nums[0];
        int cnt = 1;
        for(int i = 1 ; i < nums.length;i++){
            if(cnt == 0){
                cur = nums[i];
                cnt ++;
                continue;
            }
            if(nums[i] == cur){
                cnt ++ ;
            } else {
                cnt -- ;

            }
        }
        return cur;
    }
}
```

