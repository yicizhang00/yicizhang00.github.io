---
title: Hot100
date: 2025-08-12 01:57:43
categories:
  - leetcode
tags:
  - leetcode
---

# 链表

## 相交链表

遍历两次判断交点

```java
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode a = headA;
        ListNode b = headB;
        while( a!=b){
            a=a!= null?a.next:headA;
            b=b!=null?b.next:headB;
        }
        return a;
    }
```





# 矩阵

## 旋转图像

转置后进行轴对称



# 树

## 二叉树中序遍历

中序遍历一下，按照

dfs(root.left)

print(root)

dfs(root.right)

```java
    public static void dfs(TreeNode root){
        if(root==null)
        return;
        dfs(root.left);
        res.add(root.val);
        dfs(root.right);

    }
```



## 二叉树的最大深度

递归查找每一层节点的深度

```java
    public int maxDepth(TreeNode root) {
        return dfs(root);
    }
    static int dfs(TreeNode root){
        if(root == null)
        return 0;
        return Math.max(dfs(root.left),dfs(root.right)) + 1;
    }
```

## 对称二叉树

递归交换检查每层的左右节点是否对称

```java
    public static boolean dfs(TreeNode left, TreeNode right){
        if(left == null && right == null) 
        return true;
        if(left == null && right != null)
        return false;
        if(right == null && left != null)
        return false;
        if(left.val == right.val && dfs(left.left,right.right) && dfs(left.right,right.left) )
        return true;
        return false;
    }
```



## 翻转二叉树

使用递归交换每一层的左右子节点

```
    public static void dfs(TreeNode node){
        if(node == null) return;
        TreeNode t = new TreeNode();
        t = node.left;
        node.left = node.right;
        node.right = t;
        dfs(node.left);
        dfs(node.right);
    }
```



## 二叉树的直径

题目：给你一棵二叉树的根节点，返回该树的 **直径** 。

二叉树的 **直径** 是指树中任意两个节点之间最长路径的 **长度** 。这条路径可能经过也可能不经过根节点 `root` 。

两节点之间路径的 **长度** 由它们之间边数表示。

思路：递归搜索每个节点的左右子树路径和，在主函数使用一个全局变量维护该最大值。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    
    static int ans = 0;
    public int diameterOfBinaryTree(TreeNode root) {
        if(root == null) 
        return 0;
        ans = 1;
        dep(root);
        return ans-1;

    }
    public static int dep(TreeNode node){
        if(node == null) return 0;
        int l = dep(node.left);
        int r = dep(node.right);
        ans = Math.max(ans, l+r+1);
        return Math.max(l,r)+1;
    }
}
```

> 注：二叉树的直径不同于图的直径，图的直径可以通过两次遍历先找到一端的直径端点，然后再找到另一端的直径端点实现，模板如下
>
> ```java
> public static int treeDiameter(int n, List<List<Integer>> adj) {
>         if (n == 0) return 0;
>         // 从任意节点 0 开始 BFS 找最远点
>         int far = bfsFarthest(0, n, adj)[0];
>         // 从 far 再次 BFS，得到最远距离
>         int[] res = bfsFarthest(far, n, adj);
>         return res[1]; // distance
>     }
> 
>     // 返回长度为2的数组: [farthestNode, distance]
>     private static int[] bfsFarthest(int src, int n, List<List<Integer>> adj) {
>         int[] dist = new int[n];
>         Arrays.fill(dist, -1);
>         Queue<Integer> q = new ArrayDeque<>();
>         q.add(src);
>         dist[src] = 0;
>         int farNode = src;
>         while (!q.isEmpty()) {
>             int u = q.poll();
>             for (int v : adj.get(u)) {
>                 if (dist[v] == -1) {
>                     dist[v] = dist[u] + 1;
>                     q.add(v);
>                     if (dist[v] > dist[farNode]) farNode = v;
>                 }
>             }
>         }
>         return new int[]{farNode, dist[farNode]};
>     }
> ```
>
> 

## 二叉树层序遍历

使用一个Queue维护二叉树的每层节点。for循环统计当前层节点数量。

```java
public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res= new ArrayList<>();
        if(root==null){
            return res;
        }
        Deque<TreeNode> d = new ArrayDeque<>();
        d.addLast(root);
        while(!d.isEmpty()){
            int size = d.size();
            List<Integer> t = new ArrayList<>();
            for(int i=0;i<size;i++){
                TreeNode n=d.removeFirst();
                t.add(n.val);
                if(n.left!=null) d.addLast(n.left);
                if(n.right!=null) d.addLast(n.right);
            }
            res.add(t);
        }
        return res;
    }
```

## 数组转化为平衡二叉搜索树

BST递归后序遍历建立树，核心公式：int mid = (l + r) / 2 选中之后再建树，记住就好。

注意二分法的递归范围为

```java
if (left > right) return null;
TreeNode l = dfs(nums, left, mid - 1);
TreeNode r = dfs(nums, mid + 1, right);
```

```java
public TreeNode sortedArrayToBST(int[] nums) {
        return dfs(nums,0,nums.length-1);
    }
    public static TreeNode dfs(int[] nums, int left, int right){
        if(left > right)
        return null;
        int mid = (left + right) / 2;
        TreeNode t = new TreeNode(nums[mid]);
        TreeNode l = dfs(nums,left,mid-1);
        TreeNode r = dfs(nums,mid+1,right);
        t.left = l;
        t.right = r;
        return t;
    }
```



## 验证二叉搜索树

递归查询每个节点是否大于其左子树的最大值，并且小于其右子树的最小值。额外创建两个递归查询左子树的最大值和右子树的最小值。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isValidBST(TreeNode root) {
        return dfs(root);
    }
    static boolean dfs(TreeNode root){
        if(root == null)
        return true;
        int mid = root.val;
        long l = root.left==null? Long.MIN_VALUE: (long)dfs_r(root.left);
        long r = root.right==null? Long.MAX_VALUE: (long)dfs_l(root.right);
        return mid > l && mid < r && dfs(root.left) && dfs(root.right);
    }
    static int dfs_l(TreeNode root){
        if(root.left != null)
            return dfs_l(root.left);
        else 
            return root.val; 
    }
    static int dfs_r(TreeNode root){
        if(root.right!=null){
            return dfs_r(root.right);
        }else{
            return root.val;
        }
    }
}
```



## 二叉搜索树中第K小的元素

其实就是中序遍历到的第k个元素，维护一个全局变量统计一下当前统计到的元素个数。

```java
    static int cnt;
    static int res;
    public int kthSmallest(TreeNode root, int k) {
        cnt = 0;
        dfs(root,k);
        return res;
    }
    static void dfs(TreeNode root, int k){
        if(root == null){
            return; 
        }
        dfs(root.left, k);
        cnt ++;
        if(cnt == k){
            res=root.val;
            return;
        }
        dfs(root.right, k);
    }
```

## 二叉树的右视图

对于同一深度的节点来说，如果右子树存在的话就只能看见右子树，所以我们要从右->左进行遍历，维护一个数组，统计深度为i的层是否已经有节点在右视图中。从顶部到底部访问，可以改为[根->右->左]

注意：其中[右->左]的顺序可以不变,改变[根]的位置可以实现从顶部到底部，但不能从底部到顶部，考虑这一种情况，如果有一个左子树很大，但是右子树很小的二叉树，在[右->左]的递归顺序下，也会优先存储右子树深度较浅的值。

```java
static int[] a;
    static List<Integer> res;
    public List<Integer> rightSideView(TreeNode root) {
        a = new int[100];
        res = new ArrayList<>();
        dfs(root,0);
        return res;
    }
    static void dfs(TreeNode root, int depth){
        if(root == null)
        return;
        if(a[depth] == 0){
            res.add(root.val);
            a[depth] = 1;
        }
        dfs(root.right,depth + 1);
        dfs(root.left,depth + 1);

    }   
```

