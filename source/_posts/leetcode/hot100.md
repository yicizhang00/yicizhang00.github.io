---
title: Hot100
date: 2025-08-12 01:57:43
categories:
  - leetcode
tags:
  - leetcode
---

# 树

## 翻转二叉树







## 判断二叉树是否对称





## 二叉树的直径

题目：给你一棵二叉树的根节点，返回该树的 **直径** 。

二叉树的 **直径** 是指树中任意两个节点之间最长路径的 **长度** 。这条路径可能经过也可能不经过根节点 `root` 。

两节点之间路径的 **长度** 由它们之间边数表示。

思路：递归搜索每个节点的左右子树路径和，在主函数使用一个全局变量维护该最大值。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    
    static int ans = 0;
    public int diameterOfBinaryTree(TreeNode root) {
        if(root == null) 
        return 0;
        ans = 1;
        dep(root);
        return ans-1;

    }
    public static int dep(TreeNode node){
        if(node == null) return 0;
        int l = dep(node.left);
        int r = dep(node.right);
        ans = Math.max(ans, l+r+1);
        return Math.max(l,r)+1;
    }
}
```

> 注：二叉树的直径不同于图的直径，图的直径可以通过两次遍历先找到一端的直径端点，然后再找到另一端的直径端点实现，模板如下
>
> ```java
> public static int treeDiameter(int n, List<List<Integer>> adj) {
>         if (n == 0) return 0;
>         // 从任意节点 0 开始 BFS 找最远点
>         int far = bfsFarthest(0, n, adj)[0];
>         // 从 far 再次 BFS，得到最远距离
>         int[] res = bfsFarthest(far, n, adj);
>         return res[1]; // distance
>     }
> 
>     // 返回长度为2的数组: [farthestNode, distance]
>     private static int[] bfsFarthest(int src, int n, List<List<Integer>> adj) {
>         int[] dist = new int[n];
>         Arrays.fill(dist, -1);
>         Queue<Integer> q = new ArrayDeque<>();
>         q.add(src);
>         dist[src] = 0;
>         int farNode = src;
>         while (!q.isEmpty()) {
>             int u = q.poll();
>             for (int v : adj.get(u)) {
>                 if (dist[v] == -1) {
>                     dist[v] = dist[u] + 1;
>                     q.add(v);
>                     if (dist[v] > dist[farNode]) farNode = v;
>                 }
>             }
>         }
>         return new int[]{farNode, dist[farNode]};
>     }
> ```
>
> 