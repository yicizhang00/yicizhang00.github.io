---
title: 数据库基础
date: 2026-01-19 11:00:29
tags:
categories:
    - 数据库
---
# 数据库设计范式

数据库规范化（Normalization）是关系型数据库设计中用于**减少数据冗余、避免更新异常、提高数据一致性**的一系列理论规则。范式从第一范式（1NF）到第六范式（6NF）逐级增强约束，实际开发中最常用的是 **1NF ~ 3NF**，部分场景会用到 **BCNF**。

---

## 术语定义

### 超键（Superkey）
能够**唯一标识表中每一行记录**的一个或多个属性的集合。  
例如：在学生表 `(学号, 身份证号, 姓名)` 中，`{学号}`、`{身份证号}`、`{学号, 姓名}` 都是超键。

>  超键不要求“最小性”，只要能唯一标识即可。

---

### 候选键（Candidate Key）
**最小的超键**，即去掉其中任意一个属性后就不再具备唯一标识能力。  
一个表可以有多个候选键，但只能选其中一个作为主键。

>  例如：`(学号)` 和 `(身份证号)` 都可能是候选键；若选 `学号` 为主键，则 `身份证号` 是另一个候选键。

---
### 交替键
没有被选为**主键**的候选键被称为交替键。
---


### 主属性（Prime Attribute）
属于**任何一个候选键**的属性。  
例如：若候选键为 `{学号}` 和 `{身份证号}`，则 `学号` 和 `身份证号` 都是主属性。

---

### 非主属性（Non-prime Attribute）
**不属于任何候选键**的属性。  
例如：`姓名`、`年龄`、`部门ID` 等通常是非主属性。

---

### 函数依赖（Functional Dependency, FD）
若属性集 `X` 的值确定后，属性集 `Y` 的值也随之唯一确定，则称 **`X → Y`**（读作“X 函数决定 Y”）。  
例如：`学号 → 姓名` 表示每个学号对应唯一姓名。

>  注意：函数依赖是**语义层面**的业务规则，不是由当前数据样本推断出来的！

---

### 非平凡函数依赖（Non-trivial Functional Dependency）
若 `X → Y` 成立，且 **`Y ⊈ X`**（Y 不是 X 的子集），则称为非平凡函数依赖。  
例如：`学号 → 姓名` 是非平凡的；而 `学号 → 学号` 是平凡的，通常不考虑。

>  规范化理论只关注**非平凡函数依赖**。

---

### 多值依赖
给定 X，Y 的取值集合与表中其他属性无关，形成独立组合。
形式上：若 (x, y1, z1) 和 (x, y2, z2) 在表中，则 (x, y1, z2) 和 (x, y2, z1) 也应在表中。




---

## 1NF（第一范式：字段原子化）
**通俗点**：属性不可再分，  

**定义**：表的每一列都必须是**不可再分的原子值**，即：
- 同一列不能包含多个值（如数组、列表）；
- 不能存在重复列（如 `电话1`, `电话2` 应拆成关联表）。

**反例**：  
| 用户ID | 联系方式                     |
|--------|------------------------------|
| U001   | 手机:132..., 邮箱:xxx@...   |

→ `联系方式` 包含多个语义单元，违反 1NF。

**正确做法**：拆分为独立列或关联表：`(用户ID, 手机号, 邮箱)`，因为这样我们才可以将查询项设置为`手机号`或者`邮箱`。

### 关于Json格式的说明
<div style="border: 2px solid #150404ff; border-radius: 10px; padding: 10px; background: #f8f9fa;">
使用 JSON 格式可能会违反了第一范式。根据1NF的定义，其字段必须是原子的，而JSON格式本质是一个Array或Object，内部包含多个键值对或嵌套层次。

但如果将 JSON 作为不可分割的“黑盒”值（仅整体存取，不解析内部），则可视为原子值，形式上满足 1NF。
然而，这种做法通常违背规范化初衷，应谨慎使用。建议：仅用于存储配置、日志等非核心业务数据。

现代数据库（如 PostgreSQL, MySQL 8.0+）提供了 JSONB 或原生 JSON 支持及索引功能，这在物理层部分缓解了违背 1NF 带来的查询性能问题，但逻辑上它依然属于‘非规范化’操作。
</div>

## 2NF（第二范式：消除部分依赖）
**通俗点**：非主属性不能只依赖于半个主属性
**前提**：已满足 1NF。  
**定义**：所有**非主属性**必须**完全函数依赖于整个候选键**，而不能只依赖于候选键的一部分。

> 仅当主键是**复合主键**（由多个属性组成）时，2NF 才有意义。

**反例**：成绩表 `(学生ID, 课程ID, 学分, 成绩)`  
- 候选键：`(学生ID, 课程ID)`  
- 函数依赖：
  - `(学生ID, 课程ID) → 成绩` 符合2NF（完全依赖）
  - `课程ID → 学分` 不符合2NF（**部分依赖**：非主属性 `学分` 仅依赖主键的一部分）

**问题**：
- 若某门课程无人选修，则无法存储该课程的学分（**插入异常**）；
- 修改某门课程的学分时，需更新所有选了该课的学生记录（**更新异常**）；
- 删除最后一个学生对该课程的记录时，会丢失学分信息（**删除异常**）。

**修正方案**：分解为两张表

## 3NF（第三范式：消除传递依赖）
**通俗点**：不能存在A决定B，B决定C

**前提**：已满足 2NF。  
**定义**：所有非主属性**不能传递依赖于候选键**。即，不存在非主属性 `A → B → C`，其中 `A` 是候选键、`B` 是非主属性、`C` 是另一个非主属性。

更形式化地说：对于每个非平凡函数依赖 `X → Y`，要么：
1. `X` 是超键，**或**
2. `Y` 是主属性（属于某个候选键）

**反例**：员工表 `(员工ID, 姓名, 部门ID, 部门所在地)`  
- 候选键：`员工ID`  
- 函数依赖：
  - `员工ID → 部门ID`
  - `部门ID → 部门所在地`
  - ⇒ `员工ID → 部门所在地`（**传递依赖**，且 `部门所在地` 是非主属性）

**问题**：
- 部门搬迁时，需更新该部门下**所有员工**的 `部门所在地`（更新异常）；
- 若一个部门暂时没有员工，则无法记录其所在地（插入异常）。

**修正方案**：分解为
`<员工ID,姓名,部门ID>`和`<部门ID,部门所在地>`两张表。
## BCNF（Boyce-Codd 范式）
**通俗点**：在这个表里，任何能决定别人的属性（或属性组），都必须是`候选键`。  

**前提**：已满足 3NF。  
**定义**：对于关系模式中的**每一个非平凡函数依赖** `X → Y`，**X 必须是超键**。

>  **比 3NF 更严格**：3NF 允许 `Y` 是主属性时 `X` 不是超键，但 BCNF 不允许任何例外。

**经典反例**（满足 3NF 但不满足 BCNF）：  
表 `仓库管理(仓库, 管理员, 物品, 数量)`  
- 业务规则：
  - `仓库 ↔ 管理员`（一一对应，互相决定）
  - `(仓库, 物品) → 数量`
- 候选键有两个：`(仓库, 物品)` 和 `(管理员, 物品)`
- 函数依赖：`仓库 → 管理员`  
  → `仓库` 不是超键（单独无法确定物品），但决定了 `管理员`（主属性）

 满足 3NF（因为 `管理员` 是主属性）  
 **不满足 BCNF**（因为 `仓库` 不是超键）

**修正方案**：无损分解为`(管理员, 仓库)`和`(仓库, 物品, 数量)`


## 4NF（第四范式：消除多值依赖）
**通俗点**：两个“多选”别挤在一起做笛卡尔积。


**前提**：已满足 BCNF。  
**定义**：若存在**多值依赖**（Multivalued Dependency, MVD）`X ↠ Y`，则 `X` 必须是超键。

> **多值依赖**：给定 `X`，`Y` 的取值集合与表中其他属性无关，形成独立组合。  
> 形式上：若 `(x, y1, z1)` 和 `(x, y2, z2)` 在表中，则 `(x, y1, z2)` 和 `(x, y2, z1)` 也应在表中。

**反例**：`教师(教师名, 课程, 系别)`  
- 教师 A 教 {数学, 物理}，属于 {计算机系, 数学系}
- 为表示完整语义，需存储 2×2=4 行（笛卡尔积），造成冗余

**修正方案**：分解为`(教师名, 课程)`和`(教师名, 系别)`，将两个多值依赖拆开


## 5NF
**通俗点**： 如果是“三方契约”，别强行拆成两两关系。


**定义**：关系模式不能被无损地分解为三个或更多子关系，除非这种分解是由候选键隐含的。

**连接依赖 (Join Dependency)**：如果一张大表可以拆分成 $N$ 张小表，并且当你把这 $N$ 张小表重新做 JOIN（连接）操作时，能够完美还原回原表，既不多出数据（伪记录），也不少掉数据，那么我们就说这张原表存在“连接依赖”。

5NF处理的是连接依赖（Join Dependency）问题，而非函数依赖或多值依赖。如果这个三元约束可以被分解为三个二元关系且不产生伪记录，那么为了达到 5NF，必须将其拆分为三个表。


实际应用极少，主要用于理论完备性。

**示例场景**：
某表记录`(供应商, 零件, 项目)`三元组，且存在约束：只有当供应商能供应该零件、且该项目使用该零件、且该项目由该供应商供货时，三元组才有效。
此时若任意两两连接会产生无效组合，需保持三元整体 → 满足 5NF。




## DKNF
**通俗点**：只要填空不出界，逻辑就永远不出错。通过“拆表 + 极其精细的类型定义”消灭“逻辑判断”。

**定义**：关系中的所有约束都可以由域约束（每个属性的合法取值范围）和键约束（唯一性、主键等）逻辑推导得出。

 换言之：表中不存在除“域”和“键”之外的其他语义约束（如函数依赖、多值依赖等）。所有的业务规则都变成了‘类型检查’和‘身份检查’。
> 实际业务中几乎不可能达到，因为业务规则往往复杂。

## 6NF
**通俗点**：全员单间，一表一属性。

**定义**：在支持时态数据（Temporal Data）的数据库中，将每个非键属性与主键分离成独立表，以支持完整的历史版本追踪。

结构特点：
原表 `(A, B, C)`（主键 A） → 分解为
`(A, B)`
`(A, C)`

>适用于需要精确记录属性随时间变化的系统（如金融交易、医疗记录）。
会显著增加表数量和查询复杂度，通常通过专用时态数据库实现。





