---
title: 数据结构
date: 2025-08-12 01:55:16
tags:
categories: 
  - 数据结构 
---
# 基本数据结构
## 1.数组
特点

<div style="border: 2px solid #150404ff; border-radius: 10px; padding: 10px; background: #f8f9fa;">
☆如何创建一个动态扩容数组：
</div>


## 链表

## 栈

## 队列

## 哈希表


☆哈希表如何解决哈希冲突：

1.链地址法：每个哈希桶存储一个链表（或其他结构），所有哈希到同一位置的元素都插入该链表。插入和查找时只需遍历链表即可。
2.开放地址法：当发生冲突时，按照一定探查方式（如线性探查、二次探查、双重哈希）寻找下一个空位，将元素插入空位。查找时同样按探查顺序查找。
3.再哈希法：发生冲突时，使用另一个哈希函数重新计算位置，直到找到空位。
4.扩容与重哈希：当哈希表负载因子过高时，扩容并重新分配所有元素，减少冲突概率。

**Java实现**
Java的HashMap在JEP 180之前采用链表解决冲突，而之后当链表长度超过阈值（通常为8）通过将每个桶存储一个链表转为红黑树。

具体来说，当一个哈希桶中的链表长度达到 8（即 TREEIFY_THRESHOLD）时，并且此时哈希表的总容量（capacity）也达到了 64（即 MIN_TREEIFY_CAPACITY），这个链表就会被转换为一棵红黑树。

**改进实现**
在改进之前，字符串冲突的备选是采用hash32，为每一个String新增一个字段，此改进实现了任何Comparable接口的键类型的性能提升，字符串的hash32字段被移除。
    
该改进已经在`java.util.concurrent.ConcurrentHashMap`,`HashMap`以及`LinkedHashMap`中实现。但是在`HashTable`,`WeakHashMap`和`IdentityHashMap`中并不实现。

**为什么要满足容量大于 64？**
因为如果哈希表容量太小，频繁发生哈希冲突的原因很可能不是哈希函数不好，而是哈希表本身太小。在这种情况下，更好的解决办法是进行扩容（resize），而不是转换为红黑树。

当哈希表容量小于 64 时，即使链表长度达到了 8，`HashMap` 也会优先选择扩容，通过重新计算哈希值来分散元素。这样可以避免不必要的树化，减少性能开销。

**为什么链表长度为8**
泊松分布描述稀有事件在固定时间或者空间内发生的概率，适用于：
- 事件独立
- 事件发生的平均速率已知并固定
- 事件发生的概率极低
在哈希表中，设容量为m，插入n个键，每个键落入m个桶内，单个键冲突概率为\( \frac{1}{m}\)

**WeakHashMap的弱引用与垃圾回收**
`WeakHashMap` 的核心特点是键（key）是弱引用。这意味着当一个键对象没有其他强引用指向它时，它随时可能被垃圾回收器（Garbage Collector, GC）回收。

WeakHashMap内部有一个ReferenceQueue队列维护被GC的键，当一个弱引用键被GC后，其会被添加到这个队列中，在每次put,get,remove时，会检查并清理这个队列，所有被GC的键从WeakHashMap中删除。因此带来了：
1） 红黑树的维护开销：红黑树在删除节点时会带来节点的旋转和重新着色。
2） GC行为无法预测：导致红黑树的结构也不可预测，会带来巨大的性能开销。

**IdentityHashMap基于身份哈希的无冲突设计**
IdentityHsahMap采用"=="而非"equals()"


<div style="border: 2px solid #150404ff; border-radius: 10px; padding: 10px; background: #f8f9fa;">

</div>

### HashMap

### HashTable

### WeakHashMap

### IdentityHashMap

### LinkedHashMap
**LRU缓存设计**

**Redis的LRU设计**
redis的LRU并非严格LRU设计，而是近似的LRU设计，因此严格的LRU在每次访问一个键时需要将其移动到链表头部，同时对于内存和开销都有巨大压力：


### EnumMap


### ConcurrentSkipListMap

# 进阶数据结构

## 堆

## 优先队列

## TreeMap

## Deque 双端队列

## TreeSet

## 图

## 并查集DSU

# 高级数据结构

## 跳表

## 线段树

## 前缀树

## AVL

## 红黑树

## 布隆过滤器
布隆过滤器是一种空间效率极高的概率型数据结构，用于判断一个元素是否在集合中。它通过多个哈希函数将元素映射到位数组的不同位置，插入时将对应位设为1，查询时只要有一个位为0则一定不在集合中，否则可能在集合中（存在误判）。

**优点：**
- 占用空间小，插入和查询速度快。
- 适合大数据场景下的快速去重和存在性判断。

**缺点：**
- 存在一定的误判率（假阳性），无法删除元素（标准实现）。
- 不支持元素的遍历。

**应用场景：**
- 数据库缓存过滤（如Redis缓存穿透防护）
- 网络黑名单检测
- 大规模去重（如爬虫URL判重）

**时间复杂度：**
- 插入操作(Add): O(K)
- 查询操作(Check): O(K)
k是哈希函数的数量
<div style="border: 2px solid #150404ff; border-radius: 10px; padding: 10px; background: #f8f9fa;">
☆★布隆过滤器的原理是用 k 个哈希函数将元素映射到位数组的 k 个位置。插入时，需要对元素进行 k 次哈希并设置 k 个位；查询时，需要对元素进行 k 次哈希并检查 k 个位。因此，时间复杂度与哈希函数数量 k 成线性关系，通常 k 是常数，所以实际操作接近 O(1)。
</div>

### Java实现
```java
public class SimpleBloomFilter {
    private int size;
    private boolean[] bits;
    private int[] seeds = {7, 11, 13, 31, 37, 61};

    public SimpleBloomFilter(int capacity) {
        this.size = capacity;
        this.bits = new boolean[size];
    }

    private int hash(String value, int seed) {
        int result = 0;
        for (int i = 0; i < value.length(); i++) {
            result = seed * result + value.charAt(i);
        }
        return (size - 1) & result;
    }

    public void add(String value) {
        for (int seed : seeds) {
            bits[hash(value, seed)] = true;
        }
    }

    public boolean contains(String value) {
        for (int seed : seeds) {
            if (!bits[hash(value, seed)]) {
                return false;
            }
        }
        return true;
    }
}
```

### 第三方库
```java
BloomFilter<String> bloomFilter = BloomFilter.create(
    Funnels.stringFunnel(Charset.defaultCharset()), 
    1000, // 预期元素数量
    0.01  // 误报率
);
bloomFilter.put("item1");
System.out.println(bloomFilter.mightContain("item1")); // true
```

## 有序哈希表LinkedHashMap

## WeakHashMap

## EnumSet

## EnumMap

## 地址哈希表IdentityHashMap

## CopyOnWriteArrayList

## ConcurrentHashMap

## 时间轮Time Wheel

## 位集 BitSet

