---
title: 熔断限流框架
date: 2026-01-08 14:26:52
tags:
    - 熔断
    - 限流
categories:
    - Java
---

# 导言

在分布式系统架构中，熔断和限流是确保系统高可用性与稳定性的重要手段。当前业界广泛使用的三大主流开源熔断限流框架分别是：Hystrix、Sentinel、Resilience4j。这些框架主要提供以下功能：

- **熔断（Circuit Breaker）**：当调用某个微服务接口出现故障（如超时或异常）比例过高时，临时阻断对该接口的调用请求，防止错误在系统内蔓延，保证核心服务的可用性。
- **限流（Rate Limiter）**：对系统资源访问进行流量限制，防止突发流量冲垮后端服务，通过漏桶、令牌桶等算法平滑请求压力，实现弹性削峰填谷。
- **降级（Fallback）**：当服务不可用或被熔断、限流时，允许快速返回兜底结果（如默认值、缓存结果）或友好提示，从而提升整体用户体验及系统健壮性。
- **监控与报警**：对流量、异常、调用延迟、限流与熔断等状态进行数据采集和可视化展示，并在出现异常时进行报警，便于运维处理。

下文将分别介绍三大框架的主要特性、适用场景及基本用法，帮助开发者选择合适的解决方案进行系统容错和流量保护。
# Hystrix

Hystrix 是 Netflix 开源的熔断限流框架，主要解决分布式系统中依赖服务不稳定带来的雪崩效应问题。Hystrix 能够通过隔离、降级、熔断、限流等方式，提升整个系统的稳定性和容错性。它曾经是 Spring Cloud 微服务生态的默认熔断与限流组件，目前已于 2020 年停止维护，官方不建议在新项目中继续选用，但是在大量旧系统中依然被广泛使用。

## 主要特性

- **线程隔离和信号量隔离**：防止单个依赖处理缓慢拖垮主业务线程池。
- **服务熔断**：支持按错误比例、超时比例等指标自动开启熔断。
- **自动降级与回退（Fallback）**：后端依赖不可用时自动执行降级逻辑或返回默认值。
- **实时监控（Hystrix Dashboard）**：可视化界面展示熔断器状态与运行统计。
- **请求缓存和批量请求（Request Caching & Collapsing）**：缓存重复请求、合并相似请求，减少压力。

## 典型应用场景

- 微服务调用链过长，某个服务不稳定可能拖垮整个系统时。
- 需要快速失败并返回友好降级/兜底内容时。
- 历史代码，基于 Spring Cloud（Hoxton 及之前版本）保持兼容时。

## 基本用法示例

以 Spring Cloud 为例，使用 Hystrix 只需在业务方法上加 `@HystrixCommand` 注解：

```java
@HystrixCommand(fallbackMethod = "fallback")
public String getUserInfo(String id) {
    // 调用远程服务，可能超时或失败
}

public String fallback(String id) {
    return "获取用户信息失败，请稍后重试";
}
```

## 注意事项

- Hystrix 已停止维护，新项目推荐使用 Sentinel 或 Resilience4j。
- 由于设计和实现上与 Java 8 以后的一些标准接口不兼容，未来建议向新框架迁移。


# Sentinel

Sentinel 是阿里巴巴开源的高可用流量管控组件，专注于微服务的流量控制（限流）、熔断降级、系统负载保护。它不仅支持 Java，也有多语言生态，实现了完善的控制台、实时监控和动态规则下发等功能，是目前主流国产云原生架构的首选熔断与限流方案。

## 主要特性

- **多维度限流**：支持针对接口、服务、热点参数、调用方等多维度进行流量控制，支持 QPS/线程数等多种模式。
- **熔断降级**：根据异常比率、响应时间等自动触发熔断，并提供自动恢复机制。
- **系统保护**：可基于系统整体负载（如 CPU、RT、并发线程数）自动进行保护。
- **实时监控与动态规则配置**：自带控制台，可实时监控流量与规则生效情况，支持规则的热更新。
- **丰富的扩展支持**：与 Dubbo、Spring Cloud、gRPC等微服务框架无缝集成，支持云原生生态。

## 典型应用场景

- 微服务架构中，需要对访问量大、依赖多的接口进行动态限流和熔断保护。
- 对热点参数（如商品 ID、用户 ID）等进行细粒度流控。
- 系统整体稳定性保护（如高并发秒杀防护）。

## 基本用法示例

### 1. Java 代码方式接入 Sentinel

```java
public void doSomething() {
    Entry entry = null;
    try {
        entry = SphU.entry("doSomethingResource");
        // 被保护的业务逻辑
    } catch (BlockException ex) {
        // 被限流或熔断的处理逻辑
        System.out.println("当前流量被限流或熔断，降级处理");
    } finally {
        if (entry != null) {
            entry.exit();
        }
    }
}
```

### 2. Spring Cloud 集成（推荐）

只需引入依赖并配置，针对接口加 `@SentinelResource` 注解即可实现熔断与降级：

```java
@SentinelResource(value = "getItems", fallback = "fallbackHandler")
public List<Item> getItems(Long userId) {
    // 业务逻辑
}

public List<Item> fallbackHandler(Long userId, Throwable ex) {
    // 降级处理
    return Collections.emptyList();
}
```

### 3. 控制台实时配置规则

Sentinel 支持通过控制台动态增删改查规则，实现不停机、实时生效的保护手段。

## 注意事项

- Sentinel 推荐配合其控制台和监控系统使用，运维体验较好。
- 热点参数限流、系统负载保护等是 Sentinel 的独特优势。
- 配置规则时需充分结合实际业务场景，建议灰度上线、分阶段生效，避免误伤核心流量。

更多介绍及实践案例详见官方文档：https://sentinelguard.io/zh-cn/




# Resilience4j
Resilience4j 是一个专为 Java 8 及以上设计的轻量级高效容错库，支持限流（RateLimiter）、熔断（CircuitBreaker）、仓壁（Bulkhead）等多种容错模式，非常适合与 Spring Boot 等微服务框架配合使用。

## 1. 引入依赖

以 Maven 为例：

```xml
<dependency>
    <groupId>io.github.resilience4j</groupId>
    <artifactId>resilience4j-spring-boot2</artifactId>
    <version>1.7.1</version>
</dependency>
```

或按需引入限流、熔断子模块。

## 2. 熔断（CircuitBreaker）用法

### 注解/声明式使用

以 Spring Boot 为例，只需在方法上添加 `@CircuitBreaker` 注解：

```java
@Service
public class ItemService {

    @CircuitBreaker(name = "itemServiceBreaker", fallbackMethod = "getItemsFallback")
    public List<Item> getItems(Long userId) {
        // 正常业务处理
    }

    public List<Item> getItemsFallback(Long userId, Throwable t) {
        // 降级处理
        return Collections.emptyList();
    }
}
```

application.yml 示例配置：

```yaml
resilience4j.circuitbreaker:
  instances:
    itemServiceBreaker:
      registerHealthIndicator: true
      slidingWindowSize: 10
      minimumNumberOfCalls: 5
      failureRateThreshold: 50
      waitDurationInOpenState: 5s
```

### 编程式用法

```java
CircuitBreaker circuitBreaker = CircuitBreaker.ofDefaults("backendA");
Supplier<List<Item>> decoratedSupplier = CircuitBreaker
    .decorateSupplier(circuitBreaker, () -> getItems(userId));

Try<List<Item>> result = Try.ofSupplier(decoratedSupplier)
    .recover(throwable -> Collections.emptyList());
```

## 3. 限流（RateLimiter）用法

### 注解/声明式使用

```java
@RateLimiter(name = "myLimiter", fallbackMethod = "getItemsFallback")
public List<Item> getItems(Long userId) {
    // 业务逻辑
}
```

### 编程式用法

```java
RateLimiter rateLimiter = RateLimiter.ofDefaults("backendA");
Supplier<List<Item>> limitedSupplier =
    RateLimiter.decorateSupplier(rateLimiter, () -> getItems(userId));

Try<List<Item>> result = Try.ofSupplier(limitedSupplier)
    .recover(throwable -> Collections.emptyList());
```

application.yml 示例：

```yaml
resilience4j.ratelimiter:
  instances:
    myLimiter:
      limitForPeriod: 10  # 每周期最多调用10次
      limitRefreshPeriod: 1s
      timeoutDuration: 500ms
```

## 4. 与 Spring Cloud/Gateway 集成

只需引入对应 starter 并基于注解、配置即可与服务治理无缝衔接。

## 5. 典型运维建议

- 熔断/限流策略参数要结合流量、业务特性实际调优；
- 埋点监控熔断、限流相关事件，及时发觉异常；
- 配合 Prometheus、Micrometer 做实时监控与报警。

**更多实践与官方文档**  
详见：[https://resilience4j.readme.io/](https://resilience4j.readme.io/)
