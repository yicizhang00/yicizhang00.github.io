<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>java基础 | Hexo</title><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="java基础"><meta name="application-name" content="java基础"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="java基础"><meta property="og:url" content="http://example.com/2025/08/12/Java/java%E5%9F%BA%E7%A1%80/index.html"><meta property="og:site_name" content="Hexo"><meta property="og:description" content="Java基础知识静态方法与非静态成员静态方法是属于类的，而非静态成员属于实例对象，前者在类加载的时候就会分配内存，而后者只有在对象实例化之后才会加载，因此静态方法不能访问非静态成员。 可变长参数在jdk5后引入，参数后会加上...以表示可变长参数，当一个可变长参数的函数重载另一个函数会后，调用会优先"><meta property="og:locale" content="en"><meta property="og:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta property="article:author" content="John Doe"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta name="description" content="Java基础知识静态方法与非静态成员静态方法是属于类的，而非静态成员属于实例对象，前者在类加载的时候就会分配内存，而后者只有在对象实例化之后才会加载，因此静态方法不能访问非静态成员。 可变长参数在jdk5后引入，参数后会加上...以表示可变长参数，当一个可变长参数的函数重载另一个函数会后，调用会优先"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/2025/08/12/Java/java%E5%9F%BA%E7%A1%80/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2024/07/27/125766904/ba62475f396df9de3316a08ed9e65d86_5680958632268053399..png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"Author: John Doe","link":"Link: ","source":"Source: Hexo","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.","copySuccess":"Copy success, copy and reprint please mark the address of this article"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Hexo',
  title: 'java基础',
  postAI: '',
  pageFillDescription: 'Java基础知识, 静态方法与非静态成员, 可变长参数, 面向对象OOP, 接口和抽象类, Final关键字, Final修饰的类, Final修饰的方法, Final修饰的变量, 1. final修饰基本类型变量, 2. final修饰引用类型变量, 3. final修饰成员变量, Final的内存特点, 浅拷贝、深拷贝与引用拷贝, 浅拷贝, 深拷贝, 引用拷贝, StringStringBuilder和StringBuffer, String不可变, Error 和 Exception, Checked Exception和Unchecked Exception, throwable-类常用方法有哪些, try-catch-finally-如何使用, finally中的代码一定会被执行吗？, try-with-resources, 语法示例, 资源类型与可用性, Java 7 vs Java 9 的差别（重要）, 资源关闭的顺序, 异常处理：主异常与 suppressed（关键点）, 编译器如何糖化为 try-finally（反糖化示例）, 关于 null 资源, 结合 catch x2F finally, 常见误区与注意点（实务建议）, 进阶示例（多资源、Java9 语法、锁释放包装器）, 实践建议（短句）, 泛型, 泛型的设计目的, 泛型擦除, 泛型边界与通配符, 上界 extends, 下界 super, 无界通配符, PECS原则(Producer Extends Consumer Super), 协变x2F逆变, 泛型擦除, 最佳实践, 反射, 优点, 缺点：, 应用场景, 注解, SPI和API, 序列化和反序列化, 语法糖, Java重要知识, 值传递与引用传递, 传递基本类型, 传递引用复制, 无法改变原引用的值, 泛型amp通配符详解, 一、泛型的基本概念, 1.1 为什么需要泛型, 二、泛型的基本用法, 2.1 泛型类, 2.2 泛型接口, 2.3 泛型方法, 三、泛型的类型参数限制, 3.1 类型变量的限制（类型边界）, 3.2 多个边界, 3.3 类型参数命名规范, 四、通配符（Wildcards）, 4.1 无界通配符 ?, 4.2 上界通配符 ? extends T, 4.3 下界通配符 ? super T, 五、PECS原则（Producer Extends Consumer Super）, 5.1 原则说明, 5.2 实际应用示例, 5.3 Collections.copy()的实现, 六、类型擦除（Type Erasure）, 6.1 什么是类型擦除, 6.2 类型擦除的影响, 6.3 桥方法（Bridge Method）, 七、泛型的实际应用场景, 7.1 集合框架, 7.2 通用工具类, 7.3 设计模式中的应用, 八、常见问题和注意事项, 8.1 原始类型（Raw Type）, 8.2 静态成员不能使用类型参数, 8.3 基本类型不能作为类型参数, 8.4 类型推断的限制, 8.5 泛型与重载, 九、获取泛型信息（反射）, Java反射, 反射获取对象类的方式, 1. 类名.class, 2. 对象.getClass(), 3. Class.forName(全限定类名), 4. 通过ClassLoader加载基础知识静态方法与非静态成员静态方法是属于类的而非静态成员属于实例对象前者在类加载的时候就会分配内存而后者只有在对象实例化之后才会加载因此静态方法不能访问非静态成员可变长参数在后引入参数后会加上以表示可变长参数当一个可变长参数的函数重载另一个函数会后调用会优先选择范围可定的函数方法体可变长参数实际上是一个语法糖编译器在底层会将其转换为数组例如会被编译为调用方法时可以传递任意数量包括零个的参数可变长参数只能放在普通参数的最后面向对象三大特点封装继承多态封装内部成员隐藏仅暴露外部方法以供调用继承在已定义的类的基础上定义额外的类提高代码的重用和可扩展性子类无法继承父类的私有属性和方法子类可以重写父类的方法多态一个对象可以存在多种状态编译时多态方法重载运行时多态方法重写这是多态的核心和精髓接口和抽象类实例化接口和抽象类都不能直接实例化只能被实现接口或继承抽象类后才能创建具体的对象抽象方法接口和抽象类都可以包含抽象方法抽象方法没有方法体必须在子类或实现类中实现维度接口抽象类继承实现多个接口只能继承一个抽象类方法抽象方法默认方法静态方法抽象方法和具体方法变量只能是常量可以是普通变量构造器无有设计目标定义契约和能力代码复用和部分实现访问修饰符默认可以是等关键字修饰的类作用表示这个类不能被继承即不能有子类特点这个类所有方法都不能重写因为没有子类这个类中的变量不一定是的修饰的方法作用表示这个方法不能被子类重写特点可以用于修饰静态方法和实例方法是隐式的因为无法被继承也就没有重写方法可以被修饰的变量修饰基本类型变量作用表示这个变量的值一旦初始化就不能被修改即成为常量修饰引用类型变量作用表示这个引用不能再指向其他对象但对象本身的内容可以被修改修饰成员变量特点必须在声明时或构造方法中初始化一旦初始化后就不能再修改的内存特点修饰的变量在初始化完成后对其他线程可见阻止内存重排用于实现线程安全不可变关键浅拷贝深拷贝与引用拷贝浅拷贝创建一个新对象然后将原对象的非静态字段的值逐个复制到新对象如果字段是基本类型则复制其值如果字段是引用类型则复制其内存地址即引用而不是引用的对象本身深拷贝创建一个新对象同时递归地创建原对象中所有引用类型字段所指向的对象的副本结果是两个完全独立的对象没有任何共享的内部状态引用拷贝创建一个新的变量名实际上指向的还是原来的对象引用地址和不可变是一个修饰的对象关键字强调了该引用不可变在的主要实现中底层是一个本质是个数组而且用关键字修饰虽然不可变但是其引用不可变我们依然可以去修改堆中的内存但其使用了修饰并且没有暴露内部字段同时有字符串常量池属性对于相同的字符串它们都指向堆的同一个内存地址如果是可变的话这就没有意义了和所有的异常都继承于其有两个子类程序本身可以处理的异常可以通过进行捕获又分为和异常属于程序无法处理的不建议通过来捕获因为捕获了后续也没法处理例如无法恢复现场不能保证系统能安全恢复通常只是能打印日志或做一些清理工作如等和即受检查异常代码在编译过程中如果受检查异常没有被或者关键字处理的话就没办法通过编译最常见的如强制要求在编译阶段就对其进行或者否则编译无法通过除了及其子类以外其他的类及其子类都属于受检查异常常见的受检查异常有相关的异常即不受检查异常代码在编译过程中我们即使不处理不受检查异常也可以正常通过编译及其子类都统称为非受检查异常常见的有建议记下来日常开发中会经常用到空指针错误参数错误比如方法入参类型错误字符串转换为数字格式错误的子类数组越界错误类型转换错误算术错误安全错误比如权限不够不支持的操作错误比如重复创建同一用户这些异常无法在编译阶段被感知到因此只有在运行时才能捕获这些异常类常用方法有哪些返回异常发生时的详细信息返回异常发生时的简要描述返回异常对象的本地化信息使用的子类覆盖这个方法可以生成本地化信息如果子类没有覆盖该方法则该方法返回的信息与返回的结果相同在控制台上打印对象封装的异常信息如何使用块用于捕获异常其后可接零个或多个块如果没有块则必须跟一个块块用于处理捕获到的异常块无论是否捕获或处理异常块里的语句都会被执行当在块或块中遇到语句时语句块将在方法返回之前被执行如果语句里有返回的是语句块中变量值详细执行过程如下如果有返回值就把返回值保存到局部变量中执行指令跳到语句里执行执行完语句后返回之前保存在局部变量表里的值如果语句里均有忽略的而使用的中的代码一定会被执行吗中的代码在虚拟机被终止时中的代码就不会被执行其实是一个语法糖其目的是自动安全地关闭实现了或的资源替代手写的关闭资源避免资源泄漏并且正确处理关闭时抛出的异常语法示例使用处理读取异常可以声明多个资源用分号分隔资源类型与可用性资源类型必须实现也可以因为它继承自声明为而声明为因此如果资源的抛出受检异常调用方法必须声明或捕获该异常的差别重要资源必须在中声明即在括号内创建变量允许把已经存在的或本地变量放入的括号中必须在此之后不再被修改资源关闭的顺序创建顺序左到右关闭顺序反向右到左也就是最后创建的资源最先关闭异常处理主异常与关键点如果块中抛出了异常而在关闭资源时抛出了异常那么异常是主异常会被抛出关闭时抛出的异常会被作为被抑制异常加入主异常如果块没有异常但关闭时抛出异常则该关闭异常成为主异常并被抛出你可以通过获取被抑制的异常在打印栈跟踪时也会显示列表示例演示输出编译器如何糖化为反糖化示例单资源的近似编译后形式示意注意重点如果主异常存在抛出的异常不会覆盖它而是被如果没有主异常抛出的异常会向上抛出对于多个资源编译器会按资源个数生成嵌套的类似逻辑最终达到反向关闭并抑制的效果编译器还会在调用前检查资源是否为因此如果资源变量为不会关于资源如果资源表达式结果是编译器生成的代码会检查并跳过关闭不会调用导致结合支持和处理最后仍然会在这里执行已在退出时调用中的代码在资源关闭之后执行因为关闭是在隐式中完成的但语义上资源关闭是在退出后外层执行前完成常见误区与注意点实务建议不要在中做复杂的恢复逻辑应该尽量简洁幂等如果失败会抑制真正的业务异常排查会麻烦处理日志或错误处理时最好记录主异常和的内容避免失去关键信息不要捕获或除非框架层业务代码应捕获可恢复的异常类型框架容器可能会用做最后兜底并记录日志的使用从起都实现了推荐在中使用确保按逆序关闭方法签名注意如果资源的声明抛出受检异常那么方法如果不捕获这些异常就需要声明相应的进阶示例多资源语法锁释放包装器多资源关闭顺序使用已声明变量必须是把用作包装成使用在这里持有实践建议短句优先使用来管理流文件数据库连接等资源在需要记录或转发异常时注意同时查看实现时让简单且幂等尽量不抛出不可预期的异常若必须抛出文档清楚标注泛型泛型的设计目的在之前没有泛型的设计导致所有的集合容器存放的都是型使用时必须进行强制类型转换需要强转运行时容易出错出现因此引入了泛型能够提供编译时的类型检查消除类型强制转换可读性更好泛型擦除的泛型本质是伪泛型只会在编译时进行泛型的类型检查而在运行时会进行泛型擦除编译器在使用泛型的方法前会插入进行类型转换意味在运行时实际上无法获得泛型信息和在看来实际上都是都是由于在运行时没有泛型信息我们不能在运行时进行类型判断编译错误也不能创建泛型类型数组编译错误泛型边界与通配符上界必须是或其子类上界的能够确定当前泛型所继承的父类也就是说一定是其子类下界可以存放及其子类但取出时只保证是下界的能够确定当前泛型所拥有的子类也就是说一定是其父类无界通配符原则上界意味着你能确定当前泛型一定是某个类的子类能够安全地读出意味着可以用父类来接受它例如可以用这个父类来接受但是不能安全地写入因为无法判断其是什么具体类是还是而下界作为某个类的父类能够安全的写入因为至少能够写入最基础的类而不能安全的读出取出时只能保证其是超类自身或者其子类协变逆变的泛型没有协变逆变因此不能写如下的代码编译错误必须使用通配符表达合法泛型擦除由于在运行时会进行泛型擦除因此想要获得具体的泛型信息需要借助反射和的可能是最佳实践基本类型不能作为泛型参数不合法必须用静态变量不能使用类型参数因为泛型参数属于实例层面不属于类层面泛型类不能直接创建泛型数组类型擦除导致的桥方法如果泛型方法在子类中被重写编译器可能生成桥方法保证多态一致在设计中用通配符表达灵活性原则在内部实现时用确切的类型参数减少歧义避免原生类型这样会失去泛型检查在必要时使用但要小心写工具类时优先考虑泛型方法而不是泛型类反射简单来说反射是一种在程序运行时动态地获取类的信息并操作类或对象方法属性的能力通常情况下我们写的代码在编译时类型就已经确定了要调用哪个方法访问哪个字段都是明确的但反射允许我们在运行时才去探知一个类有哪些方法哪些属性它的构造函数是怎样的甚至可以动态地创建对象调用方法或修改属性哪怕这些方法或属性是私有的正是这种在运行时反观自身并进行操作的能力使得反射成为许多通用框架和库的基石它让代码更加灵活能够处理在编译时未知的类型优点灵活性和动态性反射允许程序在运行时动态地加载类创建对象调用方法和访问字段这样可以根据实际需求如配置文件用户输入注解等动态地适应和扩展程序的行为显著提高了系统的灵活性和适应性框架开发的基础许多现代框架如都大量使用反射来实现依赖注入面向切面编程对象关系映射注解处理等核心功能反射是实现这些魔法功能不可或缺的基础工具解耦合和通用性通过反射可以编写更通用可重用和高度解耦的代码降低模块之间的依赖例如可以通过反射实现通用的对象拷贝序列化工具等缺点性能开销反射操作通常比直接代码调用要慢因为涉及到动态类型解析方法查找以及编译器的优化受限等因素不过对于大多数框架场景这种性能损耗通常是可以接受的或者框架本身会做一些缓存优化安全性问题反射可以绕过语言的访问控制机制如访问字段和方法破坏了封装性可能导致数据泄露或程序被恶意篡改此外还可以绕过泛型检查带来类型安全隐患代码可读性和维护性过度使用反射会使代码变得复杂难以理解和调试错误通常在运行时才会暴露不像编译期错误那样容易发现应用场景和以为代表的框架会在启动时扫描带有特定注解如的类利用反射实例化对象并通过反射注入依赖如构造器注入等注解处理框架通过反射检查类方法字段上有没有特定的注解然后根据注解信息执行相应的逻辑比如看到就用反射读取注解内容去配置文件找对应的值再用反射把值设置给字段动态代理和自带的动态代理和就离不开反射代理对象在内部调用真实对象的方法时就是通过反射的来完成的关系对象映射通过反射获取类的属性列表然后把查询结果按名字或配置对应起来再用反射调用或直接修改字段值反过来保存对象到数据库时也是用反射读取属性值来拼注解注解是开始引入的新特性可以看作是一种特殊的注释主要用于修饰类方法或者变量提供某些信息供程序在编译或者运行时使用注解本质是一个继承了的特殊接口注解只有被解析之后才会生效常见的解析方法有两种编译期直接扫描编译器在编译代码的时候扫描对应的注解并处理比如某个方法使用注解编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法运行期通过反射处理像框架中自带的注解比如框架的都是通过反射来进行处理的和当实现方提供了接口和实现我们可以通过调用实现方的接口从而拥有实现方给我们提供的能力这就是这种情况下接口和实现都是放在实现方的包中调用方通过接口调用实现方的功能而不需要关心具体的实现细节当接口存在于调用方这边时这就是由接口调用方确定接口规则然后由不同的厂商根据这个规则对这个接口进行实现从而提供服务序列化和反序列化序列化将数据结构或对象转换成可以存储或传输的形式通常是二进制字节流也可以是等文本格式即对象反序列化将在序列化过程中所生成的数据转换为原始数据结构或者对象的过程即对象语法糖语法糖实际上不是一个真正的语法只是为了简化某些语法表达而创建的例如就是一个语法糖并不能识别语法糖语法糖只在编译器层面被看见编译器编译代码为字节码时会调用来解码语法糖重要知识值传递与引用传递只有值传递没有引用传递对于传参在方法调用时实参的值会被复制一份传递给形参如果参数是基本类型复制的是具体的数值如果参数是引用类型复制的是引用的值也就是对象在堆里的地址传递基本类型还是只改了副本传递引用复制输出修改的是同一个对象无法改变原引用的值还是指向新对象但不影响外部的真正的引用传递可以修改调用者的变量绑定泛型通配符详解一泛型的基本概念泛型是引入的特性允许在定义类接口和方法时使用类型参数使得类型可以作为参数传递提供了编译时的类型安全检查和代码重用为什么需要泛型在之前容器类如只能存储类型使用时需要进行强制类型转换编译时不会报错需要强制转换运行时可能抛出泛型的引入解决了以下问题类型安全在编译时进行类型检查避免运行时类型转换异常消除强制转换代码更加简洁不需要频繁进行类型转换提高代码可读性代码意图更加明确比更清晰二泛型的基本用法泛型类泛型类是指在定义类时使用类型参数的类定义泛型类使用泛型类不需要强制转换泛型接口泛型接口与泛型类类似接口定义时可以使用类型参数定义泛型接口实现泛型接口泛型方法泛型方法可以在非泛型类中定义方法可以有自己的类型参数泛型方法类型参数在返回类型之前多个类型参数使用泛型方法返回返回类型推断在调用泛型方法时通常不需要显式指定类型参数编译器可以根据参数类型自动推断显式指定类型参数通常不需要类型推断推荐方式三泛型的类型参数限制类型变量的限制类型边界可以使用关键字限制类型参数必须是指定类的子类或实现指定接口限制必须是或其子类可以安全调用的方法合法合法编译错误多个边界可以使用连接多个边界但类只能有一个接口可以有多个必须同时是的子类和的实现类型参数命名规范类型元素常用于集合键值数字第二个第三个第四个类型四通配符通配符用于表示未知类型提供了更灵活的类型匹配方式通配符使用表示无界通配符无界通配符表示可以接受任何类型的但只能读取不能写入除了编译错误不能写入编译错误不能写入唯一可以写入的值是合法合法使用场景当方法只需要读取集合中的元素而不关心具体类型时使用上界通配符上界通配符表示可以接受及其子类型的可以接受及其子类型的合法合法特点只能读取可以安全地读取元素并视为类型不能写入除了之外不能添加任何元素因为不知道具体是哪个子类型可以读取编译错误编译错误只能添加原理说明假设如果允许就会在中存入破坏了类型安全下界通配符下界通配符表示可以接受及其父类型的可以接受及其父类型的合法合法特点只能写入可以安全地添加及其子类型的元素读取受限只能读取为类型可以写入可以写入编译错误只能读取为原理说明假设可以添加因为是的子类但读取时只能保证是的父类无法确定具体类型五原则是使用通配符的重要原则帮助决定何时使用还是原则说明生产者使用如果参数是用来产生提供元素的只读使用消费者使用如果参数是用来消费接收元素的只写使用实际应用示例生产者从读取元素消费者向写入元素从读取向写入合法的实现标准库中的方法就是原则的典型应用从读取向写入六类型擦除什么是类型擦除的泛型是通过类型擦除实现的这意味着泛型信息只在编译时存在在运行时会被擦除所有的泛型参数都会被替换为它们的边界类型如果没有边界则替换为源代码编译后的字节码伪代码被擦除为如果编译后被擦除为边界类型类型擦除的影响不能使用检查泛型类型编译错误合法但失去了类型信息不能创建泛型数组以下代码都不合法编译错误编译错误可以创建通配符数组但不安全合法但不推荐不能抛出或捕获泛型类的实例以下代码不合法编译错误不能重载具有相同擦除类型的方法以下代码不合法因为擦除后都是相同的签名编译错误方法签名冲突桥方法类型擦除可能导致方法签名不匹配编译器会生成桥方法来保持多态性父类子类重写父类方法编译后编译器会生成桥方法编译器生成的桥方法伪代码重写的方法桥方法保持多态性调用重写的方法七泛型的实际应用场景集合框架集合框架是泛型最典型的应用类型安全的集合避免了类型转换和运行时错误不需要强制转换通用工具类交换数组中的两个元素查找数组中的最大值设计模式中的应用工厂模式建造者模式八常见问题和注意事项原始类型原始类型是指不使用泛型参数的泛型类应该避免使用原始类型不推荐推荐方式使用原始类型会失去类型安全检查可能引发静态成员不能使用类型参数编译错误编译错误合法泛型方法合法原因静态成员属于类而不属于实例但类型参数属于实例层面基本类型不能作为类型参数编译错误必须使用包装类型类型推断的限制在某些情况下编译器无法推断类型需要显式指定类型推断失败需要显式指定或者泛型与重载由于类型擦除不能仅通过泛型参数的不同来重载方法编译错误方法签名相同擦除后都是合法类型参数不同通配符类型不同九获取泛型信息反射虽然运行时类型被擦除但可以通过反射获取某些泛型信息如字段方法参数的泛型信息实际类型参数反射反射获取对象类的方式类名编译器就确定不会触发类初始化不执行语句对象运行期获取先存在对象再获取类一定会触发类初始化全限定类名运行期动态获取默认触发类初始化如果类不存在会抛出通过加载只加载不初始化不会执行块',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-12-31 16:40:20',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">Hexo</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> Newest Comments</span></div><div class="aside-list"><span>loading...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/java/" style="font-size: 1.05rem;">java<sup>2</sup></a><a href="/tags/leetcode/" style="font-size: 1.05rem;">leetcode<sup>5</sup></a><a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 1.05rem;">分布式<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 1.05rem;">数据库<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 1.05rem;">算法<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/" style="font-size: 1.05rem;">网络安全<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>Archives</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/12/"><span class="card-archive-list-date">December 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">8</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/09/"><span class="card-archive-list-date">September 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/08/"><span class="card-archive-list-date">August 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">27</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url">数据结构</a><i class="anzhiyufont anzhiyu-icon-angle-right post-meta-separator"></i><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/java/" itemprop="url">java</a></span><span class="article-meta tags"></span></div></div><h1 class="post-title" itemprop="name headline">java基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-08-11T17:55:16.000Z" title="Created 2025-08-12 01:55:16">2025-08-12</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-12-31T08:40:20.416Z" title="Updated 2025-12-31 16:40:20">2025-12-31</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为长沙"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>长沙</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2025/08/12/Java/java%E5%9F%BA%E7%A1%80/"><header><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url">数据结构</a><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/java/" itemprop="url">java</a><h1 id="CrawlerTitle" itemprop="name headline">java基础</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">John Doe</span><time itemprop="dateCreated datePublished" datetime="2025-08-11T17:55:16.000Z" title="Created 2025-08-12 01:55:16">2025-08-12</time><time itemprop="dateCreated datePublished" datetime="2025-12-31T08:40:20.416Z" title="Updated 2025-12-31 16:40:20">2025-12-31</time></header><h1 id="Java基础知识"><a href="#Java基础知识" class="headerlink" title="Java基础知识"></a>Java基础知识</h1><h2 id="静态方法与非静态成员"><a href="#静态方法与非静态成员" class="headerlink" title="静态方法与非静态成员"></a>静态方法与非静态成员</h2><p>静态方法是属于类的，而非静态成员属于实例对象，前者在类加载的时候就会分配内存，而后者只有在对象实例化之后才会加载，因此静态方法不能访问非静态成员。</p>
<h2 id="可变长参数"><a href="#可变长参数" class="headerlink" title="可变长参数"></a>可变长参数</h2><p>在jdk5后引入，参数后会加上<code>...</code>以表示可变长参数，当一个可变长参数的函数重载另一个函数会后，调用会优先选择范围可定的函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodName</span><span class="params">(Type... parameterName)</span> &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.可变长参数实际上是一个语法糖，编译器在底层会将其转换为数组。</p>
<p>2.例如 <code>String... args</code> 会被编译为 <code>String[] args</code>。</p>
<p>3.调用方法时，可以传递任意数量（包括零个）的参数。</p>
<p>4.可变长参数只能放在普通参数的最后。</p>
<h2 id="面向对象OOP"><a href="#面向对象OOP" class="headerlink" title="面向对象OOP"></a>面向对象OOP</h2><p>三大特点：封装、继承、多态</p>
<p>封装：内部成员隐藏，仅暴露外部方法以供调用</p>
<p>继承：在已定义的类的基础上定义额外的类，提高代码的重用和可扩展性。</p>
<p>1.子类无法继承父类的私有属性和方法</p>
<p>2.子类可以重写父类的方法</p>
<p>多态：一个对象可以存在多种状态。</p>
<p><strong>编译时多态</strong>：方法重载（Overload）。<br><strong>运行时多态</strong>：方法重写（Override）—— 这是多态的核心和精髓。</p>
<h2 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h2><ul>
<li><strong>实例化</strong>：接口和抽象类都不能直接实例化，只能被实现（接口）或继承（抽象类）后才能创建具体的对象。</li>
<li><strong>抽象方法</strong>：接口和抽象类都可以包含抽象方法。抽象方法没有方法体，必须在子类或实现类中实现。</li>
</ul>
<table>
<thead>
<tr>
<th align="left">维度</th>
<th align="left">接口 (Interface)</th>
<th align="left">抽象类 (Abstract Class)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>继承</strong></td>
<td align="left">实现多个接口</td>
<td align="left">只能继承一个抽象类</td>
</tr>
<tr>
<td align="left"><strong>方法</strong></td>
<td align="left">抽象方法、默认方法、静态方法</td>
<td align="left">抽象方法和具体方法</td>
</tr>
<tr>
<td align="left"><strong>变量</strong></td>
<td align="left">只能是常量</td>
<td align="left">可以是普通变量</td>
</tr>
<tr>
<td align="left"><strong>构造器</strong></td>
<td align="left">无</td>
<td align="left">有</td>
</tr>
<tr>
<td align="left"><strong>设计目标</strong></td>
<td align="left">定义契约和能力</td>
<td align="left">代码复用和部分实现</td>
</tr>
<tr>
<td align="left"><strong>访问修饰符</strong></td>
<td align="left">默认public</td>
<td align="left">可以是protected、private等</td>
</tr>
</tbody></table>
<h2 id="Final关键字"><a href="#Final关键字" class="headerlink" title="Final关键字"></a>Final关键字</h2><h3 id="Final修饰的类"><a href="#Final修饰的类" class="headerlink" title="Final修饰的类"></a>Final修饰的类</h3><p><strong>作用</strong>：表示这个类<strong>不能被继承</strong>，即不能有子类。</p>
<p><strong>特点</strong>：1.这个类所有方法都不能重写，因为没有子类；2.这个类中的变量不一定是final的</p>
<h3 id="Final修饰的方法"><a href="#Final修饰的方法" class="headerlink" title="Final修饰的方法"></a>Final修饰的方法</h3><p><strong>作用</strong>：表示这个方法<strong>不能被子类重写</strong>(Override)。</p>
<p><strong>特点</strong>：1.可以用于修饰静态方法和实例方法；2.private是隐式final的，因为无法被继承，也就没有重写；3.final方法可以被Overload</p>
<h3 id="Final修饰的变量"><a href="#Final修饰的变量" class="headerlink" title="Final修饰的变量"></a>Final修饰的变量</h3><h4 id="1-final修饰基本类型变量"><a href="#1-final修饰基本类型变量" class="headerlink" title="1. final修饰基本类型变量"></a>1. final修饰基本类型变量</h4><p><strong>作用</strong>：表示这个变量的值<strong>一旦初始化就不能被修改</strong>（即成为常量）。</p>
<h4 id="2-final修饰引用类型变量"><a href="#2-final修饰引用类型变量" class="headerlink" title="2. final修饰引用类型变量"></a>2. final修饰引用类型变量</h4><p><strong>作用</strong>：表示这个引用<strong>不能再指向其他对象</strong>，但对象本身的内容可以被修改。</p>
<h4 id="3-final修饰成员变量"><a href="#3-final修饰成员变量" class="headerlink" title="3. final修饰成员变量"></a>3. final修饰成员变量</h4><p><strong>特点</strong>：1.必须在声明时或构造方法中初始化；2.一旦初始化后就不能再修改。</p>
<h3 id="Final的内存特点"><a href="#Final的内存特点" class="headerlink" title="Final的内存特点"></a>Final的内存特点</h3><p>1.Final修饰的变量在初始化完成后对其他线程可见。</p>
<p>2.阻止内存重排。</p>
<p>3.用于实现线程安全不可变关键。</p>
<h2 id="浅拷贝、深拷贝与引用拷贝"><a href="#浅拷贝、深拷贝与引用拷贝" class="headerlink" title="浅拷贝、深拷贝与引用拷贝"></a>浅拷贝、深拷贝与引用拷贝</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://oss.javaguide.cn/github/javaguide/java/basis/shallow&deep-copy.png" alt="shallow&amp;deep-copy"></p>
<h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>创建一个新对象，然后将原对象的<strong>非静态字段</strong>的值逐个复制到新对象。</p>
<ul>
<li><p>如果字段是<strong>基本类型</strong>，则复制其值。</p>
</li>
<li><p>如果字段是<strong>引用类型</strong>，则复制其<strong>内存地址</strong>（即引用），而不是引用的对象本身。</p>
</li>
</ul>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>创建一个新对象，同时递归地创建原对象中所有引用类型字段所指向的对象的副本。结果是两个完全独立的对象，没有任何共享的内部状态。</p>
<h3 id="引用拷贝"><a href="#引用拷贝" class="headerlink" title="引用拷贝"></a>引用拷贝</h3><p>创建一个新的变量名，实际上指向的还是原来的对象引用地址。</p>
<h2 id="String，StringBuilder和StringBuffer"><a href="#String，StringBuilder和StringBuffer" class="headerlink" title="String，StringBuilder和StringBuffer"></a>String，StringBuilder和StringBuffer</h2><h3 id="String不可变"><a href="#String不可变" class="headerlink" title="String不可变"></a>String不可变</h3><p>String是一个final修饰的对象，final关键字强调了该引用不可变。</p>
<p>在JDK的主要实现中，String底层是一个char[]。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line"><span class="comment">/** String本质是个char数组. 而且用final关键字修饰.*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然final不可变，但是其引用不可变，我们依然可以去修改堆中的内存，但其使用了private修饰，并且没有暴露内部字段。</p>
<p>同时，String有字符串常量池属性，对于相同的字符串，它们都指向堆的同一个内存地址，如果String是可变的话，这就没有意义了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;111&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;111&quot;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="Error-和-Exception"><a href="#Error-和-Exception" class="headerlink" title="Error 和 Exception"></a>Error 和 Exception</h2><p>所有的异常都继承于<code>java.lang.Throwable</code>，其有两个子类</p>
<ul>
<li>Exception：程序本身可以处理的异常，可以通过<code>catch</code>进行捕获。Exception又分为Checked和Unchecked异常</li>
<li>Error：属于程序无法处理的，不建议通过catch来捕获，因为捕获了后续也没法处理，例如无法恢复现场，不能保证系统能安全恢复，通常只是能打印日志或做一些清理工作。如<code>OutOfMemoryError</code>,<code>Virtual MachineError</code>,<code>NoClassDefFoundError</code>等</li>
</ul>
<h3 id="Checked-Exception和Unchecked-Exception"><a href="#Checked-Exception和Unchecked-Exception" class="headerlink" title="Checked Exception和Unchecked Exception"></a>Checked Exception和Unchecked Exception</h3><p><strong>Checked Exception</strong> 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>或者<code>throws</code> 关键字处理的话，就没办法通过编译。最常见的如FileNotFoundException，强制要求在编译阶段就对其进行catch或者throws，否则编译无法通过。</p>
<p>除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于受检查异常 。常见的受检查异常有：IO 相关的异常、<code>ClassNotFoundException</code>、<code>SQLException</code>…。</p>
<p><strong>Unchecked Exception</strong> 即 <strong>不受检查异常</strong> ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</p>
<p><code>RuntimeException</code> 及其子类都统称为非受检查异常，常见的有（建议记下来，日常开发中会经常用到）：</p>
<ul>
<li><code>NullPointerException</code>(空指针错误)</li>
<li><code>IllegalArgumentException</code>(参数错误比如方法入参类型错误)</li>
<li><code>NumberFormatException</code>（字符串转换为数字格式错误，<code>IllegalArgumentException</code>的子类）</li>
<li><code>ArrayIndexOutOfBoundsException</code>（数组越界错误）</li>
<li><code>ClassCastException</code>（类型转换错误）</li>
<li><code>ArithmeticException</code>（算术错误）</li>
<li><code>SecurityException</code> （安全错误比如权限不够）</li>
<li><code>UnsupportedOperationException</code>(不支持的操作错误比如重复创建同一用户)</li>
</ul>
<p>这些异常无法在编译阶段被感知到，因此只有在运行时才能捕获这些异常</p>
<h3 id="throwable-类常用方法有哪些"><a href="#throwable-类常用方法有哪些" class="headerlink" title="throwable-类常用方法有哪些"></a>throwable-类常用方法有哪些</h3><ul>
<li><code>String getMessage()</code>: 返回异常发生时的详细信息</li>
<li><code>String toString()</code>: 返回异常发生时的简要描述</li>
<li><code>String getLocalizedMessage()</code>: 返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage()</code>返回的结果相同</li>
<li><code>void printStackTrace()</code>: 在控制台上打印 <code>Throwable</code> 对象封装的异常信息</li>
</ul>
<h3 id="try-catch-finally-如何使用"><a href="#try-catch-finally-如何使用" class="headerlink" title="try-catch-finally-如何使用"></a>try-catch-finally-如何使用</h3><ul>
<li><code>try</code>块：用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。</li>
<li><code>catch</code>块：用于处理 try 捕获到的异常。</li>
<li><code>finally</code> 块：无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</li>
</ul>
<blockquote>
<p>如果try语句里有return，返回的是try语句块中变量值。<br>详细执行过程如下：<br>a.如果有返回值，就把返回值保存到局部变量中；<br>b.执行jsr指令跳到finally语句里执行；<br>c.执行完finally语句后，返回之前保存在局部变量表里的值。<br>**如果try，finally语句里均有return，忽略try的return，而使用finally的return.</p>
</blockquote>
<h3 id="finally中的代码一定会被执行吗？"><a href="#finally中的代码一定会被执行吗？" class="headerlink" title="finally中的代码一定会被执行吗？"></a>finally中的代码一定会被执行吗？</h3><p>finally中的代码在虚拟机被终止时，finally中的代码就不会被执行。</p>
<h3 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h3><p><code>try-with-resources</code> 其实是一个语法糖，其目的是自动、安全地关闭实现了 <code>AutoCloseable</code>（或 <code>Closeable</code>）的资源，替代手写的 <code>try...finally</code> 关闭资源，避免资源泄漏并且正确处理关闭时抛出的异常。</p>
<h4 id="语法示例"><a href="#语法示例" class="headerlink" title="语法示例"></a>语法示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try (InputStream in = new FileInputStream(&quot;file.txt&quot;)) &#123;</span><br><span class="line">    // 使用 in</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    // 处理读取异常</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以声明多个资源，用分号分隔：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try (</span><br><span class="line">    InputStream in = new FileInputStream(&quot;a&quot;);</span><br><span class="line">    OutputStream out = new FileOutputStream(&quot;b&quot;)</span><br><span class="line">) &#123;</span><br><span class="line">    // body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="资源类型与可用性"><a href="#资源类型与可用性" class="headerlink" title="资源类型与可用性"></a>资源类型与可用性</h4><ul>
<li>资源类型必须实现 <code>java.lang.AutoCloseable</code>（<code>java.io.Closeable</code> 也可以，因为它继承自 <code>AutoCloseable</code>）。</li>
<li><code>AutoCloseable.close()</code> 声明为 <code>throws Exception</code>，而 <code>Closeable.close()</code> 声明为 <code>throws IOException</code>。因此如果资源的 <code>close()</code> 抛出受检异常，调用方法必须声明或捕获该异常。</li>
</ul>
<h4 id="Java-7-vs-Java-9-的差别（重要）"><a href="#Java-7-vs-Java-9-的差别（重要）" class="headerlink" title="Java 7 vs Java 9 的差别（重要）"></a>Java 7 vs Java 9 的差别（重要）</h4><ul>
<li><p>Java 7&#x2F;8：资源必须在 <code>try(...)</code> 中声明（即在括号内创建变量）。</p>
</li>
<li><p>Java 9+：允许把<strong>已经存在的 final 或 *effectively final* 本地变量</strong>放入 <code>try</code> 的括号中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader br = new BufferedReader(...);</span><br><span class="line">// br 必须在此之后不再被修改（effectively final）</span><br><span class="line">try (br) &#123;</span><br><span class="line">    // use br</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="资源关闭的顺序"><a href="#资源关闭的顺序" class="headerlink" title="资源关闭的顺序"></a>资源关闭的顺序</h4><ul>
<li>创建顺序：左到右。</li>
<li>关闭顺序：<strong>反向</strong>（右到左）。也就是最后创建的资源最先关闭。</li>
</ul>
<h4 id="异常处理：主异常与-suppressed（关键点）"><a href="#异常处理：主异常与-suppressed（关键点）" class="headerlink" title="异常处理：主异常与 suppressed（关键点）"></a>异常处理：主异常与 suppressed（关键点）</h4><ul>
<li>如果 try 块中抛出了异常 A，而在关闭资源时抛出了异常 B，那么：<ul>
<li>异常 A 是<strong>主异常</strong>（会被抛出）。</li>
<li>关闭时抛出的异常 B 会被作为被抑制异常（suppressed）加入主异常：<code>A.addSuppressed(B)</code>。</li>
</ul>
</li>
<li>如果 try 块没有异常，但关闭时抛出异常，则该关闭异常成为主异常并被抛出。</li>
<li>你可以通过 <code>Throwable[] t.getSuppressed()</code> 获取被抑制的异常；在打印栈跟踪时 JVM 也会显示 suppressed 列表。</li>
</ul>
<p>示例（演示 suppressed）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class R implements AutoCloseable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void close() throws Exception &#123;</span><br><span class="line">        throw new Exception(&quot;close failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    try (R r = new R()) &#123;</span><br><span class="line">        throw new Exception(&quot;try failed&quot;);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        System.out.println(&quot;Primary: &quot; + e.getMessage());</span><br><span class="line">        for (Throwable s : e.getSuppressed()) &#123;</span><br><span class="line">            System.out.println(&quot;Suppressed: &quot; + s.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Primary: try failed</span><br><span class="line">Suppressed: close failed</span><br></pre></td></tr></table></figure>

<h4 id="编译器如何“糖化”为-try-finally（反糖化示例）"><a href="#编译器如何“糖化”为-try-finally（反糖化示例）" class="headerlink" title="编译器如何“糖化”为 try-finally（反糖化示例）"></a>编译器如何“糖化”为 try-finally（反糖化示例）</h4><p>单资源的近似编译后形式（示意）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">MyResource r = new MyResource();</span><br><span class="line">Throwable primaryExc = null;</span><br><span class="line">try &#123;</span><br><span class="line">    // try-body</span><br><span class="line">&#125; catch (Throwable t) &#123;</span><br><span class="line">    primaryExc = t;</span><br><span class="line">    throw t;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    if (r != null) &#123;</span><br><span class="line">        if (primaryExc != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                r.close();</span><br><span class="line">            &#125; catch (Throwable closeExc) &#123;</span><br><span class="line">                primaryExc.addSuppressed(closeExc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            r.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意重点：如果主异常存在，<code>close()</code> 抛出的异常不会覆盖它，而是被 <code>addSuppressed</code>；如果没有主异常，<code>close()</code> 抛出的异常会向上抛出。</li>
<li>对于多个资源，编译器会按资源个数生成嵌套的类似逻辑，最终达到“反向关闭并抑制”的效果。</li>
<li>编译器还会在调用 <code>close()</code> 前检查资源是否为 <code>null</code>（因此如果资源变量为 <code>null</code>，不会 NPE）。</li>
</ul>
<h4 id="关于-null-资源"><a href="#关于-null-资源" class="headerlink" title="关于 null 资源"></a>关于 null 资源</h4><ul>
<li>如果资源表达式结果是 <code>null</code>，编译器生成的代码会检查并跳过关闭（不会调用 <code>close()</code> 导致 NPE）。</li>
</ul>
<h4 id="结合-catch-finally"><a href="#结合-catch-finally" class="headerlink" title="结合 catch &#x2F; finally"></a>结合 catch &#x2F; finally</h4><ul>
<li><code>try-with-resources</code> 支持 <code>catch</code> 和 <code>finally</code>：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try (R r = ...) &#123;</span><br><span class="line">   // body</span><br><span class="line">&#125; catch (SomeException e) &#123;</span><br><span class="line">   // 处理</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">   // 最后仍然会在这里执行（close 已在 try 退出时调用）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>finally</code> 中的代码在资源关闭之后执行（因为关闭是在隐式 finally 中完成的 —— 但语义上资源关闭是在 try 退出后、外层 finally 执行前完成）。</li>
</ul>
<h4 id="常见误区与注意点（实务建议）"><a href="#常见误区与注意点（实务建议）" class="headerlink" title="常见误区与注意点（实务建议）"></a>常见误区与注意点（实务建议）</h4><ol>
<li><strong>不要在 close() 中做复杂的恢复逻辑</strong>——close 应该尽量简洁、幂等；如果 close 失败会抑制真正的业务异常，排查会麻烦。</li>
<li><strong>处理 suppressed</strong>：日志或错误处理时，最好记录主异常和 <code>getSuppressed()</code> 的内容，避免失去关键信息。</li>
<li><strong>不要捕获 <code>Error</code> 或 <code>Throwable</code>（除非框架层）</strong>：业务代码应捕获可恢复的异常类型；框架&#x2F;容器可能会用 <code>catch(Throwable)</code> 做最后兜底并记录日志。</li>
<li><strong>JDBC 的使用</strong>：<code>Connection</code>, <code>Statement</code>, <code>ResultSet</code> 从 JDBC 4.1 起都实现了 <code>AutoCloseable</code>，推荐在 try-with-resources 中使用，确保按逆序关闭。</li>
<li><strong>方法签名注意</strong>：如果资源的 <code>close()</code> 声明抛出受检异常，那么 enclosing 方法如果不捕获这些异常就需要声明相应的 throws。</li>
</ol>
<h4 id="进阶示例（多资源、Java9-语法、锁释放包装器）"><a href="#进阶示例（多资源、Java9-语法、锁释放包装器）" class="headerlink" title="进阶示例（多资源、Java9 语法、锁释放包装器）"></a><strong>进阶示例</strong>（多资源、Java9 语法、锁释放包装器）</h4><p>多资源（关闭顺序：out -&gt; in）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">try (InputStream in = new FileInputStream(&quot;a&quot;);</span><br><span class="line">     OutputStream out = new FileOutputStream(&quot;b&quot;)) &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java 9+, 使用已声明变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader br = new BufferedReader(new FileReader(&quot;f&quot;));</span><br><span class="line">try (br) &#123; // br 必须是 effectively final</span><br><span class="line">    System.out.println(br.readLine());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把 <code>ReentrantLock</code> 用作 try-with-resources（包装成 AutoCloseable）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class LockWrapper implements AutoCloseable &#123;</span><br><span class="line">    private final ReentrantLock lock;</span><br><span class="line">    LockWrapper(ReentrantLock lock) &#123;</span><br><span class="line">        this.lock = lock; lock.lock();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void close() &#123; lock.unlock(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用：</span><br><span class="line">ReentrantLock lock = new ReentrantLock();</span><br><span class="line">try (LockWrapper lw = new LockWrapper(lock)) &#123;</span><br><span class="line">    // 在这里持有 lock</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实践建议（短句）"><a href="#实践建议（短句）" class="headerlink" title="实践建议（短句）"></a>实践建议（短句）</h4><ul>
<li>优先使用 <code>try-with-resources</code> 来管理流、文件、数据库连接等资源。</li>
<li>在需要记录或转发异常时，注意同时查看 <code>getSuppressed()</code>。</li>
<li>实现 <code>AutoCloseable</code> 时让 <code>close()</code> 简单且幂等，尽量不抛出不可预期的异常；若必须抛出，文档清楚标注。</li>
</ul>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="泛型的设计目的"><a href="#泛型的设计目的" class="headerlink" title="泛型的设计目的"></a>泛型的设计目的</h3><p>在java1.5之前，没有泛型的设计，导致所有的集合容器存放的都是Object型，使用时必须进行强制类型转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String) list.get(<span class="number">0</span>); <span class="comment">// 需要强转</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行时容易出错，出现<code>ClassCastException</code></p>
<p>因此引入了泛型，能够提供：</p>
<ol>
<li>编译时的类型检查</li>
<li>消除类型强制转换</li>
<li>可读性更好</li>
</ol>
<h3 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h3><p>java的泛型本质是伪泛型，只会在编译时进行泛型的类型检查，而在运行时会进行泛型擦除，编译器在使用泛型的<code>get()</code>方法前，会插入<code>(&lt;T&gt;)</code>进行类型转换，意味JVM在运行时实际上无法获得泛型信息，<code>List&lt;String&gt;</code>和<code>List&lt;Integer&gt;</code>在JVM看来实际上都是都是<code>List</code>。</p>
<p>由于在运行时JVM没有泛型信息，我们不能在运行时进行类型判断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (list <span class="keyword">instanceof</span> List&lt;String&gt;) &#123;&#125; <span class="comment">// 编译错误</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>也不能创建泛型类型数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] arr = <span class="keyword">new</span> <span class="title class_">List</span>&lt;String&gt;[<span class="number">10</span>]; <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure>

<h3 id="泛型边界与通配符"><a href="#泛型边界与通配符" class="headerlink" title="泛型边界与通配符"></a>泛型边界与通配符</h3><h4 id="上界-extends"><a href="#上界-extends" class="headerlink" title="上界 extends"></a>上界 extends</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; &#123;  <span class="comment">// T 必须是 Number 或其子类</span></span><br><span class="line">    T value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上界的extends能够确定当前泛型T所继承的父类，也就是说T一定是其子类</p>
<h4 id="下界-super"><a href="#下界-super" class="headerlink" title="下界 super"></a>下界 super</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="built_in">super</span> Integer&gt; list; <span class="comment">// 可以存放 Integer 及其子类，但取出时只保证是 Object</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下界的super能够确定当前泛型T所拥有的子类，也就是说T一定是其父类</p>
<h4 id="无界通配符"><a href="#无界通配符" class="headerlink" title="无界通配符"></a>无界通配符</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void printList(List&lt;?&gt; list) &#123;</span><br><span class="line">    for (Object o : list) &#123;</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="PECS原则-Producer-Extends-Consumer-Super"><a href="#PECS原则-Producer-Extends-Consumer-Super" class="headerlink" title="PECS原则(Producer Extends, Consumer Super)"></a>PECS原则(Producer Extends, Consumer Super)</h4><p>上界意味着你能确定当前泛型T，一定是某个类的子类，能够安全地读出，意味着可以用父类来接受它，例如<T extends Number>可以用Number这个父类来接受，但是不能安全地写入，因为无法判断其是什么具体类，是Integer还是Double。</p>
<p>而下界作为某个类的父类，能够安全的写入，因为至少能够写入Integer，最基础的类，而不能安全的读出，取出时只能保证其是超类Object自身或者其子类。</p>
<h3 id="协变-逆变"><a href="#协变-逆变" class="headerlink" title="协变&#x2F;逆变"></a>协变&#x2F;逆变</h3><p>java的泛型没有协变&#x2F;逆变，因此不能写如下的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Number&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(); <span class="comment">// 编译错误</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>必须使用通配符表达：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(); <span class="comment">// 合法</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="泛型擦除-1"><a href="#泛型擦除-1" class="headerlink" title="泛型擦除"></a>泛型擦除</h3><p>由于jvm在运行时会进行泛型擦除，因此想要获得具体的泛型信息，需要借助反射和<code>type</code>的API</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> MyClass.class.getDeclaredField(<span class="string">&quot;list&quot;</span>);</span><br><span class="line"><span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> f.getGenericType();  <span class="comment">// 可能是 ParameterizedType</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p><strong>基本类型不能作为泛型参数</strong></p>
<ul>
<li><code>List&lt;int&gt;</code> 不合法，必须用 <code>Integer</code>。</li>
</ul>
<p><strong>静态变量不能使用类型参数</strong></p>
<ul>
<li>因为泛型参数属于实例层面，不属于类层面。</li>
</ul>
<p><strong>泛型类不能直接创建泛型数组</strong></p>
<p><strong>类型擦除导致的桥方法 (Bridge Method)</strong><br> 如果泛型方法在子类中被重写，编译器可能生成桥方法保证多态一致。</p>
<p><strong>在 API 设计中，用通配符表达灵活性（PECS 原则）。</strong></p>
<p><strong>在内部实现时，用确切的类型参数，减少歧义。</strong></p>
<p><strong>避免原生类型（raw type）<code>List list</code>，这样会失去泛型检查。</strong></p>
<p><strong>在必要时使用 <code>@SuppressWarnings(&quot;unchecked&quot;)</code>，但要小心</strong>。</p>
<p><strong>写工具类时优先考虑泛型方法，而不是泛型类。</strong></p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>简单来说，Java 反射 (Reflection) 是一种<strong>在程序运行时，动态地获取类的信息并操作类或对象（方法、属性）的能力</strong>。</p>
<p>通常情况下，我们写的代码在编译时类型就已经确定了，要调用哪个方法、访问哪个字段都是明确的。但反射允许我们在<strong>运行时</strong>才去探知一个类有哪些方法、哪些属性、它的构造函数是怎样的，甚至可以动态地创建对象、调用方法或修改属性，哪怕这些方法或属性是私有的。</p>
<p>正是这种在运行时“反观自身”并进行操作的能力，使得反射成为许多<strong>通用框架和库的基石</strong>。它让代码更加灵活，能够处理在编译时未知的类型。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p><strong>灵活性和动态性</strong>：反射允许程序在运行时动态地加载类、创建对象、调用方法和访问字段。这样可以根据实际需求（如配置文件、用户输入、注解等）动态地适应和扩展程序的行为，显著提高了系统的灵活性和适应性。</p>
<p><strong>框架开发的基础</strong>：许多现代 Java 框架（如 Spring、Hibernate、MyBatis）都大量使用反射来实现依赖注入（DI）、面向切面编程（AOP）、对象关系映射（ORM）、注解处理等核心功能。反射是实现这些“魔法”功能不可或缺的基础工具。</p>
<p><strong>解耦合和通用性</strong>：通过反射，可以编写更通用、可重用和高度解耦的代码，降低模块之间的依赖。例如，可以通过反射实现通用的对象拷贝、序列化、Bean 工具等。</p>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p><strong>性能开销</strong>：反射操作通常比直接代码调用要慢。因为涉及到动态类型解析、方法查找以及 JIT 编译器的优化受限等因素。不过，对于大多数框架场景，这种性能损耗通常是可以接受的，或者框架本身会做一些缓存优化。</p>
<p><strong>安全性问题</strong>：反射可以绕过 Java 语言的访问控制机制（如访问 <code>private</code> 字段和方法），破坏了封装性，可能导致数据泄露或程序被恶意篡改。此外，还可以绕过泛型检查，带来类型安全隐患。</p>
<p><strong>代码可读性和维护性</strong>：过度使用反射会使代码变得复杂、难以理解和调试。错误通常在运行时才会暴露，不像编译期错误那样容易发现。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol>
<li><p>DI和IOC：以 Spring&#x2F;Spring Boot 为代表的 IoC 框架，会在启动时扫描带有特定注解（如 <code>@Component</code>, <code>@Service</code>, <code>@Repository</code>, <code>@Controller</code>）的类，利用反射实例化对象（Bean），并通过反射注入依赖（如 <code>@Autowired</code>、构造器注入等）。</p>
</li>
<li><p>注解处理：框架通过反射检查类、方法、字段上有没有特定的注解，然后根据注解信息执行相应的逻辑。比如，看到 <code>@Value</code>，就用反射读取注解内容，去配置文件找对应的值，再用反射把值设置给字段。</p>
</li>
<li><p>动态代理和AOP：JDK 自带的动态代理（Proxy 和 InvocationHandler）就离不开反射。代理对象在内部调用真实对象的方法时，就是通过反射的 <code>Method.invoke</code> 来完成的。</p>
</li>
<li><p>ORM关系对象映射：ORM通过反射获取 Java 类的属性列表，然后把查询结果按名字或配置对应起来，再用反射调用 setter 或直接修改字段值。反过来，保存对象到数据库时，也是用反射读取属性值来拼 SQL。</p>
</li>
</ol>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p><code>Annotation</code> （注解） 是 Java5 开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。</p>
<p>注解本质是一个继承了<code>Annotation</code> 的特殊接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Override</span> <span class="keyword">extends</span> <span class="title class_">Annotation</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解只有被解析之后才会生效，常见的解析方法有两种：</p>
<ul>
<li><strong>编译期直接扫描</strong>：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用<code>@Override</code> 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li>
<li><strong>运行期通过反射处理</strong>：像框架中自带的注解(比如 Spring 框架的 <code>@Value</code>、<code>@Component</code>)都是通过反射来进行处理的。</li>
</ul>
<h2 id="SPI和API"><a href="#SPI和API" class="headerlink" title="SPI和API"></a>SPI和API</h2><p>当实现方提供了接口和实现，我们可以通过调用实现方的接口从而拥有实现方给我们提供的能力，这就是 <strong>API</strong>。这种情况下，接口和实现都是放在实现方的包中。调用方通过接口调用实现方的功能，而不需要关心具体的实现细节。</p>
<p>当接口存在于调用方这边时，这就是 <strong>SPI</strong> 。由接口调用方确定接口规则，然后由不同的厂商根据这个规则对这个接口进行实现，从而提供服务。</p>
<h2 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h2><ul>
<li><strong>序列化</strong>：将数据结构或对象转换成可以存储或传输的形式，通常是二进制字节流，也可以是 JSON, XML 等文本格式，即对象-&gt;JSON。</li>
<li><strong>反序列化</strong>：将在序列化过程中所生成的数据转换为原始数据结构或者对象的过程，即JSON-&gt;对象。</li>
</ul>
<h2 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h2><p>语法糖实际上不是一个真正的语法，只是为了简化某些语法表达而创建的，例如<code>for-each</code>就是一个语法糖，JVM并不能识别语法糖，语法糖只在编译器层面被看见，编译器编译代码为字节码时会调用<code>desugar()</code>来解码语法糖。</p>
<h1 id="Java重要知识"><a href="#Java重要知识" class="headerlink" title="Java重要知识"></a>Java重要知识</h1><h2 id="值传递与引用传递"><a href="#值传递与引用传递" class="headerlink" title="值传递与引用传递"></a>值传递与引用传递</h2><p>Java只有值传递没有引用传递，对于传参，在 Java 方法调用时，<strong>实参的值</strong>会被复制一份，传递给形参。</p>
<ul>
<li>如果参数是 <strong>基本类型</strong>，复制的是 <strong>具体的数值</strong>。</li>
<li>如果参数是 <strong>引用类型</strong>，复制的是 <strong>引用的值</strong>（也就是对象在堆里的地址）。</li>
</ul>
<h3 id="传递基本类型"><a href="#传递基本类型" class="headerlink" title="传递基本类型"></a>传递基本类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        change(x);</span><br><span class="line">        System.out.println(x); <span class="comment">// 还是 5</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">        a = <span class="number">10</span>; <span class="comment">// 只改了副本</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="传递引用复制"><a href="#传递引用复制" class="headerlink" title="传递引用复制"></a>传递引用复制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    Person(String name) &#123; <span class="built_in">this</span>.name = name; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">        change(p);</span><br><span class="line">        System.out.println(p.name); <span class="comment">// 输出 Bob</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(Person x)</span> &#123;</span><br><span class="line">        x.name = <span class="string">&quot;Bob&quot;</span>; <span class="comment">// 修改的是同一个对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="无法改变原引用的值"><a href="#无法改变原引用的值" class="headerlink" title="无法改变原引用的值"></a>无法改变原引用的值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">        reassign(p);</span><br><span class="line">        System.out.println(p.name); <span class="comment">// 还是 Alice</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reassign</span><span class="params">(Person x)</span> &#123;</span><br><span class="line">        x = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Charlie&quot;</span>); <span class="comment">// x 指向新对象，但不影响外部的 p</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>真正的引用传递可以修改调用者的变量绑定。</p>
<h2 id="泛型-通配符详解"><a href="#泛型-通配符详解" class="headerlink" title="泛型&amp;通配符详解"></a>泛型&amp;通配符详解</h2><h3 id="一、泛型的基本概念"><a href="#一、泛型的基本概念" class="headerlink" title="一、泛型的基本概念"></a>一、泛型的基本概念</h3><p>泛型（Generics）是Java 5引入的特性，允许在定义类、接口和方法时使用类型参数（Type Parameter），使得类型可以作为参数传递，提供了编译时的类型安全检查和代码重用。</p>
<h4 id="1-1-为什么需要泛型"><a href="#1-1-为什么需要泛型" class="headerlink" title="1.1 为什么需要泛型"></a>1.1 为什么需要泛型</h4><p>在Java 5之前，容器类（如List、Set、Map）只能存储Object类型，使用时需要进行强制类型转换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">list.add(<span class="number">123</span>);  <span class="comment">// 编译时不会报错</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String) list.get(<span class="number">0</span>);  <span class="comment">// 需要强制转换</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> (Integer) list.get(<span class="number">1</span>);  <span class="comment">// 运行时可能抛出ClassCastException</span></span><br></pre></td></tr></table></figure>

<p>泛型的引入解决了以下问题：</p>
<ul>
<li><strong>类型安全</strong>：在编译时进行类型检查，避免运行时类型转换异常</li>
<li><strong>消除强制转换</strong>：代码更加简洁，不需要频繁进行类型转换</li>
<li><strong>提高代码可读性</strong>：代码意图更加明确，<code>List&lt;String&gt;</code>比<code>List</code>更清晰</li>
</ul>
<h3 id="二、泛型的基本用法"><a href="#二、泛型的基本用法" class="headerlink" title="二、泛型的基本用法"></a>二、泛型的基本用法</h3><h4 id="2-1-泛型类"><a href="#2-1-泛型类" class="headerlink" title="2.1 泛型类"></a>2.1 泛型类</h4><p>泛型类是指在定义类时使用类型参数的类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义泛型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用泛型类</span></span><br><span class="line">Box&lt;String&gt; stringBox = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;&gt;();</span><br><span class="line">stringBox.setValue(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> stringBox.getValue();  <span class="comment">// 不需要强制转换</span></span><br><span class="line"></span><br><span class="line">Box&lt;Integer&gt; intBox = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;&gt;();</span><br><span class="line">intBox.setValue(<span class="number">123</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> intBox.getValue();</span><br></pre></td></tr></table></figure>

<h4 id="2-2-泛型接口"><a href="#2-2-泛型接口" class="headerlink" title="2.2 泛型接口"></a>2.2 泛型接口</h4><p>泛型接口与泛型类类似，接口定义时可以使用类型参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(T other)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student other)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age - other.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-泛型方法"><a href="#2-3-泛型方法" class="headerlink" title="2.3 泛型方法"></a>2.3 泛型方法</h4><p>泛型方法可以在非泛型类中定义，方法可以有自己的类型参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Utils</span> &#123;</span><br><span class="line">    <span class="comment">// 泛型方法：类型参数在返回类型之前</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getMiddle</span><span class="params">(T... args)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> args[args.length / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 多个类型参数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; V <span class="title function_">getValue</span><span class="params">(Map&lt;K, V&gt; map, K key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用泛型方法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">middle</span> <span class="operator">=</span> Utils.getMiddle(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);  <span class="comment">// 返回 &quot;b&quot;</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> Utils.getMiddle(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);  <span class="comment">// 返回 3</span></span><br></pre></td></tr></table></figure>

<p><strong>类型推断</strong>：在调用泛型方法时，通常不需要显式指定类型参数，编译器可以根据参数类型自动推断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显式指定类型参数（通常不需要）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> Utils.&lt;String&gt;getMiddle(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型推断（推荐方式）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> Utils.getMiddle(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="三、泛型的类型参数限制"><a href="#三、泛型的类型参数限制" class="headerlink" title="三、泛型的类型参数限制"></a>三、泛型的类型参数限制</h3><h4 id="3-1-类型变量的限制（类型边界）"><a href="#3-1-类型变量的限制（类型边界）" class="headerlink" title="3.1 类型变量的限制（类型边界）"></a>3.1 类型变量的限制（类型边界）</h4><p>可以使用<code>extends</code>关键字限制类型参数必须是指定类的子类或实现指定接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 限制T必须是Number或其子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumberBox</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getDoubleValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value.doubleValue();  <span class="comment">// 可以安全调用Number的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NumberBox&lt;Integer&gt; intBox = <span class="keyword">new</span> <span class="title class_">NumberBox</span>&lt;&gt;();  <span class="comment">// 合法</span></span><br><span class="line">NumberBox&lt;Double&gt; doubleBox = <span class="keyword">new</span> <span class="title class_">NumberBox</span>&lt;&gt;();  <span class="comment">// 合法</span></span><br><span class="line">NumberBox&lt;String&gt; stringBox = <span class="keyword">new</span> <span class="title class_">NumberBox</span>&lt;&gt;();  <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-多个边界"><a href="#3-2-多个边界" class="headerlink" title="3.2 多个边界"></a>3.2 多个边界</h4><p>可以使用<code>&amp;</code>连接多个边界，但类只能有一个，接口可以有多个。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T必须同时是Number的子类和Comparable的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComparableNumber</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Number</span> &amp; Comparable&lt;T&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(ComparableNumber&lt;T&gt; other)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.value.compareTo(other.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-类型参数命名规范"><a href="#3-3-类型参数命名规范" class="headerlink" title="3.3 类型参数命名规范"></a>3.3 类型参数命名规范</h4><ul>
<li><code>T</code> - Type（类型）</li>
<li><code>E</code> - Element（元素，常用于集合）</li>
<li><code>K</code> - Key（键）</li>
<li><code>V</code> - Value（值）</li>
<li><code>N</code> - Number（数字）</li>
<li><code>S, U, V</code> - 第二个、第三个、第四个类型</li>
</ul>
<h3 id="四、通配符（Wildcards）"><a href="#四、通配符（Wildcards）" class="headerlink" title="四、通配符（Wildcards）"></a>四、通配符（Wildcards）</h3><p>通配符用于表示未知类型，提供了更灵活的类型匹配方式。通配符使用<code>?</code>表示。</p>
<h4 id="4-1-无界通配符"><a href="#4-1-无界通配符" class="headerlink" title="4.1 无界通配符 ?"></a>4.1 无界通配符 <code>?</code></h4><p>无界通配符<code>List&lt;?&gt;</code>表示可以接受任何类型的List，但只能读取，不能写入（除了null）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printList</span><span class="params">(List&lt;?&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Object obj : list) &#123;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// list.add(&quot;hello&quot;);  // 编译错误，不能写入</span></span><br><span class="line">    <span class="comment">// list.add(123);      // 编译错误，不能写入</span></span><br><span class="line">    list.add(<span class="literal">null</span>);        <span class="comment">// 唯一可以写入的值是null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; stringList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; intList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">printList(stringList);  <span class="comment">// 合法</span></span><br><span class="line">printList(intList);     <span class="comment">// 合法</span></span><br></pre></td></tr></table></figure>

<p><strong>使用场景</strong>：当方法只需要读取集合中的元素，而不关心具体类型时使用。</p>
<h4 id="4-2-上界通配符-extends-T"><a href="#4-2-上界通配符-extends-T" class="headerlink" title="4.2 上界通配符 ? extends T"></a>4.2 上界通配符 <code>? extends T</code></h4><p>上界通配符<code>List&lt;? extends T&gt;</code>表示可以接受<code>T</code>及其子类型的List。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以接受Number及其子类型的List</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">sum</span><span class="params">(List&lt;? extends Number&gt; numbers)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Number num : numbers) &#123;</span><br><span class="line">        total += num.doubleValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; intList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">List&lt;Double&gt; doubleList = Arrays.asList(<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>);</span><br><span class="line"><span class="type">double</span> <span class="variable">sum1</span> <span class="operator">=</span> sum(intList);     <span class="comment">// 合法</span></span><br><span class="line"><span class="type">double</span> <span class="variable">sum2</span> <span class="operator">=</span> sum(doubleList);  <span class="comment">// 合法</span></span><br></pre></td></tr></table></figure>

<p><strong>特点</strong>：</p>
<ul>
<li><strong>只能读取</strong>：可以安全地读取元素并视为<code>T</code>类型</li>
<li><strong>不能写入</strong>：除了<code>null</code>之外，不能添加任何元素（因为不知道具体是哪个子类型）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"><span class="type">Number</span> <span class="variable">num</span> <span class="operator">=</span> list.get(<span class="number">0</span>);  <span class="comment">// 可以读取</span></span><br><span class="line"><span class="comment">// list.add(new Integer(1));  // 编译错误</span></span><br><span class="line"><span class="comment">// list.add(new Double(1.0)); // 编译错误</span></span><br><span class="line">list.add(<span class="literal">null</span>);            <span class="comment">// 只能添加null</span></span><br></pre></td></tr></table></figure>

<p><strong>原理说明</strong>：假设<code>List&lt;? extends Number&gt; list = new ArrayList&lt;Integer&gt;()</code>，如果允许<code>list.add(new Double(1.0))</code>，就会在<code>ArrayList&lt;Integer&gt;</code>中存入Double，破坏了类型安全。</p>
<h4 id="4-3-下界通配符-super-T"><a href="#4-3-下界通配符-super-T" class="headerlink" title="4.3 下界通配符 ? super T"></a>4.3 下界通配符 <code>? super T</code></h4><p>下界通配符<code>List&lt;? super T&gt;</code>表示可以接受<code>T</code>及其父类型的List。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以接受Integer及其父类型的List</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNumbers</span><span class="params">(List&lt;? <span class="built_in">super</span> Integer&gt; list)</span> &#123;</span><br><span class="line">    list.add(<span class="number">1</span>);</span><br><span class="line">    list.add(<span class="number">2</span>);</span><br><span class="line">    list.add(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Number&gt; numberList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;Object&gt; objectList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">addNumbers(numberList);  <span class="comment">// 合法</span></span><br><span class="line">addNumbers(objectList);  <span class="comment">// 合法</span></span><br></pre></td></tr></table></figure>

<p><strong>特点</strong>：</p>
<ul>
<li><strong>只能写入</strong>：可以安全地添加<code>T</code>及其子类型的元素</li>
<li><strong>读取受限</strong>：只能读取为<code>Object</code>类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="built_in">super</span> Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Number&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>));      <span class="comment">// 可以写入</span></span><br><span class="line">list.add(<span class="number">2</span>);                   <span class="comment">// 可以写入</span></span><br><span class="line"><span class="comment">// Integer i = list.get(0);    // 编译错误</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> list.get(<span class="number">0</span>);      <span class="comment">// 只能读取为Object</span></span><br></pre></td></tr></table></figure>

<p><strong>原理说明</strong>：假设<code>List&lt;? super Integer&gt; list = new ArrayList&lt;Number&gt;()</code>，可以添加Integer，因为Integer是Number的子类；但读取时只能保证是Number的父类Object，无法确定具体类型。</p>
<h3 id="五、PECS原则（Producer-Extends-Consumer-Super）"><a href="#五、PECS原则（Producer-Extends-Consumer-Super）" class="headerlink" title="五、PECS原则（Producer Extends, Consumer Super）"></a>五、PECS原则（Producer Extends, Consumer Super）</h3><p>PECS是使用通配符的重要原则，帮助决定何时使用<code>extends</code>还是<code>super</code>。</p>
<h4 id="5-1-原则说明"><a href="#5-1-原则说明" class="headerlink" title="5.1 原则说明"></a>5.1 原则说明</h4><ul>
<li><strong>Producer Extends（生产者使用extends）</strong>：如果参数是用来<strong>产生&#x2F;提供</strong>元素的（只读），使用<code>? extends T</code></li>
<li><strong>Consumer Super（消费者使用super）</strong>：如果参数是用来<strong>消费&#x2F;接收</strong>元素的（只写），使用<code>? super T</code></li>
</ul>
<h4 id="5-2-实际应用示例"><a href="#5-2-实际应用示例" class="headerlink" title="5.2 实际应用示例"></a>5.2 实际应用示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者：从src读取元素</span></span><br><span class="line"><span class="comment">// 消费者：向dest写入元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(List&lt;? extends T&gt; src, List&lt;? <span class="built_in">super</span> T&gt; dest)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (T item : src) &#123;</span><br><span class="line">        dest.add(item);  <span class="comment">// 从extends读取，向super写入</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; intList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">List&lt;Number&gt; numberList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">copy(intList, numberList);  <span class="comment">// 合法：Integer extends Number</span></span><br></pre></td></tr></table></figure>

<h4 id="5-3-Collections-copy-的实现"><a href="#5-3-Collections-copy-的实现" class="headerlink" title="5.3 Collections.copy()的实现"></a>5.3 Collections.copy()的实现</h4><p>Java标准库中的<code>Collections.copy()</code>方法就是PECS原则的典型应用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(List&lt;? <span class="built_in">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">srcSize</span> <span class="operator">=</span> src.size();</span><br><span class="line">    <span class="keyword">if</span> (srcSize &gt; dest.size())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;Source does not fit in dest&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    ListIterator&lt;? <span class="built_in">super</span> T&gt; di = dest.listIterator();</span><br><span class="line">    ListIterator&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; si = src.listIterator();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; srcSize; i++) &#123;</span><br><span class="line">        di.next();</span><br><span class="line">        di.set(si.next());  <span class="comment">// 从extends读取，向super写入</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="六、类型擦除（Type-Erasure）"><a href="#六、类型擦除（Type-Erasure）" class="headerlink" title="六、类型擦除（Type Erasure）"></a>六、类型擦除（Type Erasure）</h3><h4 id="6-1-什么是类型擦除"><a href="#6-1-什么是类型擦除" class="headerlink" title="6.1 什么是类型擦除"></a>6.1 什么是类型擦除</h4><p>Java的泛型是通过<strong>类型擦除</strong>实现的，这意味着泛型信息只在编译时存在，在运行时会被擦除，所有的泛型参数都会被替换为它们的<strong>边界类型</strong>（如果没有边界，则替换为<code>Object</code>）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(T value)</span> &#123; <span class="built_in">this</span>.value = value; &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getValue</span><span class="params">()</span> &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后的字节码（伪代码）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object value;  <span class="comment">// T被擦除为Object</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(Object value)</span> &#123; <span class="built_in">this</span>.value = value; &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果T extends Number</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumberBox</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumberBox</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Number value;  <span class="comment">// T被擦除为Number（边界类型）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-2-类型擦除的影响"><a href="#6-2-类型擦除的影响" class="headerlink" title="6.2 类型擦除的影响"></a>6.2 类型擦除的影响</h4><p><strong>1. 不能使用instanceof检查泛型类型</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (list <span class="keyword">instanceof</span> List&lt;String&gt;) &#123;  <span class="comment">// 编译错误</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (list <span class="keyword">instanceof</span> List) &#123;  <span class="comment">// 合法，但失去了类型信息</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 不能创建泛型数组</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下代码都不合法</span></span><br><span class="line">List&lt;String&gt;[] array = <span class="keyword">new</span> <span class="title class_">List</span>&lt;String&gt;[<span class="number">10</span>];  <span class="comment">// 编译错误</span></span><br><span class="line">T[] array = <span class="keyword">new</span> <span class="title class_">T</span>[<span class="number">10</span>];  <span class="comment">// 编译错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以创建通配符数组，但不安全</span></span><br><span class="line">List&lt;?&gt;[] array = <span class="keyword">new</span> <span class="title class_">List</span>&lt;?&gt;[<span class="number">10</span>];  <span class="comment">// 合法但不推荐</span></span><br></pre></td></tr></table></figure>

<p><strong>3. 不能抛出或捕获泛型类的实例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下代码不合法</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception&lt;String&gt; e) &#123;  <span class="comment">// 编译错误</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. 不能重载具有相同擦除类型的方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下代码不合法，因为擦除后都是相同的签名</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(List&lt;String&gt; list)</span> &#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(List&lt;Integer&gt; list)</span> &#123; &#125;  <span class="comment">// 编译错误，方法签名冲突</span></span><br></pre></td></tr></table></figure>

<h4 id="6-3-桥方法（Bridge-Method）"><a href="#6-3-桥方法（Bridge-Method）" class="headerlink" title="6.3 桥方法（Bridge Method）"></a>6.3 桥方法（Bridge Method）</h4><p>类型擦除可能导致方法签名不匹配，编译器会生成桥方法来保持多态性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parent</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(T value)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(String value)</span> &#123;  <span class="comment">// 重写父类方法</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译后，编译器会生成桥方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译器生成的桥方法（伪代码）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(String value)</span> &#123;  <span class="comment">// 重写的方法</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 桥方法：保持多态性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">        setValue((String) value);  <span class="comment">// 调用重写的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="七、泛型的实际应用场景"><a href="#七、泛型的实际应用场景" class="headerlink" title="七、泛型的实际应用场景"></a>七、泛型的实际应用场景</h3><h4 id="7-1-集合框架"><a href="#7-1-集合框架" class="headerlink" title="7.1 集合框架"></a>7.1 集合框架</h4><p>Java集合框架是泛型最典型的应用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型安全的集合</span></span><br><span class="line">List&lt;String&gt; stringList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Set&lt;Integer&gt; intSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 避免了类型转换和运行时错误</span></span><br><span class="line">stringList.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> stringList.get(<span class="number">0</span>);  <span class="comment">// 不需要强制转换</span></span><br></pre></td></tr></table></figure>

<h4 id="7-2-通用工具类"><a href="#7-2-通用工具类" class="headerlink" title="7.2 通用工具类"></a>7.2 通用工具类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayUtils</span> &#123;</span><br><span class="line">    <span class="comment">// 交换数组中的两个元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(T[] array, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">temp</span> <span class="operator">=</span> array[i];</span><br><span class="line">        array[i] = array[j];</span><br><span class="line">        array[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找数组中的最大值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; T <span class="title function_">max</span><span class="params">(T[] array)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="literal">null</span> || array.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">T</span> <span class="variable">max</span> <span class="operator">=</span> array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (T item : array) &#123;</span><br><span class="line">            <span class="keyword">if</span> (item.compareTo(max) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                max = item;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-3-设计模式中的应用"><a href="#7-3-设计模式中的应用" class="headerlink" title="7.3 设计模式中的应用"></a>7.3 设计模式中的应用</h4><p><strong>工厂模式</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Factory</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">create</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringFactory</span> <span class="keyword">implements</span> <span class="title class_">Factory</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;default&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>建造者模式</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Builder</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T instance;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Builder&lt;T&gt; <span class="title function_">setInstance</span><span class="params">(T instance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.instance = instance;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="八、常见问题和注意事项"><a href="#八、常见问题和注意事项" class="headerlink" title="八、常见问题和注意事项"></a>八、常见问题和注意事项</h3><h4 id="8-1-原始类型（Raw-Type）"><a href="#8-1-原始类型（Raw-Type）" class="headerlink" title="8.1 原始类型（Raw Type）"></a>8.1 原始类型（Raw Type）</h4><p>原始类型是指不使用泛型参数的泛型类，应该避免使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();  <span class="comment">// 原始类型，不推荐</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  <span class="comment">// 推荐方式</span></span><br></pre></td></tr></table></figure>

<p>使用原始类型会失去类型安全检查，可能引发<code>ClassCastException</code>。</p>
<h4 id="8-2-静态成员不能使用类型参数"><a href="#8-2-静态成员不能使用类型参数" class="headerlink" title="8.2 静态成员不能使用类型参数"></a>8.2 静态成员不能使用类型参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// private static T value;  // 编译错误</span></span><br><span class="line">    <span class="comment">// public static T getValue() &#123; &#125;  // 编译错误</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 合法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(T param)</span> &#123; &#125;  <span class="comment">// 泛型方法合法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原因：静态成员属于类，而不属于实例，但类型参数属于实例层面。</p>
<h4 id="8-3-基本类型不能作为类型参数"><a href="#8-3-基本类型不能作为类型参数" class="headerlink" title="8.3 基本类型不能作为类型参数"></a>8.3 基本类型不能作为类型参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List&lt;int&gt; list;  // 编译错误</span></span><br><span class="line">List&lt;Integer&gt; list;  <span class="comment">// 必须使用包装类型</span></span><br></pre></td></tr></table></figure>

<h4 id="8-4-类型推断的限制"><a href="#8-4-类型推断的限制" class="headerlink" title="8.4 类型推断的限制"></a>8.4 类型推断的限制</h4><p>在某些情况下，编译器无法推断类型，需要显式指定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型推断失败</span></span><br><span class="line">List&lt;String&gt; list = Collections.emptyList();  <span class="comment">// 需要显式指定</span></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">List&lt;String&gt; list = Collections.&lt;String&gt;emptyList();</span><br></pre></td></tr></table></figure>

<h4 id="8-5-泛型与重载"><a href="#8-5-泛型与重载" class="headerlink" title="8.5 泛型与重载"></a>8.5 泛型与重载</h4><p>由于类型擦除，不能仅通过泛型参数的不同来重载方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译错误：方法签名相同（擦除后都是List）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(List&lt;String&gt; list)</span> &#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(List&lt;Integer&gt; list)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合法：类型参数不同</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(List&lt;T&gt; list)</span> &#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(List&lt;?&gt; list)</span> &#123; &#125;  <span class="comment">// 通配符类型不同</span></span><br></pre></td></tr></table></figure>

<h3 id="九、获取泛型信息（反射）"><a href="#九、获取泛型信息（反射）" class="headerlink" title="九、获取泛型信息（反射）"></a>九、获取泛型信息（反射）</h3><p>虽然运行时类型被擦除，但可以通过反射API获取某些泛型信息（如字段、方法参数的泛型信息）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.ParameterizedType;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericInfo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; stringList;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> GenericInfo.class.getDeclaredField(<span class="string">&quot;stringList&quot;</span>);</span><br><span class="line">        <span class="type">Type</span> <span class="variable">type</span> <span class="operator">=</span> field.getGenericType();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">            <span class="type">ParameterizedType</span> <span class="variable">pt</span> <span class="operator">=</span> (ParameterizedType) type;</span><br><span class="line">            Type[] actualTypes = pt.getActualTypeArguments();</span><br><span class="line">            System.out.println(<span class="string">&quot;实际类型参数: &quot;</span> + actualTypes[<span class="number">0</span>]);  <span class="comment">// class java.lang.String</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Java反射"><a href="#Java反射" class="headerlink" title="Java反射"></a>Java反射</h2><h3 id="反射获取对象类的方式"><a href="#反射获取对象类的方式" class="headerlink" title="反射获取对象类的方式"></a>反射获取对象类的方式</h3><h4 id="1-类名-class"><a href="#1-类名-class" class="headerlink" title="1. 类名.class"></a>1. 类名.class</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;String&gt; clazz = String.class;</span><br></pre></td></tr></table></figure>
<ul>
<li>编译器就确定</li>
<li>不会触发类初始化，不执行static语句</li>
</ul>
<h4 id="2-对象-getClass"><a href="#2-对象-getClass" class="headerlink" title="2. 对象.getClass()"></a>2. 对象.getClass()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">Class&lt;? <span class="keyword">extends</span> <span class="title class_">String</span>&gt; clazz = s.getClass();</span><br></pre></td></tr></table></figure>
<ul>
<li>运行期获取</li>
<li>先存在对象，再获取类，一定会触发类初始化</li>
</ul>
<h4 id="3-Class-forName-“全限定类名”"><a href="#3-Class-forName-“全限定类名”" class="headerlink" title="3. Class.forName(“全限定类名”)"></a>3. Class.forName(“全限定类名”)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>运行期动态获取</li>
<li>默认触发类初始化</li>
<li>如果类不存在会抛出<code>ClassNotFoundException</code></li>
</ul>
<h4 id="4-通过ClassLoader加载"><a href="#4-通过ClassLoader加载" class="headerlink" title="4. 通过ClassLoader加载"></a>4. 通过ClassLoader加载</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">Class&lt;?&gt; clazz = cl.loadClass(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>只加载，不初始化</li>
<li>不会执行static块</li>
</ul>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">John Doe</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2025/08/12/Java/java%E5%9F%BA%E7%A1%80/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2025/08/12/Java/java%E5%9F%BA%E7%A1%80/')">java基础</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2025/08/12/Java/java%E5%9F%BA%E7%A1%80/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=java基础&amp;url=http://example.com/2025/08/12/Java/java%E5%9F%BA%E7%A1%80/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"></div></div></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/08/12/Java/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">JVM类加载</div></div></a></div><div class="next-post pull-right"><a href="/2025/08/12/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">多线程</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description"></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">Java基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">1.1.</span> <span class="toc-text">静态方法与非静态成员</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0"><span class="toc-number">1.2.</span> <span class="toc-text">可变长参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1OOP"><span class="toc-number">1.3.</span> <span class="toc-text">面向对象OOP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">1.4.</span> <span class="toc-text">接口和抽象类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.5.</span> <span class="toc-text">Final关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Final%E4%BF%AE%E9%A5%B0%E7%9A%84%E7%B1%BB"><span class="toc-number">1.5.1.</span> <span class="toc-text">Final修饰的类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Final%E4%BF%AE%E9%A5%B0%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.2.</span> <span class="toc-text">Final修饰的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Final%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-number">1.5.3.</span> <span class="toc-text">Final修饰的变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-final%E4%BF%AE%E9%A5%B0%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">1. final修饰基本类型变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-final%E4%BF%AE%E9%A5%B0%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">2. final修饰引用类型变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-final%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">3. final修饰成员变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Final%E7%9A%84%E5%86%85%E5%AD%98%E7%89%B9%E7%82%B9"><span class="toc-number">1.5.4.</span> <span class="toc-text">Final的内存特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E5%BC%95%E7%94%A8%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.6.</span> <span class="toc-text">浅拷贝、深拷贝与引用拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.6.1.</span> <span class="toc-text">浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.6.2.</span> <span class="toc-text">深拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.6.3.</span> <span class="toc-text">引用拷贝</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%EF%BC%8CStringBuilder%E5%92%8CStringBuffer"><span class="toc-number">1.7.</span> <span class="toc-text">String，StringBuilder和StringBuffer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="toc-number">1.7.1.</span> <span class="toc-text">String不可变</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Error-%E5%92%8C-Exception"><span class="toc-number">1.8.</span> <span class="toc-text">Error 和 Exception</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Checked-Exception%E5%92%8CUnchecked-Exception"><span class="toc-number">1.8.1.</span> <span class="toc-text">Checked Exception和Unchecked Exception</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#throwable-%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.8.2.</span> <span class="toc-text">throwable-类常用方法有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#try-catch-finally-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8"><span class="toc-number">1.8.3.</span> <span class="toc-text">try-catch-finally-如何使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#finally%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B8%80%E5%AE%9A%E4%BC%9A%E8%A2%AB%E6%89%A7%E8%A1%8C%E5%90%97%EF%BC%9F"><span class="toc-number">1.8.4.</span> <span class="toc-text">finally中的代码一定会被执行吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#try-with-resources"><span class="toc-number">1.8.5.</span> <span class="toc-text">try-with-resources</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.8.5.1.</span> <span class="toc-text">语法示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8F%AF%E7%94%A8%E6%80%A7"><span class="toc-number">1.8.5.2.</span> <span class="toc-text">资源类型与可用性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-7-vs-Java-9-%E7%9A%84%E5%B7%AE%E5%88%AB%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">1.8.5.3.</span> <span class="toc-text">Java 7 vs Java 9 的差别（重要）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E5%85%B3%E9%97%AD%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.8.5.4.</span> <span class="toc-text">资源关闭的顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%9A%E4%B8%BB%E5%BC%82%E5%B8%B8%E4%B8%8E-suppressed%EF%BC%88%E5%85%B3%E9%94%AE%E7%82%B9%EF%BC%89"><span class="toc-number">1.8.5.5.</span> <span class="toc-text">异常处理：主异常与 suppressed（关键点）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E5%A6%82%E4%BD%95%E2%80%9C%E7%B3%96%E5%8C%96%E2%80%9D%E4%B8%BA-try-finally%EF%BC%88%E5%8F%8D%E7%B3%96%E5%8C%96%E7%A4%BA%E4%BE%8B%EF%BC%89"><span class="toc-number">1.8.5.6.</span> <span class="toc-text">编译器如何“糖化”为 try-finally（反糖化示例）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E-null-%E8%B5%84%E6%BA%90"><span class="toc-number">1.8.5.7.</span> <span class="toc-text">关于 null 资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E5%90%88-catch-finally"><span class="toc-number">1.8.5.8.</span> <span class="toc-text">结合 catch &#x2F; finally</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E8%AF%AF%E5%8C%BA%E4%B8%8E%E6%B3%A8%E6%84%8F%E7%82%B9%EF%BC%88%E5%AE%9E%E5%8A%A1%E5%BB%BA%E8%AE%AE%EF%BC%89"><span class="toc-number">1.8.5.9.</span> <span class="toc-text">常见误区与注意点（实务建议）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6%E7%A4%BA%E4%BE%8B%EF%BC%88%E5%A4%9A%E8%B5%84%E6%BA%90%E3%80%81Java9-%E8%AF%AD%E6%B3%95%E3%80%81%E9%94%81%E9%87%8A%E6%94%BE%E5%8C%85%E8%A3%85%E5%99%A8%EF%BC%89"><span class="toc-number">1.8.5.10.</span> <span class="toc-text">进阶示例（多资源、Java9 语法、锁释放包装器）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B5%E5%BB%BA%E8%AE%AE%EF%BC%88%E7%9F%AD%E5%8F%A5%EF%BC%89"><span class="toc-number">1.8.5.11.</span> <span class="toc-text">实践建议（短句）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.9.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%9B%AE%E7%9A%84"><span class="toc-number">1.9.1.</span> <span class="toc-text">泛型的设计目的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="toc-number">1.9.2.</span> <span class="toc-text">泛型擦除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E8%BE%B9%E7%95%8C%E4%B8%8E%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">1.9.3.</span> <span class="toc-text">泛型边界与通配符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E7%95%8C-extends"><span class="toc-number">1.9.3.1.</span> <span class="toc-text">上界 extends</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E7%95%8C-super"><span class="toc-number">1.9.3.2.</span> <span class="toc-text">下界 super</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E7%95%8C%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">1.9.3.3.</span> <span class="toc-text">无界通配符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PECS%E5%8E%9F%E5%88%99-Producer-Extends-Consumer-Super"><span class="toc-number">1.9.3.4.</span> <span class="toc-text">PECS原则(Producer Extends, Consumer Super)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E5%8F%98-%E9%80%86%E5%8F%98"><span class="toc-number">1.9.4.</span> <span class="toc-text">协变&#x2F;逆变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4-1"><span class="toc-number">1.9.5.</span> <span class="toc-text">泛型擦除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.9.6.</span> <span class="toc-text">最佳实践</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">1.10.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">1.10.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">1.10.2.</span> <span class="toc-text">缺点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.10.3.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.11.</span> <span class="toc-text">注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SPI%E5%92%8CAPI"><span class="toc-number">1.12.</span> <span class="toc-text">SPI和API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">1.13.</span> <span class="toc-text">序列化和反序列化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E7%B3%96"><span class="toc-number">1.14.</span> <span class="toc-text">语法糖</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86"><span class="toc-number">2.</span> <span class="toc-text">Java重要知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%80%BC%E4%BC%A0%E9%80%92%E4%B8%8E%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="toc-number">2.1.</span> <span class="toc-text">值传递与引用传递</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.1.</span> <span class="toc-text">传递基本类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E5%BC%95%E7%94%A8%E5%A4%8D%E5%88%B6"><span class="toc-number">2.1.2.</span> <span class="toc-text">传递引用复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E6%B3%95%E6%94%B9%E5%8F%98%E5%8E%9F%E5%BC%95%E7%94%A8%E7%9A%84%E5%80%BC"><span class="toc-number">2.1.3.</span> <span class="toc-text">无法改变原引用的值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B-%E9%80%9A%E9%85%8D%E7%AC%A6%E8%AF%A6%E8%A7%A3"><span class="toc-number">2.2.</span> <span class="toc-text">泛型&amp;通配符详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.2.1.</span> <span class="toc-text">一、泛型的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%B3%9B%E5%9E%8B"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">1.1 为什么需要泛型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">2.2.2.</span> <span class="toc-text">二、泛型的基本用法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">2.1 泛型类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">2.2 泛型接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">2.3 泛型方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E9%99%90%E5%88%B6"><span class="toc-number">2.2.3.</span> <span class="toc-text">三、泛型的类型参数限制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E7%9A%84%E9%99%90%E5%88%B6%EF%BC%88%E7%B1%BB%E5%9E%8B%E8%BE%B9%E7%95%8C%EF%BC%89"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">3.1 类型变量的限制（类型边界）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E5%A4%9A%E4%B8%AA%E8%BE%B9%E7%95%8C"><span class="toc-number">2.2.3.2.</span> <span class="toc-text">3.2 多个边界</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">2.2.3.3.</span> <span class="toc-text">3.3 类型参数命名规范</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%80%9A%E9%85%8D%E7%AC%A6%EF%BC%88Wildcards%EF%BC%89"><span class="toc-number">2.2.4.</span> <span class="toc-text">四、通配符（Wildcards）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E6%97%A0%E7%95%8C%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">4.1 无界通配符 ?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E4%B8%8A%E7%95%8C%E9%80%9A%E9%85%8D%E7%AC%A6-extends-T"><span class="toc-number">2.2.4.2.</span> <span class="toc-text">4.2 上界通配符 ? extends T</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-%E4%B8%8B%E7%95%8C%E9%80%9A%E9%85%8D%E7%AC%A6-super-T"><span class="toc-number">2.2.4.3.</span> <span class="toc-text">4.3 下界通配符 ? super T</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81PECS%E5%8E%9F%E5%88%99%EF%BC%88Producer-Extends-Consumer-Super%EF%BC%89"><span class="toc-number">2.2.5.</span> <span class="toc-text">五、PECS原则（Producer Extends, Consumer Super）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E5%8E%9F%E5%88%99%E8%AF%B4%E6%98%8E"><span class="toc-number">2.2.5.1.</span> <span class="toc-text">5.1 原则说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.2.5.2.</span> <span class="toc-text">5.2 实际应用示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-Collections-copy-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.5.3.</span> <span class="toc-text">5.3 Collections.copy()的实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%EF%BC%88Type-Erasure%EF%BC%89"><span class="toc-number">2.2.6.</span> <span class="toc-text">六、类型擦除（Type Erasure）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="toc-number">2.2.6.1.</span> <span class="toc-text">6.1 什么是类型擦除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">2.2.6.2.</span> <span class="toc-text">6.2 类型擦除的影响</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-%E6%A1%A5%E6%96%B9%E6%B3%95%EF%BC%88Bridge-Method%EF%BC%89"><span class="toc-number">2.2.6.3.</span> <span class="toc-text">6.3 桥方法（Bridge Method）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.2.7.</span> <span class="toc-text">七、泛型的实际应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6"><span class="toc-number">2.2.7.1.</span> <span class="toc-text">7.1 集合框架</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-%E9%80%9A%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">2.2.7.2.</span> <span class="toc-text">7.2 通用工具类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">2.2.7.3.</span> <span class="toc-text">7.3 设计模式中的应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">2.2.8.</span> <span class="toc-text">八、常见问题和注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%EF%BC%88Raw-Type%EF%BC%89"><span class="toc-number">2.2.8.1.</span> <span class="toc-text">8.1 原始类型（Raw Type）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="toc-number">2.2.8.2.</span> <span class="toc-text">8.2 静态成员不能使用类型参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8D%E8%83%BD%E4%BD%9C%E4%B8%BA%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="toc-number">2.2.8.3.</span> <span class="toc-text">8.3 基本类型不能作为类型参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-number">2.2.8.4.</span> <span class="toc-text">8.4 类型推断的限制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-%E6%B3%9B%E5%9E%8B%E4%B8%8E%E9%87%8D%E8%BD%BD"><span class="toc-number">2.2.8.5.</span> <span class="toc-text">8.5 泛型与重载</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E8%8E%B7%E5%8F%96%E6%B3%9B%E5%9E%8B%E4%BF%A1%E6%81%AF%EF%BC%88%E5%8F%8D%E5%B0%84%EF%BC%89"><span class="toc-number">2.2.9.</span> <span class="toc-text">九、获取泛型信息（反射）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%8F%8D%E5%B0%84"><span class="toc-number">2.3.</span> <span class="toc-text">Java反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E7%B1%BB%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">2.3.1.</span> <span class="toc-text">反射获取对象类的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%B1%BB%E5%90%8D-class"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">1. 类名.class</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AF%B9%E8%B1%A1-getClass"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">2. 对象.getClass()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Class-forName-%E2%80%9C%E5%85%A8%E9%99%90%E5%AE%9A%E7%B1%BB%E5%90%8D%E2%80%9D"><span class="toc-number">2.3.1.3.</span> <span class="toc-text">3. Class.forName(“全限定类名”)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%80%9A%E8%BF%87ClassLoader%E5%8A%A0%E8%BD%BD"><span class="toc-number">2.3.1.4.</span> <span class="toc-text">4. 通过ClassLoader加载</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/31/%E7%BD%91%E7%BB%9C/Untitled%201/" title="No title">No title</a><time datetime="2025-12-31T08:40:20.420Z" title="Created 2025-12-31 16:40:20">2025-12-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/31/linux%E5%86%85%E6%A0%B8/" title="No title">No title</a><time datetime="2025-12-31T08:40:20.418Z" title="Created 2025-12-31 16:40:20">2025-12-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/31/%E4%B8%AA%E4%BA%BA%E4%BB%8B%E7%BB%8D/" title="No title">No title</a><time datetime="2025-12-31T08:40:20.418Z" title="Created 2025-12-31 16:40:20">2025-12-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/31/hello-world/" title="Hello World">Hello World</a><time datetime="2025-12-31T08:40:20.417Z" title="Created 2025-12-31 16:40:20">2025-12-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/12/31/Java/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" title="代理模式">代理模式</a><time datetime="2025-12-31T01:52:52.000Z" title="Created 2025-12-31 09:52:52">2025-12-31</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2025 By <a class="footer-bar-link" href="/" title="John Doe" target="_blank">John Doe</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">Articles</div><div class="length-num">38</div></a><a href="/tags/" title="tag"><div class="headline">Tags</div><div class="length-num">6</div></a><a href="/categories/" title="category"><div class="headline">Categories</div><div class="length-num">20</div></a></div><span class="sidebar-menu-item-title">Function</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="Display Mode"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>Display Mode</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/java/" style="font-size: 0.88rem;">java<sup>2</sup></a><a href="/tags/leetcode/" style="font-size: 0.88rem;">leetcode<sup>5</sup></a><a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 0.88rem;">分布式<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 0.88rem;">数据库<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 0.88rem;">算法<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/" style="font-size: 0.88rem;">网络安全<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.14",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 John Doe 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>