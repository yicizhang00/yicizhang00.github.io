---
title: redis
date: 2025-09-22 01:44:36
tags:
  - java

---

# Redis基础

[Redis](https://redis.io/) （**RE**mote **DI**ctionary **S**erver）是一个基于 C 语言开发的开源 NoSQL 数据库（BSD 许可）。与传统数据库不同的是，Redis 的数据是保存在内存中的（内存数据库，支持持久化），因此读写速度非常快，被广泛应用于分布式缓存方向。并且，Redis 存储的是 KV 键值对数据。

为了满足不同的业务场景，Redis 内置了多种数据类型实现（比如 String、Hash、Sorted Set、Bitmap、HyperLogLog、GEO）。并且，Redis 还支持事务、持久化、Lua 脚本、发布订阅模型、多种开箱即用的集群方案（Redis Sentinel、Redis Cluster）。

## Redis的数据类型



1. **String（字符串）**
   - 二进制安全，可以存储任意数据：字符串、数字、甚至图片或序列化数据。
   - 最大容量：单个 value 最多 512MB。
   - 常见操作：`SET`、`GET`、`INCR`、`DECR`、`APPEND`。
   - 使用场景：缓存对象、计数器、分布式锁。
2. **List（列表）**
   - 一个有序的双向链表，可以从两端插入和弹出元素。
   - 保持插入顺序，支持重复元素。
   - 常见操作：`LPUSH`、`RPUSH`、`LPOP`、`RPOP`、`LRANGE`。
   - 使用场景：消息队列、任务队列、最新列表展示（如微博时间线）。
3. **Hash（哈希表）**
   - 存储键值对（field-value），适合存储对象。
   - 常见操作：`HSET`、`HGET`、`HMGET`、`HDEL`。
   - 使用场景：用户信息表（id → {name, age, email}）。
4. **Set（集合）**
   - 无序集合，不允许重复。
   - 底层实现：哈希表，查找和去重效率高。
   - 常见操作：`SADD`、`SMEMBERS`、`SINTER`、`SUNION`、`SDIFF`。
   - 使用场景：去重、好友关系（交集求共同好友，差集求可能认识的人）。
5. **Sorted Set（有序集合，Zset）**
   - 每个成员（member）关联一个分数（score），按分数排序。
   - 分数可以相同，但成员不能重复。
   - 常见操作：`ZADD`、`ZRANGE`、`ZREVRANGE`、`ZRANK`、`ZREM`。
   - 使用场景：排行榜（按分数、时间排序）、带权重的数据。

6. **Bitmap（位图）**

- 基于 String 的位操作，节省存储空间。
- 常见操作：`SETBIT`、`GETBIT`、`BITCOUNT`。
- 使用场景：签到打卡、用户在线状态统计、布隆过滤器底层。

7. **HyperLogLog**

- 用于基数统计（去重计数），占用空间固定（12KB）。
- 常见操作：`PFADD`、`PFCOUNT`、`PFMERGE`。
- 使用场景：网站 UV 统计、活跃用户数。

8. **Geospatial（地理空间数据）**

- 基于 Zset 实现，可以存储经纬度并进行范围查询。
- 常见操作：`GEOADD`、`GEODIST`、`GEORADIUS`。
- 使用场景：附近的人、地图服务。

9. **Stream（流，Redis 5.0 引入）**

- 消息队列结构，支持持久化和消费组。
- 常见操作：`XADD`、`XREAD`、`XGROUP`、`XREADGROUP`。
- 使用场景：消息队列、日志系统、实时数据处理。

| 类型        | 是否有序 | 是否允许重复 | 典型场景         |
| ----------- | -------- | ------------ | ---------------- |
| String      | 否       | 否           | 缓存、计数器、锁 |
| List        | 有序     | 允许         | 队列、时间线     |
| Hash        | 无序     | field 唯一   | 存储对象信息     |
| Set         | 无序     | 否           | 去重、集合运算   |
| Sorted Set  | 有序     | 否           | 排行榜           |
| Bitmap      | 位序列   | 位唯一       | 签到、状态标记   |
| HyperLogLog | N/A      | 概率去重     | UV 统计          |
| Geo         | 按距离   | 否           | 地理位置服务     |
| Stream      | 有序     | 允许         | 消息队列         |

## redis效能

1. 纯内存操作：所有读写发生在内存中，而非持久化到磁盘上。
2. 高效的IO模型：采用了单线程事件以及IO多路复用。
3. 优化的内部数据结构：如ziplist，quicklist，skiplist，hashtable
4. 采用了自定义的通信协议：RESP

## 其他的分布式缓存技术

### Memcached

## Tendis

## Dragonfly

## keyDB

## Faster



# Redis常见问题



## 问什么要用分布式缓存

| 特性         | 本地缓存                             | Redis                            |
| ------------ | ------------------------------------ | -------------------------------- |
| 数据一致性   | 多服务器部署时存在数据不一致问题     | 数据一致                         |
| 内存限制     | 受限于单台服务器内存                 | 独立部署，内存空间更大           |
| 数据丢失风险 | 服务器宕机数据丢失                   | 可持久化，数据不易丢失           |
| 管理维护     | 分散，管理不便                       | 集中管理，提供丰富的管理工具     |
| 功能丰富性   | 功能有限，通常只提供简单的键值对存储 | 功能丰富，支持多种数据结构和功能 |

## 常见的缓存更新策略有哪些

### Cache Aside(旁路缓存)

写流程：

1. 更新DB
2. 删除缓存

读流程：

1. 查缓存，命中直接返回，未命中转2
2. 查数据库
3. 更新缓存

**为什么写流程不能先删除后更新？**

#### 场景复现（先删除后写）

1. **线程 A**：删除缓存。
2. **线程 B**：读取数据，发现缓存没了，去查数据库，读到的是旧值。
3. **线程 A**：更新数据库。
4. **线程 B**：把旧值写回缓存。

👉 结果：**缓存里是旧值**，数据库里是新值，缓存和数据库不一致。

#### 场景复现（先写后删除）

1. **线程 A**：更新数据库。
2. **线程 B**：读取数据，发现缓存存在，直接返回旧值。
3. **线程 A**：删除缓存。
4. **线程 C**：读取数据，发现缓存不存在，去数据库里面查数据库，然后更新缓存。

👉 结果：到线程B时**缓存为空**，数据库里是新值，缓存和数据库**短暂**不一致，短暂不一致在后续线程C时会更新缓存保证**最终一致性**。

#### 场景复现（先写后删除依旧有问题）

1. **线程 A**：读取数据，但数据不在缓存中，去数据库中读取到旧数据。
2. **线程 B**：写数据库。
3. **线程 B**：删除缓存。
4. **线程 A**：更新缓存为旧数据。

👉 结果：此时仍然会出现缓存和DB数据不一致的情况。

#### 优化手段

延迟双删：为了解决短暂的不一致性，更新数据库后：先写数据库→ 删缓存 → sleep 一段时间 → 再删一次缓存，能够解决并发读写导致的脏数据。确保第二次删除能够覆盖所有旧数据的缓存。

- 优点：
  - 适合缓存一致性要求高，但无法满足完全实时一致性。

- 缺点：
  - 增加系统复杂度。
  - 无法满足会完全实时一致性的场景。

**缺点1**：**解决首次请求数据一定不在 cache 的问题**，将热点数据提前放入redis中。

**缺点2**：

数据库和缓存数据强一致场景：更新 db 的时候同样更新 cache，不过我们需要加一个锁/分布式锁来保证更新 cache 的时候不存在线程安全问题。

可以短暂地允许数据库和缓存数据不一致的场景：更新 db 的时候同样更新 cache，但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小。

### Read Through Pattern 读穿透

读：

1. 查缓存，命中直接返回，未命中转2
2. 查数据库，更新缓存，返回数据库



### Write Through Pattern（写穿透）

写：

1. 先查cache，cache不存在，直接更新db
2. cache中存在，先更新cache，**同步**更新DB（缓存和DB在同一事务中写）

Read-Through Pattern 实际只是在 Cache-Aside Pattern 之上进行了封装。在 Cache-Aside Pattern 下，发生读请求的时候，如果 cache 中不存在对应的数据，是由客户端自己负责把数据写入 cache，而 Read Through Pattern 则是 cache 服务自己来写入缓存的，这对客户端是透明的。

> 实际上redis并不提供读写穿透的策略，redis自己无法去写DB

### Read Back （写回）

写：

1. 先查cache，cache不存在，直接更新db
2. cache中存在，先更新cache，**异步**更新DB

优点：

​	减少数据库压力

缺点：

​	数据丢失风险（缓存宕机，数据没落库）。

​	一致性较弱，适合对一致性要求不高的场景。

## Redis的功能

### 分布式锁



### 限流



### 消息队列



### 延时队列



### 分布式Session



### 其他业务场景
