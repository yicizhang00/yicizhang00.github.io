---
title: 设计模式
date: 2025-08-12 01:55:16
tags:
categories: 
  - 设计模式
  - java
---

# 设计原则



# 设计模式

## 创建型模式

### 1.单例模式

**核心思想**：某个类只有一个实例，并且提供一个全局访问点来获取这个实例。
 **结构**：构造器私有化 + 静态实例 + 全局访问方法。
 **适用场景**：配置对象、线程池、日志系统。
 **优点**：控制全局唯一对象，节省资源。
 **缺点**：全局状态可能导致代码难以测试。
 **应用**：`Runtime.getRuntime()`，Spring 默认 bean 单例。

#### 1.**饿汉式（Eager Initialization）**

```java
public class Singleton {
    private static final Singleton instance = new Singleton();
    private Singleton() {}
    public static Singleton getInstance() {
        return instance;
    }
}
```

特点：饿汉式在类加载时就创建对象，即在类的Initialization（加载）阶段创建。

优点：线程安全简单。

缺点：一开始就加载可能会导致内存浪费。



#### 2.懒汉式（Lazy Initialization，线程不安全）

```java
public class Singleton {
    private static Singleton instance;
    private Singleton() {}
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}

```

特点：只有在需要用到这个实例时才进行第一次创建。

缺点：多线程环境下，可能有多个线程同时进入`if(instance==null)`中，导致创建多个实例。



#### 3.懒汉式（线程安全版）

```java
public class Singleton {
    private static Singleton instance;
    private Singleton() {}
    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}

```

1. 在实例方法加锁

```
public synchronized void foo() {
    // ...
}

```

等价于

```
public void foo() {
    synchronized(this) {
        // ...
    }
}

```

- 锁的对象是 **当前实例 (this)**。

- 同一个对象的多个 `synchronized` 实例方法，调用时会互斥。

- 不同对象之间互不影响。

2. 在静态方法加锁

```
public static synchronized void bar() {
    // ...
}

```

等价于

```
public static void bar() {
    synchronized (Singleton.class) {
        // ...
    }
}

```

- 锁的对象是 **类的 `Class` 对象**。

- 整个类范围内（所有实例）共享一把锁。无论从哪个对象或类名调用，都要竞争 **同一把类锁**。

特点：因此懒汉式的线程安全版加的是静态方法锁，即对整个类的对象加锁。

优点：线程安全

缺点：每次调用都需要加锁，效率低。

#### 4.双重检查锁(DCL)

```java
public class Singleton {
    private static volatile Singleton instance;
    private Singleton() {}
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized(Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}

```

其中`volatile`关键字防止指令重排，在Java中创建一个对象可以大概分为三步：

```
memory = allocate();         // 1. 分配内存
ctorInstance(memory);        // 2. 初始化对象
instance = memory;           // 3. 将 instance 指向内存

```

而JIT和CPU的指令重排会导致

```
memory = allocate();         // 1. 分配内存
instance = memory;           // 2. 将 instance 指向内存
ctorInstance(memory);        // 3. 初始化对象
```

那么一个对象在`if(instance==null)`可能会直接`return`一个存在引用但是未初始化完成的对象。

优点：对比整体加锁，外层的if循环可以在已经存在实例时直接返回单例对象。

#### 5.静态内部类

```
public class Singleton {
    private Singleton() {}

    private static class Holder {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getInstance() {
        return Holder.INSTANCE;
    }
}

```

**外部类 `Singleton` 的加载**
 当 JVM 加载 `Singleton.class` 时，并不会立即加载 `Holder` 类。
 所以此时单例对象 **还没有被创建**。

**`Holder` 的加载与初始化**
 只有在第一次调用 `Singleton.getInstance()` 时，才会触发对 `Holder` 类的主动使用，从而导致 `Holder` 被 **加载并初始化**。
 在 `Holder` 初始化阶段，`INSTANCE = new Singleton()` 才会执行。

**线程安全保证**
 JVM 在类的初始化阶段会保证：

- `<clinit>()` 方法（即类的静态初始化逻辑）对同一个类只会被执行一次
- 并且是由 JVM 保证的 **同步过程**
   因此不需要 `synchronized`，天然线程安全。

特点：采用了JVM的同步过程保证只会加载一次。

#### 6.枚举类

```java
public enum Singleton {
    INSTANCE;

    public void doSomething() {
        System.out.println("working...");
    }
}
```

特点：天然防止反射和序列化破坏。**反射破坏不了**（JVM 层面禁止），**序列化也破坏不了**（JVM 自动处理）。

缺点：语义上可能不如类清晰。

#### SLF4J的单例模式

在`LoggerFactory`中我们可以得到一个存储各个类的ConcurrentHashMap，使用其保证每个类只有一个实例

```java
public class LoggerFactory {
    // 使用ConcurrentHashMap存储已创建的Logger实例
    private static final ConcurrentHashMap<String, Logger> loggerMap = new ConcurrentHashMap<>();

    public static Logger getLogger(Class<?> clazz) {
        return getLogger(clazz.getName());
    }

    public static Logger getLogger(String name) {
        // 先检查缓存中是否存在
        Logger logger = loggerMap.get(name);
        if (logger != null) {
            return logger;
        }

        // 不存在则创建，并放入缓存
        logger = new Logger(name);
        Logger existingLogger = loggerMap.putIfAbsent(name, logger);
        return existingLogger != null ? existingLogger : logger;
    }
}
```

对于每一个类创建唯一一个`Logger`对象，使用ConcurrentHashMap保持线程安全

```java
// 在类A中
private static final Logger logger = LoggerFactory.getLogger(ClassA.class);

// 在类B中
private static final Logger logger = LoggerFactory.getLogger(ClassB.class);
```

### 2.工厂方法模式

**核心思想**：定义一个创建对象的接口，让子类决定实例化哪个类。
**结构**：抽象工厂接口 + 具体工厂实现。
**适用场景**：需要根据环境决定创建的对象。
**优点**：解耦对象创建和使用。
**缺点**：类数量增加。
**应用**：SLF4J的`LoggerFactory`，JDBC的`DriverManager.getConnection()`和`Iterator<E> iteator()`方法

工厂方法模式主要有以下角色：

1. **Product（产品接口/抽象类）**
    定义产品的抽象（如 `Button` 接口）。

```java
public interface Button {
    void render();
}
```

2. **ConcreteProduct（具体产品类）**
    实现 Product 接口（如 `WindowsButton`, `MacButton`）。

```java
public class WindowsButton implements Button {
    public void render() {
        System.out.println("Render a Windows style button");
    }
}

public class MacButton implements Button {
    public void render() {
        System.out.println("Render a Mac style button");
    }
}

```

3. **Creator（抽象工厂/创建者）**
    声明工厂方法，返回 Product。

```java
public abstract class Dialog {
    // 工厂方法，返回抽象产品
    public abstract Button createButton();

    // 使用工厂方法
    public void renderWindow() {
        Button okButton = createButton();
        okButton.render();
    }
}

```

4. **ConcreteCreator（具体工厂类）**
    实现工厂方法，返回具体的 ConcreteProduct。

```java
public class WindowsDialog extends Dialog {
    public Button createButton() {
        return new WindowsButton();
    }
}

public class MacDialog extends Dialog {
    public Button createButton() {
        return new MacButton();
    }
}
```

5. 客户端实例化过程

```java
public class Client {
    public static void main(String[] args) {
        Dialog dialog;

        String os = System.getProperty("os.name").toLowerCase();
        if (os.contains("win")) {
            dialog = new WindowsDialog();
        } else {
            dialog = new MacDialog();
        }

        dialog.renderWindow(); // 使用工厂方法创建按钮
    }
}

```

优点

- 符合 **开闭原则**：新增产品时，只需要新增工厂类，不改原有代码。
- 客户端只依赖抽象，降低耦合。
- 容易扩展产品族。

缺点

- 每增加一个产品类，就要写一个新的工厂类，类的数量会增加。
- 结构比简单工厂复杂。

### 3.抽象工厂方法模式

**抽象工厂模式是一种创建型设计模式**，它提供一个接口，可以创建一系列相关或相互依赖的对象，而无需指定它们的具体类。

**AbstractProduct（抽象产品）**
 每个产品的抽象（例如 `Button`, `Checkbox`）。

```java
// 按钮接口
public interface Button {
    void paint();
}

// 复选框接口
public interface Checkbox {
    void paint();
}

```



**ConcreteProduct（具体产品）**
 具体产品实现（如 `WindowsButton`, `MacButton`）。

```java
public class WindowsButton implements Button {
    public void paint() {
        System.out.println("Render a button in Windows style.");
    }
}

public class MacButton implements Button {
    public void paint() {
        System.out.println("Render a button in Mac style.");
    }
}

public class WindowsCheckbox implements Checkbox {
    public void paint() {
        System.out.println("Render a checkbox in Windows style.");
    }
}

public class MacCheckbox implements Checkbox {
    public void paint() {
        System.out.println("Render a checkbox in Mac style.");
    }
}

```



**AbstractFactory（抽象工厂）**
 定义创建一组抽象产品的方法。

```java
public interface GUIFactory {
    Button createButton();
    Checkbox createCheckbox();
}

```

**ConcreteFactory（具体工厂）**
 实现抽象工厂的方法，生产具体产品族。

```java
public class WindowsFactory implements GUIFactory {
    public Button createButton() {
        return new WindowsButton();
    }
    public Checkbox createCheckbox() {
        return new WindowsCheckbox();
    }
}

public class MacFactory implements GUIFactory {
    public Button createButton() {
        return new MacButton();
    }
    public Checkbox createCheckbox() {
        return new MacCheckbox();
    }
}

```

**Client（客户端）**
 通过抽象工厂获取产品，只依赖抽象，不关心具体实现。

```java
public class Application {
    private Button button;
    private Checkbox checkbox;

    public Application(GUIFactory factory) {
        button = factory.createButton();
        checkbox = factory.createCheckbox();
    }

    public void render() {
        button.paint();
        checkbox.paint();
    }

    public static void main(String[] args) {
        GUIFactory factory;

        String os = System.getProperty("os.name").toLowerCase();
        if (os.contains("win")) {
            factory = new WindowsFactory();
        } else {
            factory = new MacFactory();
        }

        Application app = new Application(factory);
        app.render();
    }
}

```

### 4.建造者模式

建造者模式是一种将复杂对象的构造过程与表示分离的设计模式，使得同样的构建过程可以创建不同的表示。

#### 内部静态类

```java

public class House {
    private String foundation;
    private String walls;
    private String roof;
    private boolean hasGarage;
    private boolean hasGarden;

    private House(Builder builder) {
        this.foundation = builder.foundation;
        this.walls = builder.walls;
        this.roof = builder.roof;
        this.hasGarage = builder.hasGarage;
        this.hasGarden = builder.hasGarden;
    }

    public static class Builder {
        private String foundation;
        private String walls;
        private String roof;
        private boolean hasGarage;
        private boolean hasGarden;

        public Builder foundation(String foundation) {
            this.foundation = foundation;
            return this;
        }
        public Builder walls(String walls) {
            this.walls = walls;
            return this;
        }
        public Builder roof(String roof) {
            this.roof = roof;
            return this;
        }
        public Builder garage(boolean hasGarage) {
            this.hasGarage = hasGarage;
            return this;
        }
        public Builder garden(boolean hasGarden) {
            this.hasGarden = hasGarden;
            return this;
        }
        public House build() {
            return new House(this);
        }
    }

    @Override
    public String toString() {
        return "House [foundation=" + foundation + ", walls=" + walls + 
               ", roof=" + roof + ", garage=" + hasGarage + ", garden=" + hasGarden + "]";
    }
}

```

#### 客户端

```java
House house = new House.Builder()
    .foundation("Concrete")
    .walls("Brick")
    .roof("Tile")
    .garage(true)
    .garden(false)
    .build();
System.out.println(house);

```

#### ✅ 优点

- 将复杂对象的构建和表示分离，代码更清晰。
- 支持链式调用，易读性强。
- 可以复用构造步骤，创建不同对象。
- 符合 **单一职责原则**：Builder 负责构造，Product 负责表示。

#### ❌ 缺点

- 类数量可能增多（传统写法需要多个 Builder、Director）。
- 不适合简单对象（会显得过度设计）。

#### Lombok 的 @Builder

Lombok 通过在类或构造器/方法上加 `@Builder`，**自动生成内部静态 Builder 类**，省去手写 Builder 的麻烦。

```java
import lombok.Builder;
import lombok.ToString;

@Builder
@ToString
public class User {
    private String name;
    private int age;
    private String email;
    private String password;
}

```

编译后，Lombok 会帮你生成一个 `UserBuilder` 类，支持链式调用：

```java
User user = User.builder()
        .name("Tom")
        .age(20)
        .email("tom@example.com")
        .password("123456")
        .build();

System.out.println(user);

```

#### StringBuilder

使用`append()`不断追加内容，最后通过`toString()`得到结果。`StringBuilder` 不是严格的 **建造者模式**，但用法上体现了 **Builder 模式的思想**：链式构建、最后生成结果。

```java
public class Main {
    public static void main(String[] args) {
        StringBuilder sb = new StringBuilder();

        String result = sb.append("Hello")
                          .append(", ")
                          .append("World")
                          .append("!")
                          .toString();

        System.out.println(result); // Hello, World!
    }
}

```



### 5.原型模式

#### 1. **浅拷贝（Shallow Copy）**

- 拷贝对象本身，但引用类型属性只拷贝引用，不拷贝对象本身。
- 即 **共享引用**。
- 可能会引发 <mark>改一处动全身</mark> 的问题

#### 2. **深拷贝（Deep Copy）**

- 不仅拷贝对象本身，还拷贝它引用的所有对象。
- 新对象完全独立，不会共享引用。

实现方法：

- 手写 `clone()`，在里面递归克隆引用对象。
- 或者通过序列化/反序列化实现。

#### Java中应用

- `ArrayList.clone()`（浅拷贝）。

  `HashMap.clone()`（浅拷贝）。

- Java 提供了 **`Cloneable` 接口** + **`Object.clone()` 方法**。
- 但是：
  - `Cloneable` 是一个**标记接口**，不定义方法。
  - 必须重写 `clone()` 并调用 `super.clone()`。
  - 否则会抛出 `CloneNotSupportedException`。

很多框架（如 Spring）更推荐 **拷贝构造函数 / 工具类（如 Apache Commons Lang 的 `SerializationUtils.clone()`）** 来做深拷贝。

## 结构型模式

### 适配器模式

**核心思想**：将不兼容的接口转换为可用接口。
 **结构**：Adapter 包装 Adaptee。
 **适用场景**：老代码接口不兼容。
 **优点**：复用已有类。
 **缺点**：类层次复杂化。
 **应用**：`InputStreamReader`，Spring MVC 参数适配器。

1. 类适配器（继承）

- `Adapter` 继承 `Adaptee`，实现 `Target` 接口。

- 通过继承获得 `Adaptee` 的功能。

2. 组合适配（持有引用）

- `Adapter` 持有 `Adaptee` 的引用，转发调用。
- 更灵活（可以适配多个不同的 `Adaptee`）。

3. 接口适配器

- 提供一个抽象类，实现接口的所有方法为空实现。
- 子类可以选择性地重写需要的方法。
- 常用于回调接口场景（比如 Java AWT/Swing 的监听器）。

#### Java中的标准适配器

- [`java.util.Arrays#asList()`](https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList-T...-)
- [`java.util.Collections#list()`](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#list-java.util.Enumeration-)
- [`java.util.Collections#enumeration()`](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#enumeration-java.util.Collection-)
- [`java.io.InputStreamReader(InputStream)`](https://docs.oracle.com/javase/8/docs/api/java/io/InputStreamReader.html#InputStreamReader-java.io.InputStream-) （返回 `Reader`对象）
- [`java.io.OutputStreamWriter(OutputStream)`](https://docs.oracle.com/javase/8/docs/api/java/io/OutputStreamWriter.html#OutputStreamWriter-java.io.OutputStream-) （返回 `Writer`对象）
- [`javax.xml.bind.annotation.adapters.XmlAdapter#marshal()`](https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/adapters/XmlAdapter.html#marshal-BoundType-) 和 `#unmarshal()`

`java.util.Collections#list()`不完全是适配器模式，要实现适配器模式类似于以下方式，将Enumeration转为Iterator

```java
class EnumerationIterator<T> implements Iterator<T> {
    private Enumeration<T> enumeration;

    public EnumerationIterator(Enumeration<T> enumeration) {
        this.enumeration = enumeration;
    }

    @Override
    public boolean hasNext() {
        return enumeration.hasMoreElements();
    }

    @Override
    public T next() {
        return enumeration.nextElement();
    }
}
```

#### java的实现例子

让方钉适配圆孔

圆孔：

```java
package refactoring_guru.adapter.example.round;

/**
 * RoundHoles are compatible with RoundPegs.
 */
public class RoundHole {
    private double radius;

    public RoundHole(double radius) {
        this.radius = radius;
    }

    public double getRadius() {
        return radius;
    }

    public boolean fits(RoundPeg peg) {
        boolean result;
        result = (this.getRadius() >= peg.getRadius());
        return result;
    }
}
```

圆钉：

```java
package refactoring_guru.adapter.example.round;

/**
 * RoundPegs are compatible with RoundHoles.
 */
public class RoundPeg {
    private double radius;

    public RoundPeg() {}

    public RoundPeg(double radius) {
        this.radius = radius;
    }

    public double getRadius() {
        return radius;
    }
}
```

方钉：

```java
package refactoring_guru.adapter.example.square;

/**
 * SquarePegs are not compatible with RoundHoles (they were implemented by
 * previous development team). But we have to integrate them into our program.
 */
public class SquarePeg {
    private double width;

    public SquarePeg(double width) {
        this.width = width;
    }

    public double getWidth() {
        return width;
    }

    public double getSquare() {
        double result;
        result = Math.pow(this.width, 2);
        return result;
    }
}
```
适配器
```java
package refactoring_guru.adapter.example.adapters;

import refactoring_guru.adapter.example.round.RoundPeg;
import refactoring_guru.adapter.example.square.SquarePeg;

/**
 * Adapter allows fitting square pegs into round holes.
 */
public class SquarePegAdapter extends RoundPeg {
    private SquarePeg peg;

    public SquarePegAdapter(SquarePeg peg) {
        this.peg = peg;
    }

    @Override
    public double getRadius() {
        double result;
        // Calculate a minimum circle radius, which can fit this peg.
        result = (Math.sqrt(Math.pow((peg.getWidth() / 2), 2) * 2));
        return result;
    }
}

```
客户端
```java
package refactoring_guru.adapter.example;

import refactoring_guru.adapter.example.adapters.SquarePegAdapter;
import refactoring_guru.adapter.example.round.RoundHole;
import refactoring_guru.adapter.example.round.RoundPeg;
import refactoring_guru.adapter.example.square.SquarePeg;

/**
 * Somewhere in client code...
 */
public class Demo {
    public static void main(String[] args) {
        // Round fits round, no surprise.
        RoundHole hole = new RoundHole(5);
        RoundPeg rpeg = new RoundPeg(5);
        if (hole.fits(rpeg)) {
            System.out.println("Round peg r5 fits round hole r5.");
        }

        SquarePeg smallSqPeg = new SquarePeg(2);
        SquarePeg largeSqPeg = new SquarePeg(20);
        // hole.fits(smallSqPeg); // Won't compile.

        // Adapter solves the problem.
        SquarePegAdapter smallSqPegAdapter = new SquarePegAdapter(smallSqPeg);
        SquarePegAdapter largeSqPegAdapter = new SquarePegAdapter(largeSqPeg);
        if (hole.fits(smallSqPegAdapter)) {
            System.out.println("Square peg w2 fits round hole r5.");
        }
        if (!hole.fits(largeSqPegAdapter)) {
            System.out.println("Square peg w20 does not fit into round hole r5.");
        }
    }
}
```

#### ✅ 优点

- 解耦：客户端和被适配类解耦。
- 复用：复用已有功能，无需改源码。
- 灵活：对象适配器方式支持组合多个适配对象。

#### ❌ 缺点

- 增加了系统复杂度，多了一层转换。
- 类适配器方式受限于单继承。

### 装饰器模式

**核心思想**：在不修改对象代码的前提下动态添加功能。
 **结构**：Decorator 包含被装饰对象。
 **适用场景**：多层功能增强。
 **优点**：比继承更灵活。
 **缺点**：多层装饰会难以调试。
 **应用**：Java I/O 流。

> 在不改变原有对象结构的前提下，动态地给对象增加新的功能。

- 它通过“包装”一个对象来增强功能，而不是通过继承。
- 使用同一个接口，保证客户端无感知。

#### java实现例子

```
interface Component {
    void operation();
}

class ConcreteComponent implements Component {
    public void operation() {
        System.out.println("执行基本操作");
    }
}

```

抽象装饰器

```
abstract class Decorator implements Component {
    protected Component component;

    public Decorator(Component component) {
        this.component = component;
    }

    @Override
    public void operation() {
        component.operation(); // 默认转发
    }
}

```

具体装饰器

```
class LoggingDecorator extends Decorator {
    public LoggingDecorator(Component component) {
        super(component);
    }

    @Override
    public void operation() {
        System.out.println("记录日志...");
        super.operation();
    }
}

class SecurityDecorator extends Decorator {
    public SecurityDecorator(Component component) {
        super(component);
    }

    @Override
    public void operation() {
        System.out.println("检查权限...");
        super.operation();
    }
}

```
客户端使用

```java
public class Client {
    public static void main(String[] args) {
        Component c = new ConcreteComponent();

        // 增强功能：先权限检查，再日志记录，再执行基本操作
        Component decorated = new LoggingDecorator(new SecurityDecorator(c));
        decorated.operation();
    }
}

```

#### 现实例子

**Java IO**

- `InputStream` 是抽象构件。

- `FileInputStream` 是具体构件。

- `BufferedInputStream`、`DataInputStream`、`ZipInputStream` 是装饰器。

- 它们可以层层嵌套：

  ```
  InputStream in = new BufferedInputStream(
                       new DataInputStream(
                           new FileInputStream("test.txt")));
  ```

**Spring**

- Spring AOP 的 `BeanPostProcessor` 本质上也是装饰思想：在 Bean 初始化前后加功能。

**GUI 框架**

- 滚动条装饰器 `ScrollBarDecorator` 可以给窗口动态加滚动条。

#### ✅ 优点

- **扩展性强**：不修改原有类就能添加功能。
- **灵活组合**：不同装饰器可以任意组合。
- **遵循开闭原则**：对扩展开放，对修改关闭。

#### ❌ 缺点

- 对象层层包装，调试时可能比较复杂。
- 装饰链过长时，可能影响性能和可读性。
